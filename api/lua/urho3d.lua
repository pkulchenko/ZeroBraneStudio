-- Urho3D API generated on 2014-03-29

local api = {

  -- Classes
  AnimatedModel = {
    childs = {
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      AddAnimationState = {
        args = "(Animation* animation)",
        description = "Add an animation.",
        returns = "(AnimationState*)",
        valuetype = "AnimationState",
        type = "method"
      },
      RemoveAnimationState = {
        args = "(Animation* animation)",
        description = "() RemoveAnimationState (const String animationName),\n() RemoveAnimationState (StringHash animationNameHash),\n() RemoveAnimationState (AnimationState* state),\n() RemoveAnimationState (unsigned index)\nRemove an animation by animation pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAllAnimationStates = {
        args = "()",
        description = "Remove all animations.",
        returns = "()",
        type = "method"
      },
      SetAnimationLodBias = {
        args = "(float bias)",
        description = "Set animation LOD bias.",
        returns = "()",
        type = "method"
      },
      SetUpdateInvisible = {
        args = "(bool enable)",
        description = "Set whether to update animation and the bounding box when not visible. Recommended to enable for physically controlled models like ragdolls.",
        returns = "()",
        type = "method"
      },
      SetMorphWeight = {
        args = "(const String name, float weight)",
        description = "() SetMorphWeight (StringHash nameHash, float weight),\n() SetMorphWeight (unsigned index, float weight)\nSet vertex morph weight by name.",
        returns = "()",
        type = "method"
      },
      ResetMorphWeights = {
        args = "()",
        description = "Reset all vertex morphs to zero.",
        returns = "()",
        type = "method"
      },
      GetSkeleton = {
        args = "()",
        description = "Return skeleton.",
        returns = "(Skeleton&)",
        valuetype = "Skeleton",
        type = "method"
      },
      GetNumAnimationStates = {
        args = "()",
        description = "Return number of animation states.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAnimationState = {
        args = "(Animation* animation)",
        description = "(AnimationState*) GetAnimationState (const String animationName),\n(AnimationState*) GetAnimationState (const StringHash animationNameHash),\n(AnimationState*) GetAnimationState (unsigned index)\nReturn animation state by animation pointer.",
        returns = "(AnimationState*)",
        valuetype = "AnimationState",
        type = "method"
      },
      GetAnimationLodBias = {
        args = "()",
        description = "Return animation LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetUpdateInvisible = {
        args = "()",
        description = "Return whether to update animation when not visible.",
        returns = "(bool)",
        type = "method"
      },
      GetNumMorphs = {
        args = "()",
        description = "Return number of vertex morphs.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMorphWeight = {
        args = "(const String name)",
        description = "(float) GetMorphWeight (StringHash nameHash),\n(float) GetMorphWeight (unsigned index)\nReturn vertex morph weight by name.",
        returns = "(float)",
        type = "method"
      },
      IsMaster = {
        args = "()",
        description = "Return whether is the master (first) animated model.",
        returns = "(bool)",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*",
        type = "value"
      },
      skeleton = {
        valuetype = "Skeleton",
        description = "(Readonly) Skeleton&\nSkeleton.",
        type = "value"
      },
      numAnimationStates = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      animationLodBias = {
        description = "float\nAnimation LOD bias.",
        type = "value"
      },
      updateInvisible = {
        description = "bool\nUpdate animation when invisible flag.",
        type = "value"
      },
      numMorphs = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      master = {
        description = "(Readonly) bool",
        type = "value"
      },
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "(bool) SetMaterial (unsigned index, Material* material)\nSet material on all geometries.",
        returns = "()",
        type = "method"
      },
      SetOcclusionLodLevel = {
        args = "(unsigned level)",
        description = "Set occlusion LOD level. By default (M_MAX_UNSIGNED) same as visible.",
        returns = "()",
        type = "method"
      },
      ApplyMaterialList = {
        args = "(const String fileName = String::EMPTY)",
        description = "Apply default materials from a material list file. If filename is empty (default), the model's resource name with extension .txt will be used.",
        returns = "()",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaterial = {
        args = "(unsigned index = 0)",
        description = "Return material by geometry index.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetOcclusionLodLevel = {
        args = "()",
        description = "Return occlusion LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Determines if the given world space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideLocal = {
        args = "(const Vector3& point)",
        description = "Determines if the given local space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      numGeometries = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      occlusionLodLevel = {
        description = "unsigned\nOcclusion LOD level.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  AnimatedSprite2D = {
    childs = {
      SetSpeed = {
        args = "(float speed)",
        description = "Set speed.",
        returns = "()",
        type = "method"
      },
      SetCycleMode = {
        args = "(CycleMode cycleMode)",
        description = "Set cycle mode.",
        returns = "()",
        type = "method"
      },
      SetAnimation = {
        args = "(Animation2D* animation)",
        description = "Set animation.",
        returns = "()",
        type = "method"
      },
      GetSpeed = {
        args = "()",
        description = "Return speed.",
        returns = "(float)",
        type = "method"
      },
      GetCycleMode = {
        args = "()",
        description = "Return cycle mode.",
        returns = "(CycleMode)",
        type = "method"
      },
      GetAnimation = {
        args = "()",
        description = "Return Animation.",
        returns = "(Animation2D*)",
        valuetype = "Animation2D",
        type = "method"
      },
      speed = {
        description = "float\nSpeed.",
        type = "value"
      },
      cycleMode = {
        description = "CycleMode\nCycle mode.",
        type = "value"
      },
      animation = {
        valuetype = "Animation2D",
        description = "Animation2D*\nAnimation.",
        type = "value"
      },
      SetFlip = {
        args = "(bool flipX, bool flipY)",
        description = "Set flip.",
        returns = "()",
        type = "method"
      },
      SetFlipX = {
        args = "(bool flipX)",
        description = "Set flip X.",
        returns = "()",
        type = "method"
      },
      SetFlipY = {
        args = "(bool flipY)",
        description = "Set flip Y.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "Set color.",
        returns = "()",
        type = "method"
      },
      GetFlipX = {
        args = "()",
        description = "Return flip X.",
        returns = "(bool)",
        type = "method"
      },
      GetFlipY = {
        args = "()",
        description = "Return flip Y.",
        returns = "(bool)",
        type = "method"
      },
      GetColor = {
        args = "()",
        description = "Return color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      flipX = {
        description = "bool\nFlip X.",
        type = "value"
      },
      flipY = {
        description = "bool\nFlip Y.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColor.",
        type = "value"
      },
      SetPixelsPerUnit = {
        args = "(float pixelsPerUnit)",
        description = "Set pixels per coordinate unit.",
        returns = "()",
        type = "method"
      },
      SetSprite = {
        args = "(Sprite2D* sprite)",
        description = "Set sprite.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetZValue = {
        args = "(float zValue)",
        description = "Set Z value.",
        returns = "()",
        type = "method"
      },
      GetPixelsPerUnit = {
        args = "()",
        description = "Return pixels per coordinate unit.",
        returns = "(float)",
        type = "method"
      },
      GetSprite = {
        args = "()",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      GetZValue = {
        args = "()",
        description = "Return Z value.",
        returns = "(float)",
        type = "method"
      },
      pixelsPerUnit = {
        description = "float\nPixels per coordinate unit.",
        type = "value"
      },
      sprite = {
        valuetype = "Sprite2D",
        description = "Sprite2D*\nSprite.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*\nMaterial. If null, use a default material. If non-null, use a clone of this for updating the diffuse texture.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode.",
        type = "value"
      },
      zValue = {
        description = "float\nZ value.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Animation = {
    childs = {
      GetAnimationName = {
        args = "()",
        description = "Return animation name.",
        returns = "(const String)",
        type = "method"
      },
      GetAnimationNameHash = {
        args = "()",
        description = "Return animation name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetLength = {
        args = "()",
        description = "Return animation length.",
        returns = "(float)",
        type = "method"
      },
      GetNumTracks = {
        args = "()",
        description = "Return number of animation tracks.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTrack = {
        args = "(const String name)",
        description = "(const AnimationTrack*) GetTrack (StringHash nameHash),\n(const AnimationTrack*) GetTrack (unsigned index)\nReturn animation track by bone name.",
        returns = "(const AnimationTrack*)",
        valuetype = "AnimationTrack",
        type = "method"
      },
      GetNumTriggers = {
        args = "()",
        description = "Return number of animation trigger points.",
        returns = "(unsigned)",
        type = "method"
      },
      animationName = {
        description = "(Readonly) String\nAnimation name.",
        type = "value"
      },
      animationNameHash = {
        description = "(Readonly) StringHash\nAnimation name hash.",
        type = "value"
      },
      length = {
        description = "(Readonly) float\nAnimation length.",
        type = "value"
      },
      numTracks = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numTriggers = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Animation2D = {
    childs = {
      GetTotalTime = {
        args = "()",
        description = "Return total time.",
        returns = "(float)",
        type = "method"
      },
      GetNumFrames = {
        args = "()",
        description = "Return number of frames.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFrameSprite = {
        args = "(unsigned index)",
        description = "Return Frame sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      GetFrameSpriteByTime = {
        args = "(float time)",
        description = "Return frame sprite by time.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      totalTime = {
        description = "(Readonly) float",
        type = "value"
      },
      numFrames = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationControl = {
    childs = {
      new = {
        args = "()",
        returns = "(AnimationControl*)",
        valuetype = "AnimationControl",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      hash_ = {
        description = "StringHash",
        type = "value"
      },
      speed_ = {
        description = "float",
        type = "value"
      },
      targetWeight_ = {
        description = "float",
        type = "value"
      },
      fadeTime_ = {
        description = "float",
        type = "value"
      },
      autoFadeTime_ = {
        description = "float",
        type = "value"
      },
      setTimeTtl_ = {
        description = "float",
        type = "value"
      },
      setWeightTtl_ = {
        description = "float",
        type = "value"
      },
      setTime_ = {
        description = "short",
        type = "value"
      },
      setWeight_ = {
        description = "char",
        type = "value"
      },
      setTimeRev_ = {
        description = "char",
        type = "value"
      },
      setWeightRev_ = {
        description = "char",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationController = {
    childs = {
      Play = {
        args = "(const String name, char layer, bool looped, float fadeInTime = 0.0f)",
        returns = "(bool)",
        type = "method"
      },
      PlayExclusive = {
        args = "(const String name, char layer, bool looped, float fadeTime = 0.0f)",
        returns = "(bool)",
        type = "method"
      },
      Stop = {
        args = "(const String name, float fadeOutTime = 0.0f)",
        description = "Stop an animation. Zero fadetime is instant. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      StopLayer = {
        args = "(char layer, float fadeOutTime = 0.0f)",
        returns = "()",
        type = "method"
      },
      StopAll = {
        args = "(float fadeTime = 0.0f)",
        description = "Stop all animations. Zero fadetime is instant.",
        returns = "()",
        type = "method"
      },
      Fade = {
        args = "(const String name, float targetWeight, float fadeTime)",
        description = "Fade animation to target weight. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      FadeOthers = {
        args = "(const String name, float targetWeight, float fadeTime)",
        description = "Fade other animations on the same layer to target weight. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetLayer = {
        args = "(const String name, char layer)",
        returns = "(bool)",
        type = "method"
      },
      SetStartBone = {
        args = "(const String name, const String startBoneName)",
        description = "Set animation start bone. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetTime = {
        args = "(const String name, float time)",
        description = "Set animation time position. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetWeight = {
        args = "(const String name, float weight)",
        description = "Set animation weight. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetLooped = {
        args = "(const String name, bool enable)",
        description = "Set animation looping. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetSpeed = {
        args = "(const String name, float speed)",
        description = "Set animation speed. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetAutoFade = {
        args = "(const String name, float fadeOutTime)",
        description = "Set animation autofade on stop (non-looped animations only.) Zero time disables. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      IsPlaying = {
        args = "(const String name)",
        description = "Return whether an animation is active.",
        returns = "(bool)",
        type = "method"
      },
      IsFadingIn = {
        args = "(const String name)",
        description = "Return whether an animation is fading in.",
        returns = "(bool)",
        type = "method"
      },
      IsFadingOut = {
        args = "(const String name)",
        description = "Return whether an animation is fading out.",
        returns = "(bool)",
        type = "method"
      },
      GetLayer = {
        args = "(const String name)",
        description = "Return animation blending layer.",
        returns = "(char)",
        type = "method"
      },
      GetStartBone = {
        args = "(const String name)",
        description = "Return animation start bone, or null if no such animation.",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      GetStartBoneName = {
        args = "(const String name)",
        description = "Return animation start bone name, or empty string if no such animation.",
        returns = "(const String)",
        type = "method"
      },
      GetTime = {
        args = "(const String name)",
        description = "Return animation time position.",
        returns = "(float)",
        type = "method"
      },
      GetWeight = {
        args = "(const String name)",
        description = "Return animation weight.",
        returns = "(float)",
        type = "method"
      },
      IsLooped = {
        args = "(const String name)",
        description = "Return animation looping.",
        returns = "(bool)",
        type = "method"
      },
      GetLength = {
        args = "(const String name)",
        description = "Return animation length.",
        returns = "(float)",
        type = "method"
      },
      GetSpeed = {
        args = "(const String name)",
        description = "Return animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetFadeTarget = {
        args = "(const String name)",
        description = "Return animation fade target weight.",
        returns = "(float)",
        type = "method"
      },
      GetFadeTime = {
        args = "(const String name)",
        description = "Return animation fade time.",
        returns = "(float)",
        type = "method"
      },
      GetAutoFade = {
        args = "(const String name)",
        description = "Return animation autofade time.",
        returns = "(float)",
        type = "method"
      },
      GetAnimationState = {
        args = "(const String name)",
        description = "(AnimationState*) GetAnimationState (StringHash nameHash)\nFind an animation state by animation name.",
        returns = "(AnimationState*)",
        valuetype = "AnimationState",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationKeyFrame = {
    childs = {
      time = {
        description = "float",
        type = "value"
      },
      position = {
        description = "Vector3",
        type = "value"
      },
      rotation = {
        description = "Quaternion",
        type = "value"
      },
      scale = {
        description = "Vector3",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationState = {
    childs = {
      new = {
        args = "(AnimatedModel* model, Animation* animation)",
        description = "(AnimationState*) new (Node* node, Animation* animation)",
        returns = "(AnimationState*)",
        valuetype = "AnimationState",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetStartBone = {
        args = "(Bone* bone)",
        description = "Set start bone. Not supported in node animation mode. Resets any assigned per-bone weights.",
        returns = "()",
        type = "method"
      },
      SetLooped = {
        args = "(bool looped)",
        description = "Set looping enabled/disabled.",
        returns = "()",
        type = "method"
      },
      SetWeight = {
        args = "(float weight)",
        description = "Set blending weight.",
        returns = "()",
        type = "method"
      },
      SetTime = {
        args = "(float time)",
        description = "Set time position. Does not fire animation triggers.",
        returns = "()",
        type = "method"
      },
      SetBoneWeight = {
        args = "(const String name, float weight, bool recursive = false)",
        description = "() SetBoneWeight (StringHash nameHash, float weight, bool recursive = false),\n() SetBoneWeight (unsigned index, float weight, bool recursive = false)\nSet per-bone blending weight by name.",
        returns = "()",
        type = "method"
      },
      AddWeight = {
        args = "(float delta)",
        description = "Modify blending weight.",
        returns = "()",
        type = "method"
      },
      AddTime = {
        args = "(float delta)",
        description = "Modify time position. %Animation triggers will be fired.",
        returns = "()",
        type = "method"
      },
      SetLayer = {
        args = "(char layer)",
        returns = "()",
        type = "method"
      },
      GetAnimation = {
        args = "()",
        description = "Return animation.",
        returns = "(Animation*)",
        valuetype = "Animation",
        type = "method"
      },
      GetStartBone = {
        args = "()",
        description = "Return start bone.",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      GetBoneWeight = {
        args = "(const String name)",
        description = "(float) GetBoneWeight (StringHash nameHash),\n(float) GetBoneWeight (unsigned index)\nReturn per-bone blending weight by name.",
        returns = "(float)",
        type = "method"
      },
      GetTrackIndex = {
        args = "(const String name)",
        description = "(unsigned) GetTrackIndex (StringHash nameHash)\nReturn track index by bone name, or M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether weight is nonzero.",
        returns = "(bool)",
        type = "method"
      },
      IsLooped = {
        args = "()",
        description = "Return whether looped.",
        returns = "(bool)",
        type = "method"
      },
      GetWeight = {
        args = "()",
        description = "Return blending weight.",
        returns = "(float)",
        type = "method"
      },
      GetTime = {
        args = "()",
        description = "Return time position.",
        returns = "(float)",
        type = "method"
      },
      GetLength = {
        args = "()",
        description = "Return animation length.",
        returns = "(float)",
        type = "method"
      },
      GetLayer = {
        args = "()",
        description = "Return blending layer.",
        returns = "(char)",
        type = "method"
      },
      animation = {
        valuetype = "Animation",
        description = "(Readonly) Animation*\nAnimation.",
        type = "value"
      },
      startBone = {
        valuetype = "Bone",
        description = "Bone*\nStart bone.",
        type = "value"
      },
      enabled = {
        description = "(Readonly) bool",
        type = "value"
      },
      looped = {
        description = "bool\nLooped flag.",
        type = "value"
      },
      weight = {
        description = "float\nBlending weight.",
        type = "value"
      },
      time = {
        description = "float\nTime position.",
        type = "value"
      },
      length = {
        description = "(Readonly) float",
        type = "value"
      },
      layer = {
        description = "char\nBlending layer.",
        type = "value"
      },
    },
    type = "class"
  },
  Audio = {
    childs = {
      SetMode = {
        args = "(int bufferLengthMSec, int mixRate, bool stereo, bool interpolation = true)",
        description = "Initialize sound output with specified buffer length and output mode.",
        returns = "(bool)",
        type = "method"
      },
      Play = {
        args = "()",
        description = "Restart sound output.",
        returns = "(bool)",
        type = "method"
      },
      Stop = {
        args = "()",
        description = "Suspend sound output.",
        returns = "()",
        type = "method"
      },
      SetMasterGain = {
        args = "(SoundType type, float gain)",
        description = "Set master gain on a specific sound type such as sound effects, music or voice.",
        returns = "()",
        type = "method"
      },
      SetListener = {
        args = "(SoundListener* listener)",
        description = "Set active sound listener for 3D sounds.",
        returns = "()",
        type = "method"
      },
      StopSound = {
        args = "(Sound* sound)",
        description = "Stop any sound source playing a certain sound clip.",
        returns = "()",
        type = "method"
      },
      GetSampleSize = {
        args = "()",
        description = "Return byte size of one sample.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMixRate = {
        args = "()",
        description = "Return mixing rate.",
        returns = "(int)",
        type = "method"
      },
      GetInterpolation = {
        args = "()",
        description = "Return whether output is interpolated.",
        returns = "(bool)",
        type = "method"
      },
      IsStereo = {
        args = "()",
        description = "Return whether output is stereo.",
        returns = "(bool)",
        type = "method"
      },
      IsPlaying = {
        args = "()",
        description = "Return whether audio is being output.",
        returns = "(bool)",
        type = "method"
      },
      IsInitialized = {
        args = "()",
        description = "Return whether an audio stream has been reserved.",
        returns = "(bool)",
        type = "method"
      },
      GetMasterGain = {
        args = "(SoundType type)",
        description = "Return master gain for a specific sound source type.",
        returns = "(float)",
        type = "method"
      },
      GetListener = {
        args = "()",
        description = "Return active sound listener.",
        returns = "(SoundListener*)",
        valuetype = "SoundListener",
        type = "method"
      },
      GetSoundSources = {
        args = "()",
        description = "Return all sound sources.",
        returns = "(const PODVector<SoundSource*>&)",
        valuetype = "PODVector<SoundSource*>",
        type = "method"
      },
      AddSoundSource = {
        args = "(SoundSource* soundSource)",
        description = "Add a sound source to keep track of. Called by SoundSource.",
        returns = "()",
        type = "method"
      },
      RemoveSoundSource = {
        args = "(SoundSource* soundSource)",
        description = "Remove a sound source. Called by SoundSource.",
        returns = "()",
        type = "method"
      },
      GetSoundSourceMasterGain = {
        args = "(SoundType type)",
        description = "Return sound type specific gain multiplied by master gain.",
        returns = "(float)",
        type = "method"
      },
      MixOutput = {
        args = "(void* dest, unsigned samples)",
        returns = "()",
        type = "method"
      },
      sampleSize = {
        description = "(Readonly) unsigned\nSample size.",
        type = "value"
      },
      mixRate = {
        description = "(Readonly) int\nMixing rate.",
        type = "value"
      },
      interpolation = {
        description = "(Readonly) bool\nMixing interpolation flag.",
        type = "value"
      },
      stereo = {
        description = "(Readonly) bool\nStereo flag.",
        type = "value"
      },
      playing = {
        description = "(Readonly) bool\nPlaying flag.",
        type = "value"
      },
      initialized = {
        description = "(Readonly) bool",
        type = "value"
      },
      listener = {
        valuetype = "SoundListener",
        description = "SoundListener*\nSound listener.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  BiasParameters = {
    childs = {
      new = {
        args = "()",
        description = "(BiasParameters*) new (float constantBias, float slopeScaledBias)",
        returns = "(BiasParameters*)",
        valuetype = "BiasParameters",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
    },
    type = "class"
  },
  Billboard = {
    childs = {
      position = {
        description = "Vector3",
        type = "value"
      },
      size = {
        description = "Vector2",
        type = "value"
      },
      uv = {
        description = "Rect",
        type = "value"
      },
      color = {
        description = "Color",
        type = "value"
      },
      rotation = {
        description = "float",
        type = "value"
      },
      enabled = {
        description = "bool",
        type = "value"
      },
      sortDistance = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  BillboardSet = {
    childs = {
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetNumBillboards = {
        args = "(unsigned num)",
        description = "Set number of billboards.",
        returns = "()",
        type = "method"
      },
      SetRelative = {
        args = "(bool enable)",
        description = "Set whether billboards are relative to the scene node. Default true.",
        returns = "()",
        type = "method"
      },
      SetScaled = {
        args = "(bool enable)",
        description = "Set whether scene node scale affects billboards' size. Default true.",
        returns = "()",
        type = "method"
      },
      SetSorted = {
        args = "(bool enable)",
        description = "Set whether billboards are sorted by distance. Default false.",
        returns = "()",
        type = "method"
      },
      SetFaceCamera = {
        args = "(bool enable)",
        description = "Set whether billboards face the camera automatically. Default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationLodBias = {
        args = "(float bias)",
        description = "Set animation LOD bias.",
        returns = "()",
        type = "method"
      },
      Commit = {
        args = "()",
        description = "Mark for bounding box and vertex buffer update. Call after modifying the billboards.",
        returns = "()",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetNumBillboards = {
        args = "()",
        description = "Return number of billboards.",
        returns = "(unsigned)",
        type = "method"
      },
      GetBillboard = {
        args = "(unsigned index)",
        description = "Return billboard by index.",
        returns = "(Billboard*)",
        valuetype = "Billboard",
        type = "method"
      },
      IsRelative = {
        args = "()",
        description = "Return whether billboards are relative to the scene node.",
        returns = "(bool)",
        type = "method"
      },
      IsScaled = {
        args = "()",
        description = "Return whether scene node scale affects billboards' size.",
        returns = "(bool)",
        type = "method"
      },
      IsSorted = {
        args = "()",
        description = "Return whether billboards are sorted.",
        returns = "(bool)",
        type = "method"
      },
      GetFaceCamera = {
        args = "()",
        description = "Return whether faces the camera automatically.",
        returns = "(bool)",
        type = "method"
      },
      GetAnimationLodBias = {
        args = "()",
        description = "Return animation LOD bias.",
        returns = "(float)",
        type = "method"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      numBillboards = {
        description = "unsigned",
        type = "value"
      },
      relative = {
        description = "bool\nBillboards relative flag.",
        type = "value"
      },
      scaled = {
        description = "bool\nScale affects billboard scale flag.",
        type = "value"
      },
      sorted = {
        description = "bool\nBillboards sorted flag.",
        type = "value"
      },
      faceCamera = {
        description = "bool\nFace camera flag.",
        type = "value"
      },
      animationLodBias = {
        description = "float\nAnimation LOD bias.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Bone = {
    childs = {
      new = {
        args = "()",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      name = {
        description = "String",
        type = "value"
      },
      nameHash = {
        description = "StringHash",
        type = "value"
      },
      parentIndex = {
        description = "unsigned",
        type = "value"
      },
      initialPosition = {
        description = "Vector3",
        type = "value"
      },
      initialRotation = {
        description = "Quaternion",
        type = "value"
      },
      initialScale = {
        description = "Vector3",
        type = "value"
      },
      offsetMatrix = {
        description = "Matrix3x4",
        type = "value"
      },
      animated = {
        description = "bool",
        type = "value"
      },
      collisionMask = {
        description = "char",
        type = "value"
      },
      radius = {
        description = "float",
        type = "value"
      },
      boundingBox = {
        description = "BoundingBox",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
    },
    type = "class"
  },
  BorderImage = {
    childs = {
      new = {
        args = "()",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  BoundingBox = {
    childs = {
      new = {
        args = "()",
        description = "(BoundingBox*) new (const BoundingBox& box),\n(BoundingBox*) new (const Rect& rect),\n(BoundingBox*) new (const Vector3& min, const Vector3& max),\n(BoundingBox*) new (float min, float max),\n(BoundingBox*) new (const Frustum& frustum),\n(BoundingBox*) new (const Polyhedron& poly),\n(BoundingBox*) new (const Sphere& sphere)",
        returns = "(BoundingBox*)",
        valuetype = "BoundingBox",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const BoundingBox& box)",
        description = "() Define (const Rect& rect),\n() Define (const Vector3& min, const Vector3& max),\n() Define (float min, float max),\n() Define (const Vector3& point),\n() Define (const Frustum& frustum),\n() Define (const Polyhedron& poly),\n() Define (const Sphere& sphere)",
        returns = "()",
        type = "method"
      },
      Merge = {
        args = "(const Vector3& point)",
        description = "() Merge (const BoundingBox& box),\n() Merge (const Frustum& frustum),\n() Merge (const Polyhedron& poly),\n() Merge (const Sphere& sphere)",
        returns = "()",
        type = "method"
      },
      Clip = {
        args = "(const BoundingBox& box)",
        returns = "()",
        type = "method"
      },
      Transform = {
        args = "(const Matrix3& transform)",
        description = "() Transform (const Matrix3x4& transform)",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Center = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Size = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      HalfSize = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3& transform)",
        description = "(BoundingBox) Transformed (const Matrix3x4& transform)",
        returns = "(BoundingBox)",
        type = "method"
      },
      Projected = {
        args = "(const Matrix4& projection)",
        returns = "(Rect)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "(Intersection) IsInside (const BoundingBox& box),\n(Intersection) IsInside (const Sphere& sphere)",
        returns = "(Intersection)",
        type = "method"
      },
      IsInsideFast = {
        args = "(const BoundingBox& box)",
        description = "(Intersection) IsInsideFast (const Sphere& sphere)",
        returns = "(Intersection)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      min = {
        description = "Vector3",
        type = "value"
      },
      max = {
        description = "Vector3",
        type = "value"
      },
      defined = {
        description = "bool",
        type = "value"
      },
      center = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      size = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      halfSize = {
        description = "(Readonly) Vector3",
        type = "value"
      },
    },
    type = "class"
  },
  Button = {
    childs = {
      new = {
        args = "()",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetPressedOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedOffset (int x, int y)\nSet offset to image rectangle used when pressed.",
        returns = "()",
        type = "method"
      },
      SetPressedChildOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedChildOffset (int x, int y)\nSet offset of child elements when pressed.",
        returns = "()",
        type = "method"
      },
      SetRepeat = {
        args = "(float delay, float rate)",
        description = "Set repeat properties. Rate 0 (default) disables repeat.",
        returns = "()",
        type = "method"
      },
      SetRepeatDelay = {
        args = "(float delay)",
        description = "Set repeat delay.",
        returns = "()",
        type = "method"
      },
      SetRepeatRate = {
        args = "(float rate)",
        description = "Set repeat rate.",
        returns = "()",
        type = "method"
      },
      GetPressedOffset = {
        args = "()",
        description = "Return pressed image offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPressedChildOffset = {
        args = "()",
        description = "Return offset of child elements when pressed.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetRepeatDelay = {
        args = "()",
        description = "Return repeat delay.",
        returns = "(float)",
        type = "method"
      },
      GetRepeatRate = {
        args = "()",
        description = "Return repeat rate.",
        returns = "(float)",
        type = "method"
      },
      IsPressed = {
        args = "()",
        description = "Return whether is currently pressed.",
        returns = "(bool)",
        type = "method"
      },
      pressedOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed image offset.",
        type = "value"
      },
      pressedChildOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed label offset.",
        type = "value"
      },
      repeatDelay = {
        description = "float\nRepeat delay.",
        type = "value"
      },
      repeatRate = {
        description = "float\nRepeat rate.",
        type = "value"
      },
      pressed = {
        description = "(Readonly) bool\nCurrent pressed state.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Camera = {
    childs = {
      SetNearClip = {
        args = "(float nearClip)",
        description = "Set near clip distance.",
        returns = "()",
        type = "method"
      },
      SetFarClip = {
        args = "(float farClip)",
        description = "Set far clip distance.",
        returns = "()",
        type = "method"
      },
      SetFov = {
        args = "(float fov)",
        description = "Set field of view.",
        returns = "()",
        type = "method"
      },
      SetOrthoSize = {
        args = "(float orthoSize)",
        description = "() SetOrthoSize (const Vector2& orthoSize)\nSet orthographic mode view uniform size.",
        returns = "()",
        type = "method"
      },
      SetAspectRatio = {
        args = "(float aspectRatio)",
        description = "Set aspect ratio.",
        returns = "()",
        type = "method"
      },
      SetFillMode = {
        args = "(FillMode mode)",
        description = "Set polygon fill mode to use when rendering a scene.",
        returns = "()",
        type = "method"
      },
      SetZoom = {
        args = "(float zoom)",
        description = "Set zoom.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Will be and'ed with object's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetViewOverrideFlags = {
        args = "(unsigned flags)",
        description = "Set view override flags.",
        returns = "()",
        type = "method"
      },
      SetOrthographic = {
        args = "(bool enable)",
        description = "Set orthographic mode enabled/disabled.",
        returns = "()",
        type = "method"
      },
      SetAutoAspectRatio = {
        args = "(bool enable)",
        description = "Set automatic aspect ratio based on viewport dimensions.",
        returns = "()",
        type = "method"
      },
      SetProjectionOffset = {
        args = "(const Vector2& offset)",
        description = "Set projection offset. It needs to be calculated as (offset in pixels) / (viewport dimensions.)",
        returns = "()",
        type = "method"
      },
      SetUseReflection = {
        args = "(bool enable)",
        description = "Set reflection mode.",
        returns = "()",
        type = "method"
      },
      SetReflectionPlane = {
        args = "(const Plane& reflectionPlane)",
        description = "Set reflection plane in world space for reflection mode.",
        returns = "()",
        type = "method"
      },
      SetUseClipping = {
        args = "(bool enable)",
        description = "Set whether to use a custom clip plane.",
        returns = "()",
        type = "method"
      },
      SetClipPlane = {
        args = "(const Plane& clipPlane)",
        description = "Set custom clipping plane in world space.",
        returns = "()",
        type = "method"
      },
      GetFarClip = {
        args = "()",
        description = "Return far clip distance.",
        returns = "(float)",
        type = "method"
      },
      GetNearClip = {
        args = "()",
        description = "Return near clip distance.",
        returns = "(float)",
        type = "method"
      },
      GetFov = {
        args = "()",
        description = "Return field of view.",
        returns = "(float)",
        type = "method"
      },
      GetOrthoSize = {
        args = "()",
        description = "Return orthographic mode size.",
        returns = "(float)",
        type = "method"
      },
      GetAspectRatio = {
        args = "()",
        description = "Return aspect ratio.",
        returns = "(float)",
        type = "method"
      },
      GetZoom = {
        args = "()",
        description = "Return zoom.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetViewOverrideFlags = {
        args = "()",
        description = "Return view override flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFillMode = {
        args = "()",
        description = "Return fill mode.",
        returns = "(FillMode)",
        type = "method"
      },
      IsOrthographic = {
        args = "()",
        description = "Return orthographic flag.",
        returns = "(bool)",
        type = "method"
      },
      GetAutoAspectRatio = {
        args = "()",
        description = "Return auto aspect ratio flag.",
        returns = "(bool)",
        type = "method"
      },
      GetFrustum = {
        args = "()",
        description = "Return frustum in world space.",
        returns = "(const Frustum&)",
        valuetype = "Frustum",
        type = "method"
      },
      GetProjection = {
        args = "()",
        description = "Return API-specific projection matrix.",
        returns = "(const Matrix4&)",
        valuetype = "Matrix4",
        type = "method"
      },
      GetView = {
        args = "()",
        description = "Return view matrix.",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      GetFrustumSize = {
        args = "(Vector3& near, Vector3& far)",
        description = "Return frustum near and far sizes.",
        returns = "()",
        type = "method"
      },
      GetHalfViewSize = {
        args = "()",
        description = "Return half view size.",
        returns = "(float)",
        type = "method"
      },
      GetSplitFrustum = {
        args = "(float nearClip, float farClip)",
        description = "Return frustum split by custom near and far clip distances.",
        returns = "(Frustum)",
        type = "method"
      },
      GetViewSpaceFrustum = {
        args = "()",
        description = "Return frustum in view space.",
        returns = "(Frustum)",
        type = "method"
      },
      GetViewSpaceSplitFrustum = {
        args = "(float nearClip, float farClip)",
        description = "Return split frustum in view space.",
        returns = "(Frustum)",
        type = "method"
      },
      GetScreenRay = {
        args = "(float x, float y)",
        description = "Return ray corresponding to normalized screen coordinates (0.0 to 1.0.)",
        returns = "(Ray)",
        type = "method"
      },
      WorldToScreenPoint = {
        args = "(const Vector3& worldPos)",
        returns = "(Vector2)",
        type = "method"
      },
      ScreenToWorldPoint = {
        args = "(const Vector3& screenPos)",
        returns = "(Vector3)",
        type = "method"
      },
      GetProjectionOffset = {
        args = "()",
        description = "Return projection offset.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetUseReflection = {
        args = "()",
        description = "Return whether is using reflection.",
        returns = "(bool)",
        type = "method"
      },
      GetReflectionPlane = {
        args = "()",
        description = "Return the reflection plane.",
        returns = "(const Plane&)",
        valuetype = "Plane",
        type = "method"
      },
      GetUseClipping = {
        args = "()",
        description = "Return whether is using a custom clipping plane.",
        returns = "(bool)",
        type = "method"
      },
      GetClipPlane = {
        args = "()",
        description = "Return the custom clipping plane.",
        returns = "(const Plane&)",
        valuetype = "Plane",
        type = "method"
      },
      GetDistance = {
        args = "(const Vector3& worldPos)",
        description = "Return distance to position. In orthographic mode uses only Z coordinate.",
        returns = "(float)",
        type = "method"
      },
      GetDistanceSquared = {
        args = "(const Vector3& worldPos)",
        description = "Return squared distance to position. In orthographic mode uses only Z coordinate.",
        returns = "(float)",
        type = "method"
      },
      GetLodDistance = {
        args = "(float distance, float scale, float bias)",
        description = "Return a scene node's LOD scaled distance.",
        returns = "(float)",
        type = "method"
      },
      IsProjectionValid = {
        args = "()",
        description = "Return if projection parameters are valid for rendering and raycasting.",
        returns = "(bool)",
        type = "method"
      },
      GetEffectiveWorldTransform = {
        args = "()",
        description = "Get effective world transform for matrix and frustum calculations including reflection but excluding node scaling.",
        returns = "(Matrix3x4)",
        type = "method"
      },
      farClip = {
        description = "float\nFar clip distance.",
        type = "value"
      },
      nearClip = {
        description = "float\nNear clip distance.",
        type = "value"
      },
      fov = {
        description = "float\nField of view.",
        type = "value"
      },
      orthoSize = {
        description = "float\nOrthographic view size.",
        type = "value"
      },
      aspectRatio = {
        description = "float\nAspect ratio.",
        type = "value"
      },
      zoom = {
        description = "float\nZoom.",
        type = "value"
      },
      lodBias = {
        description = "float\nLOD bias.",
        type = "value"
      },
      viewMask = {
        description = "unsigned\nView mask.",
        type = "value"
      },
      viewOverrideFlags = {
        description = "unsigned\nView override flags.",
        type = "value"
      },
      fillMode = {
        description = "FillMode\nFill mode.",
        type = "value"
      },
      orthographic = {
        description = "bool\nOrthographic mode flag.",
        type = "value"
      },
      autoAspectRatio = {
        description = "bool\nAuto aspect ratio flag.",
        type = "value"
      },
      frustum = {
        valuetype = "Frustum",
        description = "(Readonly) Frustum&\nCached frustum.",
        type = "value"
      },
      projection = {
        valuetype = "Matrix4",
        description = "(Readonly) Matrix4&\nCached projection matrix.",
        type = "value"
      },
      view = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&\nCached view matrix.",
        type = "value"
      },
      halfViewSize = {
        description = "(Readonly) float",
        type = "value"
      },
      viewSpaceFrustum = {
        description = "(Readonly) Frustum",
        type = "value"
      },
      projectionOffset = {
        valuetype = "Vector2",
        description = "Vector2&\nProjection offset.",
        type = "value"
      },
      useReflection = {
        description = "bool\nReflection mode enabled flag.",
        type = "value"
      },
      reflectionPlane = {
        valuetype = "Plane",
        description = "Plane&\nReflection plane.",
        type = "value"
      },
      useClipping = {
        description = "bool\nUse custom clip plane flag.",
        type = "value"
      },
      clipPlane = {
        valuetype = "Plane",
        description = "Plane&\nClipping plane.",
        type = "value"
      },
      projectionValid = {
        description = "(Readonly) bool",
        type = "value"
      },
      effectiveWorldTransform = {
        description = "(Readonly) Matrix3x4",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CascadeParameters = {
    childs = {
      new = {
        args = "()",
        description = "(CascadeParameters*) new (float split1, float split2, float split3, float split4, float fadeStart, float biasAutoAdjust = 1.0f)",
        returns = "(CascadeParameters*)",
        valuetype = "CascadeParameters",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
    },
    type = "class"
  },
  CheckBox = {
    childs = {
      new = {
        args = "()",
        returns = "(CheckBox*)",
        valuetype = "CheckBox",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetChecked = {
        args = "(bool enable)",
        description = "Set checked state.",
        returns = "()",
        type = "method"
      },
      SetCheckedOffset = {
        args = "(const IntVector2& rect)",
        description = "() SetCheckedOffset (int x, int y)\nSet checked image offset.",
        returns = "()",
        type = "method"
      },
      IsChecked = {
        args = "()",
        description = "Return whether is checked.",
        returns = "(bool)",
        type = "method"
      },
      GetCheckedOffset = {
        args = "()",
        description = "Return checked image offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      checked = {
        description = "bool\nCurrent checked state.",
        type = "value"
      },
      checkedOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChecked image offset.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CollisionShape = {
    childs = {
      SetBox = {
        args = "(const Vector3& size)",
        description = "() SetBox (const Vector3& size, const Vector3& position),\n() SetBox (const Vector3& size, const Vector3& position, const Quaternion& rotation)\nSet as a box.",
        returns = "()",
        type = "method"
      },
      SetSphere = {
        args = "(float diameter)",
        description = "() SetSphere (float diameter, const Vector3& position),\n() SetSphere (float diameter, const Vector3& position, const Quaternion& rotation)\nSet as a sphere.",
        returns = "()",
        type = "method"
      },
      SetStaticPlane = {
        args = "()",
        description = "() SetStaticPlane (const Vector3& position),\n() SetStaticPlane (const Vector3& position, const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetCylinder = {
        args = "(float diameter, float height)",
        description = "() SetCylinder (float diameter, float height, const Vector3& position),\n() SetCylinder (float diameter, float height, const Vector3& position, const Quaternion& rotation)\nSet as a cylinder.",
        returns = "()",
        type = "method"
      },
      SetCapsule = {
        args = "(float diameter, float height)",
        description = "() SetCapsule (float diameter, float height, const Vector3& position),\n() SetCapsule (float diameter, float height, const Vector3& position, const Quaternion& rotation)\nSet as a capsule.",
        returns = "()",
        type = "method"
      },
      SetCone = {
        args = "(float diameter, float height)",
        description = "() SetCone (float diameter, float height, const Vector3& position),\n() SetCone (float diameter, float height, const Vector3& position, const Quaternion& rotation)\nSet as a cone.",
        returns = "()",
        type = "method"
      },
      SetTriangleMesh = {
        args = "(Model* model, unsigned lodLevel = 0)",
        description = "() SetTriangleMesh (Model* model, unsigned lodLevel, const Vector3& scale),\n() SetTriangleMesh (Model* model, unsigned lodLevel, const Vector3& scale, const Vector3& position),\n() SetTriangleMesh (Model* model, unsigned lodLevel, const Vector3& scale, const Vector3& position, const Quaternion& rotation)\nSet as a triangle mesh.",
        returns = "()",
        type = "method"
      },
      SetConvexHull = {
        args = "(Model* model, unsigned lodLevel = 0)",
        description = "() SetConvexHull (Model* model, unsigned lodLevel, const Vector3& scale),\n() SetConvexHull (Model* model, unsigned lodLevel, const Vector3& scale, const Vector3& position),\n() SetConvexHull (Model* model, unsigned lodLevel, const Vector3& scale, const Vector3& position, const Quaternion& rotation)\nSet as a convex hull from Model.",
        returns = "()",
        type = "method"
      },
      SetTerrain = {
        args = "()",
        description = "Set as a terrain. Only works if the same scene node contains a Terrain component.",
        returns = "()",
        type = "method"
      },
      SetShapeType = {
        args = "(ShapeType type)",
        description = "Set shape type.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const Vector3& size)",
        description = "Set shape size.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set offset position.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set offset rotation.",
        returns = "()",
        type = "method"
      },
      SetTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "Set offset transform.",
        returns = "()",
        type = "method"
      },
      SetMargin = {
        args = "(float margin)",
        description = "Set collision margin.",
        returns = "()",
        type = "method"
      },
      SetModel = {
        args = "(Model* model)",
        description = "Set triangle mesh / convex hull model.",
        returns = "()",
        type = "method"
      },
      SetLodLevel = {
        args = "(unsigned lodLevel)",
        description = "Set model LOD level.",
        returns = "()",
        type = "method"
      },
      GetPhysicsWorld = {
        args = "()",
        description = "Return physics world.",
        returns = "(PhysicsWorld*)",
        valuetype = "PhysicsWorld",
        type = "method"
      },
      GetShapeType = {
        args = "()",
        description = "Return shape type.",
        returns = "(ShapeType)",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return shape size.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return offset position.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return offset rotation.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetMargin = {
        args = "()",
        description = "Return collision margin.",
        returns = "(float)",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return triangle mesh / convex hull model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetLodLevel = {
        args = "()",
        description = "Return model LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(BoundingBox)",
        type = "method"
      },
      physicsWorld = {
        valuetype = "PhysicsWorld",
        description = "(Readonly) PhysicsWorld*\nPhysics world.",
        type = "value"
      },
      shapeType = {
        description = "ShapeType\nCollision shape type.",
        type = "value"
      },
      size = {
        valuetype = "Vector3",
        description = "Vector3&\nShape size.",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&\nOffset position.",
        type = "value"
      },
      rotation = {
        valuetype = "Quaternion",
        description = "Quaternion&\nOffset rotation.",
        type = "value"
      },
      margin = {
        description = "float\nCollision margin.",
        type = "value"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      lodLevel = {
        description = "unsigned\nModel LOD level.",
        type = "value"
      },
      worldBoundingBox = {
        description = "(Readonly) BoundingBox",
        type = "value"
      },
      modelAttr = {
        description = "ResourceRef",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Color = {
    childs = {
      new = {
        args = "()",
        description = "(Color*) new (const Color& color),\n(Color*) new (const Color& color, float a),\n(Color*) new (float r, float g, float b),\n(Color*) new (float r, float g, float b, float a)",
        returns = "(Color*)",
        valuetype = "Color",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      ToUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ToHSL = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ToHSV = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      FromHSL = {
        args = "(float h, float s, float l, float a)",
        returns = "()",
        type = "method"
      },
      FromHSV = {
        args = "(float h, float s, float v, float a)",
        returns = "()",
        type = "method"
      },
      ToVector3 = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ToVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      SumRGB = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Average = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Luma = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Chroma = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Hue = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      SaturationHSL = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      SaturationHSV = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Value = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Lightness = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      MaxRGB = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      MinRGB = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Range = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Clip = {
        args = "(bool clipAlpha = false)",
        returns = "()",
        type = "method"
      },
      Invert = {
        args = "(bool invertAlpha = false)",
        returns = "()",
        type = "method"
      },
      Lerp = {
        args = "(const Color& rhs, float t)",
        returns = "(Color)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      r = {
        description = "float",
        type = "value"
      },
      g = {
        description = "float",
        type = "value"
      },
      b = {
        description = "float",
        type = "value"
      },
      a = {
        description = "float",
        type = "value"
      },
      WHITE = {
        description = "const Color",
        type = "value"
      },
      GRAY = {
        description = "const Color",
        type = "value"
      },
      BLACK = {
        description = "const Color",
        type = "value"
      },
      RED = {
        description = "const Color",
        type = "value"
      },
      GREEN = {
        description = "const Color",
        type = "value"
      },
      BLUE = {
        description = "const Color",
        type = "value"
      },
      CYAN = {
        description = "const Color",
        type = "value"
      },
      MAGENTA = {
        description = "const Color",
        type = "value"
      },
      YELLOW = {
        description = "const Color",
        type = "value"
      },
      TRANSPARENT = {
        description = "const Color",
        type = "value"
      },
    },
    type = "class"
  },
  ColorFrame = {
    childs = {
      new = {
        args = "()",
        description = "(ColorFrame*) new (const Color& color),\n(ColorFrame*) new (const Color& color, float time)",
        returns = "(ColorFrame*)",
        valuetype = "ColorFrame",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Interpolate = {
        args = "(const ColorFrame& next, float time)",
        returns = "(Color)",
        type = "method"
      },
      color = {
        description = "Color",
        type = "value"
      },
      time = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  Component = {
    childs = {
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Connection = {
    childs = {
      SendMessage = {
        args = "(int msgID, bool reliable, bool inOrder, const VectorBuffer& msg, unsigned contentID = 0)",
        description = "Send a message.",
        returns = "()",
        type = "method"
      },
      SendRemoteEvent = {
        args = "(StringHash eventType, bool inOrder)",
        description = "() SendRemoteEvent (StringHash eventType, bool inOrder, const VariantMap& eventData),\n() SendRemoteEvent (const String eventType, bool inOrder),\n() SendRemoteEvent (const String eventType, bool inOrder, const VariantMap& eventData),\n() SendRemoteEvent (Node* node, StringHash eventType, bool inOrder),\n() SendRemoteEvent (Node* node, StringHash eventType, bool inOrder, const VariantMap& eventData),\n() SendRemoteEvent (Node* node, const String eventType, bool inOrder),\n() SendRemoteEvent (Node* node, const String eventType, bool inOrder, const VariantMap& eventData)\nSend a remote event.",
        returns = "()",
        type = "method"
      },
      SetScene = {
        args = "(Scene* newScene)",
        description = "Assign scene. On the server, this will cause the client to load it.",
        returns = "()",
        type = "method"
      },
      SetIdentity = {
        args = "(const VariantMap& identity)",
        description = "Assign identity. Called by Network.",
        returns = "()",
        type = "method"
      },
      SetControls = {
        args = "(const Controls& newControls)",
        description = "Set new controls.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set the observer position for interest management.",
        returns = "()",
        type = "method"
      },
      SetConnectPending = {
        args = "(bool connectPending)",
        description = "Set the connection pending status. Called by Network.",
        returns = "()",
        type = "method"
      },
      SetLogStatistics = {
        args = "(bool enable)",
        description = "Set whether to log data in/out statistics.",
        returns = "()",
        type = "method"
      },
      Disconnect = {
        args = "(int waitMSec = 0)",
        description = "Disconnect. If wait time is non-zero, will block while waiting for disconnect to finish.",
        returns = "()",
        type = "method"
      },
      SendServerUpdate = {
        args = "()",
        description = "Send scene update messages. Called by Network.",
        returns = "()",
        type = "method"
      },
      SendClientUpdate = {
        args = "()",
        description = "Send latest controls from the client. Called by Network.",
        returns = "()",
        type = "method"
      },
      SendRemoteEvents = {
        args = "()",
        description = "Send queued remote events. Called by Network.",
        returns = "()",
        type = "method"
      },
      SendPackages = {
        args = "()",
        description = "Send package files to client. Called by network.",
        returns = "()",
        type = "method"
      },
      ProcessPendingLatestData = {
        args = "()",
        description = "Process pending latest data for nodes and components.",
        returns = "()",
        type = "method"
      },
      ProcessMessage = {
        args = "(int msgID, MemoryBuffer& msg)",
        description = "Process a message from the server or client. Called by Network.",
        returns = "(bool)",
        type = "method"
      },
      GetIdentity = {
        args = "()",
        description = "Return client identity.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene used by this connection.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      GetControls = {
        args = "()",
        description = "Return the client controls of this connection.",
        returns = "(const Controls&)",
        valuetype = "Controls",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return the observer position for interest management.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      IsClient = {
        args = "()",
        description = "Return whether is a client connection.",
        returns = "(bool)",
        type = "method"
      },
      IsConnected = {
        args = "()",
        description = "Return whether is fully connected.",
        returns = "(bool)",
        type = "method"
      },
      IsConnectPending = {
        args = "()",
        description = "Return whether connection is pending.",
        returns = "(bool)",
        type = "method"
      },
      IsSceneLoaded = {
        args = "()",
        description = "Return whether the scene is loaded and ready to receive server updates.",
        returns = "(bool)",
        type = "method"
      },
      GetLogStatistics = {
        args = "()",
        description = "Return whether to log data in/out statistics.",
        returns = "(bool)",
        type = "method"
      },
      GetAddress = {
        args = "()",
        description = "Return remote address.",
        returns = "(String)",
        type = "method"
      },
      GetPort = {
        args = "()",
        description = "Return remote port.",
        returns = "(short)",
        type = "method"
      },
      ToString = {
        args = "()",
        description = "Return an address:port string.",
        returns = "(String)",
        type = "method"
      },
      GetNumDownloads = {
        args = "()",
        description = "Return number of package downloads remaining.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDownloadName = {
        args = "()",
        description = "Return name of current package download, or empty if no downloads.",
        returns = "(const String)",
        type = "method"
      },
      GetDownloadProgress = {
        args = "()",
        description = "Return progress of current package download, or 1.0 if no downloads.",
        returns = "(float)",
        type = "method"
      },
      identity = {
        valuetype = "VariantMap",
        description = "VariantMap&\nIdentity map.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "Scene*\nScene.",
        type = "value"
      },
      controls = {
        valuetype = "Controls",
        description = "Controls&\nCurrent controls.",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&\nObserver position for interest management.",
        type = "value"
      },
      client = {
        description = "(Readonly) bool",
        type = "value"
      },
      connected = {
        description = "(Readonly) bool",
        type = "value"
      },
      connectPending = {
        description = "bool\nConnection pending flag.",
        type = "value"
      },
      sceneLoaded = {
        description = "(Readonly) bool\nScene loaded flag.",
        type = "value"
      },
      logStatistics = {
        description = "bool\nShow statistics flag.",
        type = "value"
      },
      address = {
        description = "(Readonly) String",
        type = "value"
      },
      port = {
        description = "(Readonly) short",
        type = "value"
      },
      numDownloads = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      downloadName = {
        description = "(Readonly) String",
        type = "value"
      },
      downloadProgress = {
        description = "(Readonly) float",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Console = {
    childs = {
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set UI elements' style from an XML file.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Show or hide. Showing automatically focuses the line edit.",
        returns = "()",
        type = "method"
      },
      Toggle = {
        args = "()",
        description = "Toggle visibility.",
        returns = "()",
        type = "method"
      },
      SetNumRows = {
        args = "(unsigned rows)",
        description = "Set number of displayed rows.",
        returns = "()",
        type = "method"
      },
      SetNumHistoryRows = {
        args = "(unsigned rows)",
        description = "Set command history maximum size, 0 disables history.",
        returns = "()",
        type = "method"
      },
      UpdateElements = {
        args = "()",
        description = "Update elements to layout properly. Call this after manually adjusting the sub-elements.",
        returns = "()",
        type = "method"
      },
      GetDefaultStyle = {
        args = "()",
        description = "Return the UI style file.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetBackground = {
        args = "()",
        description = "Return the background element.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      GetLineEdit = {
        args = "()",
        description = "Return the line edit element.",
        returns = "(LineEdit*)",
        valuetype = "LineEdit",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      GetNumRows = {
        args = "()",
        description = "Return number of displayed rows.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumHistoryRows = {
        args = "()",
        description = "Return history maximum size.",
        returns = "(unsigned)",
        type = "method"
      },
      GetHistoryPosition = {
        args = "()",
        description = "Return current history position.",
        returns = "(unsigned)",
        type = "method"
      },
      GetHistoryRow = {
        args = "(unsigned index)",
        description = "Return history row at index.",
        returns = "(const String)",
        type = "method"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*",
        type = "value"
      },
      background = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nBackground.",
        type = "value"
      },
      lineEdit = {
        valuetype = "LineEdit",
        description = "(Readonly) LineEdit*\nLine edit.",
        type = "value"
      },
      visible = {
        description = "bool",
        type = "value"
      },
      numRows = {
        description = "unsigned",
        type = "value"
      },
      numHistoryRows = {
        description = "unsigned",
        type = "value"
      },
      historyPosition = {
        description = "(Readonly) unsigned\nCommand history current position.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Constraint = {
    childs = {
      SetConstraintType = {
        args = "(ConstraintType type)",
        description = "Set constraint type and recreate the constraint.",
        returns = "()",
        type = "method"
      },
      SetOtherBody = {
        args = "(RigidBody* body)",
        description = "Set other body to connect to. Set to null to connect to the static world.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set constraint position relative to own body.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set constraint rotation relative to own body.",
        returns = "()",
        type = "method"
      },
      SetAxis = {
        args = "(const Vector3& axis)",
        description = "Set constraint rotation relative to own body by specifying the axis.",
        returns = "()",
        type = "method"
      },
      SetOtherPosition = {
        args = "(const Vector3& position)",
        description = "Set constraint position relative to the other body. If connected to the static world, is a world space position.",
        returns = "()",
        type = "method"
      },
      SetOtherRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set constraint rotation relative to the other body. If connected to the static world, is a world space rotation.",
        returns = "()",
        type = "method"
      },
      SetOtherAxis = {
        args = "(const Vector3& axis)",
        description = "Set constraint rotation relative to the other body by specifying the axis.",
        returns = "()",
        type = "method"
      },
      SetWorldPosition = {
        args = "(const Vector3& position)",
        description = "Set constraint world space position. Resets both own and other body relative position, ie. zeroes the constraint error.",
        returns = "()",
        type = "method"
      },
      SetHighLimit = {
        args = "(const Vector2& limit)",
        description = "Set high limit. Interpretation is constraint type specific.",
        returns = "()",
        type = "method"
      },
      SetLowLimit = {
        args = "(const Vector2& limit)",
        description = "Set low limit. Interpretation is constraint type specific.",
        returns = "()",
        type = "method"
      },
      SetERP = {
        args = "(float erp)",
        description = "Set constraint error reduction parameter. Zero = leave to default.",
        returns = "()",
        type = "method"
      },
      SetCFM = {
        args = "(float cfm)",
        description = "Set constraint force mixing parameter. Zero = leave to default.",
        returns = "()",
        type = "method"
      },
      SetDisableCollision = {
        args = "(bool disable)",
        description = "Set whether to disable collisions between connected bodies.",
        returns = "()",
        type = "method"
      },
      GetPhysicsWorld = {
        args = "()",
        description = "Return physics world.",
        returns = "(PhysicsWorld*)",
        valuetype = "PhysicsWorld",
        type = "method"
      },
      GetConstraintType = {
        args = "()",
        description = "Return constraint type.",
        returns = "(ConstraintType)",
        type = "method"
      },
      GetOwnBody = {
        args = "()",
        description = "Return rigid body in own scene node.",
        returns = "(RigidBody*)",
        valuetype = "RigidBody",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return the other rigid body. May be null if connected to the static world.",
        returns = "(RigidBody*)",
        valuetype = "RigidBody",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return constraint position relative to own body.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return constraint rotation relative to own body.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetOtherPosition = {
        args = "()",
        description = "Return constraint position relative to other body.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetOtherRotation = {
        args = "()",
        description = "Return constraint rotation relative to other body.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetWorldPosition = {
        args = "()",
        description = "Return constraint world position, calculated from own body.",
        returns = "(Vector3)",
        type = "method"
      },
      GetHighLimit = {
        args = "()",
        description = "Return high limit.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetLowLimit = {
        args = "()",
        description = "Return low limit.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetERP = {
        args = "()",
        description = "Return constraint error reduction parameter.",
        returns = "(float)",
        type = "method"
      },
      GetCFM = {
        args = "()",
        description = "Return constraint force mixing parameter.",
        returns = "(float)",
        type = "method"
      },
      GetDisableCollision = {
        args = "()",
        description = "Return whether collisions between connected bodies are disabled.",
        returns = "(bool)",
        type = "method"
      },
      physicsWorld = {
        valuetype = "PhysicsWorld",
        description = "(Readonly) PhysicsWorld*\nPhysics world.",
        type = "value"
      },
      constraintType = {
        description = "ConstraintType\nConstraint type.",
        type = "value"
      },
      ownBody = {
        valuetype = "RigidBody",
        description = "(Readonly) RigidBody*\nOwn rigid body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody",
        description = "RigidBody*\nOther rigid body.",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&\nConstraint position.",
        type = "value"
      },
      rotation = {
        valuetype = "Quaternion",
        description = "Quaternion&\nConstraint rotation.",
        type = "value"
      },
      axis = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      otherPosition = {
        valuetype = "Vector3",
        description = "Vector3&\nConstraint other body position.",
        type = "value"
      },
      otherRotation = {
        valuetype = "Quaternion",
        description = "Quaternion&\nConstraint other body axis.",
        type = "value"
      },
      otherAxis = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      worldPosition = {
        description = "Vector3",
        type = "value"
      },
      highLimit = {
        valuetype = "Vector2",
        description = "Vector2&\nHigh limit.",
        type = "value"
      },
      lowLimit = {
        valuetype = "Vector2",
        description = "Vector2&\nLow limit.",
        type = "value"
      },
      ERP = {
        description = "float",
        type = "value"
      },
      CFM = {
        description = "float",
        type = "value"
      },
      disableCollision = {
        description = "bool\nDisable collision between connected bodies flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Context = {
    childs = {
      GetEventSender = {
        args = "()",
        description = "Return active event sender. Null outside event handling.",
        returns = "(Object*)",
        valuetype = "Object",
        type = "method"
      },
      GetEventHandler = {
        args = "()",
        description = "Return active event handler. Set by Object. Null outside event handling.",
        returns = "(EventHandler*)",
        valuetype = "EventHandler",
        type = "method"
      },
      GetTypeName = {
        args = "(ShortStringHash objectType)",
        description = "Return object type name from hash, or empty if unknown.",
        returns = "(const String)",
        type = "method"
      },
    },
    type = "class"
  },
  Controls = {
    childs = {
      new = {
        args = "()",
        returns = "(Controls*)",
        valuetype = "Controls",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Reset = {
        args = "()",
        description = "Reset to initial state.",
        returns = "()",
        type = "method"
      },
      Set = {
        args = "(unsigned buttons, bool down = true)",
        description = "Set or release buttons.",
        returns = "()",
        type = "method"
      },
      IsDown = {
        args = "(unsigned button)",
        returns = "(bool)",
        type = "method"
      },
      IsPressed = {
        args = "(unsigned button, const Controls& previousControls)",
        returns = "(bool)",
        type = "method"
      },
      buttons = {
        description = "unsigned",
        type = "value"
      },
      yaw = {
        description = "float",
        type = "value"
      },
      pitch = {
        description = "float",
        type = "value"
      },
      extraData = {
        description = "VariantMap",
        type = "value"
      },
    },
    type = "class"
  },
  Cursor = {
    childs = {
      new = {
        args = "()",
        returns = "(Cursor*)",
        valuetype = "Cursor",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      DefineShape = {
        args = "(CursorShape shape, Image* image, const IntRect& imageRect, const IntVector2& hotSpot)",
        description = "Define a shape.",
        returns = "()",
        type = "method"
      },
      SetShape = {
        args = "(CursorShape shape)",
        description = "Set current shape.",
        returns = "()",
        type = "method"
      },
      SetUseSystemShapes = {
        args = "(bool enable)",
        description = "Set whether to use system default shapes. Is only possible when the OS mouse cursor has been set visible from the Input subsystem.",
        returns = "()",
        type = "method"
      },
      GetShape = {
        args = "()",
        description = "Get current shape.",
        returns = "(CursorShape)",
        type = "method"
      },
      GetUseSystemShapes = {
        args = "()",
        description = "Return whether is using system default shapes.",
        returns = "(bool)",
        type = "method"
      },
      shape = {
        description = "CursorShape\nCurrent shape index.",
        type = "value"
      },
      useSystemShapes = {
        description = "bool\nUse system default shapes flag.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DebugHud = {
    childs = {
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set UI elements' style from an XML file.",
        returns = "()",
        type = "method"
      },
      SetMode = {
        args = "(unsigned mode)",
        description = "Set elements to show.",
        returns = "()",
        type = "method"
      },
      SetProfilerMaxDepth = {
        args = "(unsigned depth)",
        description = "Set maximum profiler block depth, default unlimited.",
        returns = "()",
        type = "method"
      },
      SetProfilerInterval = {
        args = "(float interval)",
        description = "Set profiler accumulation interval in seconds.",
        returns = "()",
        type = "method"
      },
      SetUseRendererStats = {
        args = "(bool enable)",
        description = "Set whether to show 3D geometry primitive/batch count only. Default false.",
        returns = "()",
        type = "method"
      },
      Toggle = {
        args = "(unsigned mode)",
        description = "Toggle elements.",
        returns = "()",
        type = "method"
      },
      ToggleAll = {
        args = "()",
        description = "Toggle all elements.",
        returns = "()",
        type = "method"
      },
      GetDefaultStyle = {
        args = "()",
        description = "Return the UI style file.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetStatsText = {
        args = "()",
        description = "Return rendering stats text.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetModeText = {
        args = "()",
        description = "Return rendering mode text.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetProfilerText = {
        args = "()",
        description = "Return profiler text.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetMode = {
        args = "()",
        description = "Return currently shown elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetProfilerMaxDepth = {
        args = "()",
        description = "Return maximum profiler block depth.",
        returns = "(unsigned)",
        type = "method"
      },
      GetProfilerInterval = {
        args = "()",
        description = "Return profiler accumulation interval in seconds",
        returns = "(float)",
        type = "method"
      },
      GetUseRendererStats = {
        args = "()",
        description = "Return whether showing 3D geometry primitive/batch count only.",
        returns = "(bool)",
        type = "method"
      },
      SetAppStats = {
        args = "(const String label, const Variant stats)",
        description = "() SetAppStats (const String label, const String stats)\nSet application-specific stats.",
        returns = "()",
        type = "method"
      },
      ResetAppStats = {
        args = "(const String label)",
        description = "Reset application-specific stats. Return true if it was erased successfully.",
        returns = "(bool)",
        type = "method"
      },
      ClearAppStats = {
        args = "()",
        description = "Clear all application-specific stats.",
        returns = "()",
        type = "method"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*",
        type = "value"
      },
      statsText = {
        valuetype = "Text",
        description = "(Readonly) Text*\nRendering stats text.",
        type = "value"
      },
      modeText = {
        valuetype = "Text",
        description = "(Readonly) Text*\nRendering mode text.",
        type = "value"
      },
      profilerText = {
        valuetype = "Text",
        description = "(Readonly) Text*\nProfiling information text.",
        type = "value"
      },
      mode = {
        description = "unsigned\nCurrent shown-element mode.",
        type = "value"
      },
      profilerMaxDepth = {
        description = "unsigned\nProfiler max block depth.",
        type = "value"
      },
      profilerInterval = {
        description = "float\nProfiler accumulation interval.",
        type = "value"
      },
      useRendererStats = {
        description = "bool\nShow 3D geometry primitive/batch count flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DebugRenderer = {
    childs = {
      SetView = {
        args = "(Camera* camera)",
        description = "Set the camera viewpoint. Call before rendering, or before adding geometry if you want to use culling.",
        returns = "()",
        type = "method"
      },
      AddLine = {
        args = "(const Vector3& start, const Vector3& end, const Color& color, bool depthTest = true)",
        description = "() AddLine (const Vector3& start, const Vector3& end, unsigned color, bool depthTest = true)\nAdd a line.",
        returns = "()",
        type = "method"
      },
      AddNode = {
        args = "(Node* node, float scale = 1.0f, bool depthTest = true)",
        description = "Add a scene node represented as its coordinate axes.",
        returns = "()",
        type = "method"
      },
      AddBoundingBox = {
        args = "(const BoundingBox& box, const Color& color, bool depthTest = true)",
        description = "() AddBoundingBox (const BoundingBox& box, const Matrix3x4& transform, const Color& color, bool depthTest = true)\nAdd a bounding box.",
        returns = "()",
        type = "method"
      },
      AddFrustum = {
        args = "(const Frustum& frustum, const Color& color, bool depthTest = true)",
        description = "Add a frustum.",
        returns = "()",
        type = "method"
      },
      AddPolyhedron = {
        args = "(const Polyhedron& poly, const Color& color, bool depthTest = true)",
        description = "Add a polyhedron.",
        returns = "()",
        type = "method"
      },
      AddSphere = {
        args = "(const Sphere& sphere, const Color& color, bool depthTest = true)",
        description = "Add a sphere.",
        returns = "()",
        type = "method"
      },
      AddSkeleton = {
        args = "(const Skeleton& skeleton, const Color& color, bool depthTest = true)",
        description = "Add a skeleton.",
        returns = "()",
        type = "method"
      },
      AddTriangleMesh = {
        args = "(const void* vertexData, unsigned vertexSize, const void* indexData, unsigned indexSize, unsigned indexStart, unsigned indexCount, const Matrix3x4& transform, const Color& color, bool depthTest = true)",
        returns = "()",
        type = "method"
      },
      Render = {
        args = "()",
        description = "Update vertex buffer and render all debug lines. The viewport and rendertarget should be set before.",
        returns = "()",
        type = "method"
      },
      GetView = {
        args = "()",
        description = "Return the view transform.",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      GetProjection = {
        args = "()",
        description = "Return the projection transform.",
        returns = "(const Matrix4&)",
        valuetype = "Matrix4",
        type = "method"
      },
      GetFrustum = {
        args = "()",
        description = "Return the view frustum.",
        returns = "(const Frustum&)",
        valuetype = "Frustum",
        type = "method"
      },
      IsInside = {
        args = "(const BoundingBox& box)",
        description = "Check whether a bounding box is inside the view frustum.",
        returns = "(bool)",
        type = "method"
      },
      view = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&\nView transform.",
        type = "value"
      },
      projection = {
        valuetype = "Matrix4",
        description = "(Readonly) Matrix4&\nProjection transform.",
        type = "value"
      },
      frustum = {
        valuetype = "Frustum",
        description = "(Readonly) Frustum&\nView frustum.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DecalSet = {
    childs = {
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material. The material should use a small negative depth bias to avoid Z-fighting.",
        returns = "()",
        type = "method"
      },
      SetMaxVertices = {
        args = "(unsigned num)",
        description = "Set maximum number of decal vertices.",
        returns = "()",
        type = "method"
      },
      SetMaxIndices = {
        args = "(unsigned num)",
        description = "Set maximum number of decal vertex indices.",
        returns = "()",
        type = "method"
      },
      AddDecal = {
        args = "(Drawable* target, const Vector3& worldPosition, const Quaternion& worldRotation, float size, float aspectRatio, float depth, const Vector2& topLeftUV, const Vector2& bottomRightUV, float timeToLive = 0.0f, float normalCutoff = 0.1f, unsigned subGeometry = M_MAX_UNSIGNED)",
        description = "Add a decal at world coordinates, using a target drawable's geometry for reference. If the decal needs to move with the target, the decal component should be created to the target's node. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      RemoveDecals = {
        args = "(unsigned num)",
        description = "Remove n oldest decals.",
        returns = "()",
        type = "method"
      },
      RemoveAllDecals = {
        args = "()",
        description = "Remove all decals.",
        returns = "()",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetNumDecals = {
        args = "()",
        description = "Return number of decals.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumVertices = {
        args = "()",
        description = "Retur number of vertices in the decals.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumIndices = {
        args = "()",
        description = "Retur number of vertex indices in the decals.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxVertices = {
        args = "()",
        description = "Return maximum number of decal vertices.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxIndices = {
        args = "()",
        description = "Return maximum number of decal vertex indices.",
        returns = "(unsigned)",
        type = "method"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      numDecals = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numVertices = {
        description = "(Readonly) unsigned\nVertices in the current decals.",
        type = "value"
      },
      numIndices = {
        description = "(Readonly) unsigned\nIndices in the current decals.",
        type = "value"
      },
      maxVertices = {
        description = "unsigned\nMaximum vertices.",
        type = "value"
      },
      maxIndices = {
        description = "unsigned\nMaximum indices.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Deserializer = {
    childs = {
      Read = {
        args = "(unsigned size)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      Seek = {
        args = "(unsigned position)",
        description = "Set position from the beginning of the stream.",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name of the stream.",
        returns = "(const String)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        description = "Return a checksum if applicable.",
        returns = "(unsigned)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return current position.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(unsigned)",
        type = "method"
      },
      IsEof = {
        args = "()",
        description = "Return whether the end of stream has been reached.",
        returns = "(bool)",
        type = "method"
      },
      ReadInt = {
        args = "()",
        description = "Read a 32-bit integer.",
        returns = "(int)",
        type = "method"
      },
      ReadShort = {
        args = "()",
        description = "Read a 16-bit integer.",
        returns = "(short)",
        type = "method"
      },
      ReadByte = {
        args = "()",
        description = "Read an 8-bit integer.",
        returns = "(char)",
        type = "method"
      },
      ReadUInt = {
        args = "()",
        description = "Read a 32-bit unsigned integer.",
        returns = "(unsigned)",
        type = "method"
      },
      ReadUShort = {
        args = "()",
        description = "Read a 16-bit unsigned integer.",
        returns = "(short)",
        type = "method"
      },
      ReadUByte = {
        args = "()",
        description = "Read an 8-bit unsigned integer.",
        returns = "(char)",
        type = "method"
      },
      ReadBool = {
        args = "()",
        description = "Read a bool.",
        returns = "(bool)",
        type = "method"
      },
      ReadFloat = {
        args = "()",
        description = "Read a float.",
        returns = "(float)",
        type = "method"
      },
      ReadIntRect = {
        args = "()",
        description = "Read an IntRect.",
        returns = "(IntRect)",
        type = "method"
      },
      ReadIntVector2 = {
        args = "()",
        description = "Read an IntVector2.",
        returns = "(IntVector2)",
        type = "method"
      },
      ReadRect = {
        args = "()",
        description = "Read a Rect.",
        returns = "(Rect)",
        type = "method"
      },
      ReadVector2 = {
        args = "()",
        description = "Read a Vector2.",
        returns = "(Vector2)",
        type = "method"
      },
      ReadVector3 = {
        args = "()",
        description = "Read a Vector3.",
        returns = "(Vector3)",
        type = "method"
      },
      ReadPackedVector3 = {
        args = "(float maxAbsCoord)",
        description = "Read a Vector3 packed into 3 x 16 bits with the specified maximum absolute range.",
        returns = "(Vector3)",
        type = "method"
      },
      ReadVector4 = {
        args = "()",
        description = "Read a Vector4.",
        returns = "(Vector4)",
        type = "method"
      },
      ReadQuaternion = {
        args = "()",
        description = "Read a quaternion.",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadPackedQuaternion = {
        args = "()",
        description = "Read a quaternion with each component packed in 16 bits.",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadColor = {
        args = "()",
        description = "Read a color.",
        returns = "(Color)",
        type = "method"
      },
      ReadBoundingBox = {
        args = "()",
        description = "Read a bounding box.",
        returns = "(BoundingBox)",
        type = "method"
      },
      ReadString = {
        args = "()",
        description = "Read a null-terminated string.",
        returns = "(String)",
        type = "method"
      },
      ReadFileID = {
        args = "()",
        description = "Read a four-letter file ID.",
        returns = "(String)",
        type = "method"
      },
      ReadStringHash = {
        args = "()",
        description = "Read a 32-bit StringHash.",
        returns = "(StringHash)",
        type = "method"
      },
      ReadShortStringHash = {
        args = "()",
        description = "Read a 16-bit ShortStringHash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      ReadBuffer = {
        args = "()",
        description = "Read a buffer with size encoded as VLE.",
        returns = "(VectorBuffer)",
        type = "method"
      },
      ReadResourceRef = {
        args = "()",
        description = "Read a resource reference.",
        returns = "(ResourceRef)",
        type = "method"
      },
      ReadResourceRefList = {
        args = "()",
        description = "Read a resource reference list.",
        returns = "(ResourceRefList)",
        type = "method"
      },
      ReadVariant = {
        args = "()",
        description = "(Variant) ReadVariant (VariantType type)\nRead a variant.",
        returns = "(Variant)",
        type = "method"
      },
      ReadVariantVector = {
        args = "()",
        description = "Read a variant vector.",
        returns = "(VariantVector)",
        type = "method"
      },
      ReadVariantMap = {
        args = "()",
        description = "Read a variant map.",
        returns = "(VariantMap)",
        type = "method"
      },
      ReadVLE = {
        args = "()",
        description = "Read a variable-length encoded unsigned integer, which can use 29 bits maximum.",
        returns = "(unsigned)",
        type = "method"
      },
      ReadNetID = {
        args = "()",
        description = "Read a 24-bit network object ID.",
        returns = "(unsigned)",
        type = "method"
      },
      ReadLine = {
        args = "()",
        description = "Read a text line.",
        returns = "(String)",
        type = "method"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      position = {
        description = "(Readonly) unsigned\nStream position.",
        type = "value"
      },
      size = {
        description = "(Readonly) unsigned\nStream size.",
        type = "value"
      },
      eof = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  Drawable = {
    childs = {
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Drawable2D = {
    childs = {
      SetPixelsPerUnit = {
        args = "(float pixelsPerUnit)",
        description = "Set pixels per coordinate unit.",
        returns = "()",
        type = "method"
      },
      SetSprite = {
        args = "(Sprite2D* sprite)",
        description = "Set sprite.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetZValue = {
        args = "(float zValue)",
        description = "Set Z value.",
        returns = "()",
        type = "method"
      },
      GetPixelsPerUnit = {
        args = "()",
        description = "Return pixels per coordinate unit.",
        returns = "(float)",
        type = "method"
      },
      GetSprite = {
        args = "()",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      GetZValue = {
        args = "()",
        description = "Return Z value.",
        returns = "(float)",
        type = "method"
      },
      pixelsPerUnit = {
        description = "float\nPixels per coordinate unit.",
        type = "value"
      },
      sprite = {
        valuetype = "Sprite2D",
        description = "Sprite2D*\nSprite.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*\nMaterial. If null, use a default material. If non-null, use a clone of this for updating the diffuse texture.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode.",
        type = "value"
      },
      zValue = {
        description = "float\nZ value.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DropDownList = {
    childs = {
      new = {
        args = "()",
        returns = "(DropDownList*)",
        valuetype = "DropDownList",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      AddItem = {
        args = "(UIElement* item)",
        description = "Add item to the end of the list.",
        returns = "()",
        type = "method"
      },
      InsertItem = {
        args = "(unsigned index, UIElement* item)",
        description = "Insert item to a specific position.",
        returns = "()",
        type = "method"
      },
      RemoveItem = {
        args = "(UIElement* item)",
        description = "() RemoveItem (unsigned index)\nRemove specific item.",
        returns = "()",
        type = "method"
      },
      RemoveAllItems = {
        args = "()",
        description = "Remove all items.",
        returns = "()",
        type = "method"
      },
      SetSelection = {
        args = "(unsigned index)",
        description = "Set selection.",
        returns = "()",
        type = "method"
      },
      SetPlaceholderText = {
        args = "(const String text)",
        description = "Set place holder text. This is the text shown when there is no selection in drop down list.",
        returns = "()",
        type = "method"
      },
      SetResizePopup = {
        args = "(bool enable)",
        description = "Set whether popup should be automatically resized to match the dropdown button width.",
        returns = "()",
        type = "method"
      },
      GetNumItems = {
        args = "()",
        description = "Return number of items.",
        returns = "(unsigned)",
        type = "method"
      },
      GetItem = {
        args = "(unsigned index)",
        description = "Return item at index.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetItems = {
        args = "()",
        description = "Return all items.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      GetSelection = {
        args = "()",
        description = "Return selection index, or M_MAX_UNSIGNED if none selected.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelectedItem = {
        args = "()",
        description = "Return selected item, or null if none selected.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetListView = {
        args = "()",
        description = "Return listview element.",
        returns = "(ListView*)",
        valuetype = "ListView",
        type = "method"
      },
      GetPlaceholder = {
        args = "()",
        description = "Return selected item placeholder element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetPlaceholderText = {
        args = "()",
        description = "Return place holder text.",
        returns = "(const String)",
        type = "method"
      },
      GetResizePopup = {
        args = "()",
        description = "Return whether popup should be automatically resized.",
        returns = "(bool)",
        type = "method"
      },
      numItems = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      selection = {
        description = "unsigned",
        type = "value"
      },
      selectedItem = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      listView = {
        valuetype = "ListView",
        description = "(Readonly) ListView*\nListview element.",
        type = "value"
      },
      placeholder = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*\nSelected item placeholder element.",
        type = "value"
      },
      placeholderText = {
        description = "String",
        type = "value"
      },
      resizePopup = {
        description = "bool\nResize popup flag.",
        type = "value"
      },
      SetPopup = {
        args = "(UIElement* element)",
        description = "Set popup element to show on selection.",
        returns = "()",
        type = "method"
      },
      SetPopupOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPopupOffset (int x, int y)\nSet popup element offset.",
        returns = "()",
        type = "method"
      },
      ShowPopup = {
        args = "(bool enable)",
        description = "Force the popup to show or hide.",
        returns = "()",
        type = "method"
      },
      SetAccelerator = {
        args = "(int key, int qualifiers)",
        description = "Set accelerator key (set zero key code to disable.)",
        returns = "()",
        type = "method"
      },
      GetPopup = {
        args = "()",
        description = "Return popup element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetPopupOffset = {
        args = "()",
        description = "Return popup element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetShowPopup = {
        args = "()",
        description = "Return whether popup is open.",
        returns = "(bool)",
        type = "method"
      },
      GetAcceleratorKey = {
        args = "()",
        description = "Return accelerator key code, 0 if disabled.",
        returns = "(int)",
        type = "method"
      },
      GetAcceleratorQualifiers = {
        args = "()",
        description = "Return accelerator qualifiers.",
        returns = "(int)",
        type = "method"
      },
      popup = {
        valuetype = "UIElement",
        description = "UIElement*\nPopup element.",
        type = "value"
      },
      popupOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPopup element offset.",
        type = "value"
      },
      showPopup = {
        description = "bool\nShow popup flag.",
        type = "value"
      },
      acceleratorKey = {
        description = "(Readonly) int\nAccelerator key code.",
        type = "value"
      },
      acceleratorQualifiers = {
        description = "(Readonly) int\nAccelerator qualifiers.",
        type = "value"
      },
      SetPressedOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedOffset (int x, int y)\nSet offset to image rectangle used when pressed.",
        returns = "()",
        type = "method"
      },
      SetPressedChildOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedChildOffset (int x, int y)\nSet offset of child elements when pressed.",
        returns = "()",
        type = "method"
      },
      SetRepeat = {
        args = "(float delay, float rate)",
        description = "Set repeat properties. Rate 0 (default) disables repeat.",
        returns = "()",
        type = "method"
      },
      SetRepeatDelay = {
        args = "(float delay)",
        description = "Set repeat delay.",
        returns = "()",
        type = "method"
      },
      SetRepeatRate = {
        args = "(float rate)",
        description = "Set repeat rate.",
        returns = "()",
        type = "method"
      },
      GetPressedOffset = {
        args = "()",
        description = "Return pressed image offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPressedChildOffset = {
        args = "()",
        description = "Return offset of child elements when pressed.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetRepeatDelay = {
        args = "()",
        description = "Return repeat delay.",
        returns = "(float)",
        type = "method"
      },
      GetRepeatRate = {
        args = "()",
        description = "Return repeat rate.",
        returns = "(float)",
        type = "method"
      },
      IsPressed = {
        args = "()",
        description = "Return whether is currently pressed.",
        returns = "(bool)",
        type = "method"
      },
      pressedOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed image offset.",
        type = "value"
      },
      pressedChildOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed label offset.",
        type = "value"
      },
      repeatDelay = {
        description = "float\nRepeat delay.",
        type = "value"
      },
      repeatRate = {
        description = "float\nRepeat rate.",
        type = "value"
      },
      pressed = {
        description = "(Readonly) bool\nCurrent pressed state.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Engine = {
    childs = {
      RunFrame = {
        args = "()",
        description = "Run one frame.",
        returns = "()",
        type = "method"
      },
      CreateConsole = {
        args = "()",
        description = "Create the console and return it. May return null if engine configuration does not allow creation (headless mode.)",
        returns = "(Console*)",
        valuetype = "Console",
        type = "method"
      },
      CreateDebugHud = {
        args = "()",
        description = "Create the debug hud.",
        returns = "(DebugHud*)",
        valuetype = "DebugHud",
        type = "method"
      },
      SetMinFps = {
        args = "(int fps)",
        description = "Set minimum frames per second. If FPS goes lower than this, time will appear to slow down.",
        returns = "()",
        type = "method"
      },
      SetMaxFps = {
        args = "(int fps)",
        description = "Set maximum frames per second. The engine will sleep if FPS is higher than this.",
        returns = "()",
        type = "method"
      },
      SetMaxInactiveFps = {
        args = "(int fps)",
        description = "Set maximum frames per second when the application does not have input focus.",
        returns = "()",
        type = "method"
      },
      SetTimeStepSmoothing = {
        args = "(int frames)",
        description = "Set how many frames to average for timestep smoothing. Default is 2. 1 disables smoothing.",
        returns = "()",
        type = "method"
      },
      SetPauseMinimized = {
        args = "(bool enable)",
        description = "Set whether to pause update events and audio when minimized.",
        returns = "()",
        type = "method"
      },
      SetAutoExit = {
        args = "(bool enable)",
        description = "Set whether to exit automatically on exit request (window close button.)",
        returns = "()",
        type = "method"
      },
      Exit = {
        args = "()",
        description = "Close the graphics window and set the exit flag. No-op on iOS, as an iOS application can not legally exit.",
        returns = "()",
        type = "method"
      },
      DumpProfiler = {
        args = "()",
        description = "Dump profiling information to the log.",
        returns = "()",
        type = "method"
      },
      DumpResources = {
        args = "()",
        description = "Dump information of all resources to the log.",
        returns = "()",
        type = "method"
      },
      DumpMemory = {
        args = "()",
        description = "Dump information of all memory allocations to the log. Supported in MSVC debug mode only.",
        returns = "()",
        type = "method"
      },
      GetMinFps = {
        args = "()",
        description = "Return the minimum frames per second.",
        returns = "(int)",
        type = "method"
      },
      GetMaxFps = {
        args = "()",
        description = "Return the maximum frames per second.",
        returns = "(int)",
        type = "method"
      },
      GetMaxInactiveFps = {
        args = "()",
        description = "Return the maximum frames per second when the application does not have input focus.",
        returns = "(int)",
        type = "method"
      },
      GetTimeStepSmoothing = {
        args = "()",
        description = "Return how many frames to average for timestep smoothing.",
        returns = "(int)",
        type = "method"
      },
      GetPauseMinimized = {
        args = "()",
        description = "Return whether to pause update events and audio when minimized.",
        returns = "(bool)",
        type = "method"
      },
      GetAutoExit = {
        args = "()",
        description = "Return whether to exit automatically on exit request.",
        returns = "(bool)",
        type = "method"
      },
      IsInitialized = {
        args = "()",
        description = "Return whether engine has been initialized.",
        returns = "(bool)",
        type = "method"
      },
      IsExiting = {
        args = "()",
        description = "Return whether exit has been requested.",
        returns = "(bool)",
        type = "method"
      },
      IsHeadless = {
        args = "()",
        description = "Return whether the engine has been created in headless mode.",
        returns = "(bool)",
        type = "method"
      },
      minFps = {
        description = "int\nMinimum frames per second.",
        type = "value"
      },
      maxFps = {
        description = "int\nMaximum frames per second.",
        type = "value"
      },
      maxInactiveFps = {
        description = "int\nMaximum frames per second when the application does not have input focus.",
        type = "value"
      },
      timeStepSmoothing = {
        description = "int\nHow many frames to average for the smoothed timestep.",
        type = "value"
      },
      pauseMinimized = {
        description = "bool\nPause when minimized flag.",
        type = "value"
      },
      autoExit = {
        description = "bool\nAuto-exit flag.",
        type = "value"
      },
      initialized = {
        description = "(Readonly) bool\nInitialized flag.",
        type = "value"
      },
      exiting = {
        description = "(Readonly) bool\nExiting flag.",
        type = "value"
      },
      headless = {
        description = "(Readonly) bool\nHeadless mode flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  File = {
    childs = {
      new = {
        args = "()",
        description = "(File*) new (const String fileName, FileMode mode = FILE_READ),\n(File*) new (PackageFile* package, const String fileName)",
        returns = "(File*)",
        valuetype = "File",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Open = {
        args = "(const String fileName, FileMode mode = FILE_READ)",
        description = "(bool) Open (PackageFile* package, const String fileName)\nOpen a filesystem file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Close = {
        args = "()",
        description = "Close the file.",
        returns = "()",
        type = "method"
      },
      Flush = {
        args = "()",
        description = "Flush any buffered output to the file.",
        returns = "()",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Change the file name. Used by the resource system.",
        returns = "()",
        type = "method"
      },
      GetMode = {
        args = "()",
        description = "Return the open mode.",
        returns = "(FileMode)",
        type = "method"
      },
      IsOpen = {
        args = "()",
        description = "Return whether is open.",
        returns = "(bool)",
        type = "method"
      },
      GetHandle = {
        args = "()",
        description = "Return the file handle.",
        returns = "(void*)",
        type = "method"
      },
      IsPackaged = {
        args = "()",
        description = "Return whether the file originates from a package.",
        returns = "(bool)",
        type = "method"
      },
      Read = {
        args = "(unsigned size)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      Seek = {
        args = "(unsigned position)",
        description = "Set position from the beginning of the file.",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return the file name.",
        returns = "(const String)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        description = "Return a checksum of the file contents using the SDBM hash algorithm.",
        returns = "(unsigned)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetSize = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      IsEof = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      ReadShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadUShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadUByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadFloat = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      ReadIntRect = {
        args = "()",
        returns = "(IntRect)",
        type = "method"
      },
      ReadIntVector2 = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      ReadRect = {
        args = "()",
        returns = "(Rect)",
        type = "method"
      },
      ReadVector2 = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      ReadVector3 = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ReadPackedVector3 = {
        args = "(float maxAbsCoord)",
        returns = "(Vector3)",
        type = "method"
      },
      ReadVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      ReadQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadPackedQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadColor = {
        args = "()",
        returns = "(Color)",
        type = "method"
      },
      ReadBoundingBox = {
        args = "()",
        returns = "(BoundingBox)",
        type = "method"
      },
      ReadString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadFileID = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadStringHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      ReadShortStringHash = {
        args = "()",
        returns = "(ShortStringHash)",
        type = "method"
      },
      ReadBuffer = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      ReadResourceRef = {
        args = "()",
        returns = "(ResourceRef)",
        type = "method"
      },
      ReadResourceRefList = {
        args = "()",
        returns = "(ResourceRefList)",
        type = "method"
      },
      ReadVariant = {
        args = "()",
        description = "(Variant) ReadVariant (VariantType type)",
        returns = "(Variant)",
        type = "method"
      },
      ReadVariantVector = {
        args = "()",
        returns = "(VariantVector)",
        type = "method"
      },
      ReadVariantMap = {
        args = "()",
        returns = "(VariantMap)",
        type = "method"
      },
      ReadVLE = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadNetID = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadLine = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      Write = {
        args = "(const VectorBuffer& buffer)",
        returns = "(unsigned)",
        type = "method"
      },
      WriteInt = {
        args = "(int value)",
        returns = "(bool)",
        type = "method"
      },
      WriteShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBool = {
        args = "(bool value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFloat = {
        args = "(float value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntRect = {
        args = "(const IntRect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector2 = {
        args = "(const IntVector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteRect = {
        args = "(const Rect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector2 = {
        args = "(const Vector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector3 = {
        args = "(const Vector3& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedVector3 = {
        args = "(const Vector3& value, float maxAbsCoord)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector4 = {
        args = "(const Vector4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteColor = {
        args = "(const Color& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBoundingBox = {
        args = "(const BoundingBox& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteString = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFileID = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteStringHash = {
        args = "(const StringHash& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteShortStringHash = {
        args = "(const ShortStringHash& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBuffer = {
        args = "(const VectorBuffer& buffer)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRef = {
        args = "(const ResourceRef& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRefList = {
        args = "(const ResourceRefList& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariant = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantData = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantVector = {
        args = "(const VariantVector& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantMap = {
        args = "(const VariantMap& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVLE = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteNetID = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteLine = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      mode = {
        description = "(Readonly) FileMode\nOpen mode.",
        type = "value"
      },
      open = {
        description = "(Readonly) bool",
        type = "value"
      },
      packaged = {
        description = "(Readonly) bool",
        type = "value"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned\nContent checksum.",
        type = "value"
      },
      position = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      size = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      eof = {
        description = "(Readonly) bool",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  FileSelector = {
    childs = {
      new = {
        args = "()",
        returns = "(FileSelector*)",
        valuetype = "FileSelector",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set fileselector UI style.",
        returns = "()",
        type = "method"
      },
      SetTitle = {
        args = "(const String text)",
        description = "Set title text.",
        returns = "()",
        type = "method"
      },
      SetButtonTexts = {
        args = "(const String okText, const String cancelText)",
        description = "Set button texts.",
        returns = "()",
        type = "method"
      },
      SetPath = {
        args = "(const String path)",
        description = "Set current path.",
        returns = "()",
        type = "method"
      },
      SetFileName = {
        args = "(const String fileName)",
        description = "Set current filename.",
        returns = "()",
        type = "method"
      },
      SetFilters = {
        args = "(const Vector<String>& filters, unsigned defaultIndex)",
        returns = "()",
        type = "method"
      },
      SetDirectoryMode = {
        args = "(bool enable)",
        description = "Set directory selection mode. Default false.",
        returns = "()",
        type = "method"
      },
      UpdateElements = {
        args = "()",
        description = "Update elements to layout properly. Call this after manually adjusting the sub-elements.",
        returns = "()",
        type = "method"
      },
      GetDefaultStyle = {
        args = "()",
        description = "Return the UI style file.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetWindow = {
        args = "()",
        description = "Return fileselector window.",
        returns = "(Window*)",
        valuetype = "Window",
        type = "method"
      },
      GetTitleText = {
        args = "()",
        description = "Return window title text element.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetFileList = {
        args = "()",
        description = "Return file list.",
        returns = "(ListView*)",
        valuetype = "ListView",
        type = "method"
      },
      GetPathEdit = {
        args = "()",
        description = "Return path editor.",
        returns = "(LineEdit*)",
        valuetype = "LineEdit",
        type = "method"
      },
      GetFileNameEdit = {
        args = "()",
        description = "Return filename editor.",
        returns = "(LineEdit*)",
        valuetype = "LineEdit",
        type = "method"
      },
      GetFilterList = {
        args = "()",
        description = "Return filter dropdown.",
        returns = "(DropDownList*)",
        valuetype = "DropDownList",
        type = "method"
      },
      GetOKButton = {
        args = "()",
        description = "Return OK button.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetCancelButton = {
        args = "()",
        description = "Return cancel button.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetCloseButton = {
        args = "()",
        description = "Return close button.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetTitle = {
        args = "()",
        description = "Return window title.",
        returns = "(const String)",
        type = "method"
      },
      GetPath = {
        args = "()",
        description = "Return current path.",
        returns = "(const String)",
        type = "method"
      },
      GetFileName = {
        args = "()",
        description = "Return current filename.",
        returns = "(const String)",
        type = "method"
      },
      GetFilter = {
        args = "()",
        description = "Return current filter.",
        returns = "(const String)",
        type = "method"
      },
      GetFilterIndex = {
        args = "()",
        description = "Return current filter index.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDirectoryMode = {
        args = "()",
        description = "Return directory mode flag.",
        returns = "(bool)",
        type = "method"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*",
        type = "value"
      },
      window = {
        valuetype = "Window",
        description = "(Readonly) Window*\nFileselector window.",
        type = "value"
      },
      titleText = {
        valuetype = "Text",
        description = "(Readonly) Text*\nWindow title text.",
        type = "value"
      },
      fileList = {
        valuetype = "ListView",
        description = "(Readonly) ListView*\nFile list.",
        type = "value"
      },
      pathEdit = {
        valuetype = "LineEdit",
        description = "(Readonly) LineEdit*\nPath editor.",
        type = "value"
      },
      fileNameEdit = {
        valuetype = "LineEdit",
        description = "(Readonly) LineEdit*\nFilename editor.",
        type = "value"
      },
      filterList = {
        valuetype = "DropDownList",
        description = "(Readonly) DropDownList*\nFilter dropdown.",
        type = "value"
      },
      OKButton = {
        valuetype = "Button",
        description = "(Readonly) Button*",
        type = "value"
      },
      cancelButton = {
        valuetype = "Button",
        description = "(Readonly) Button*\nCancel button.",
        type = "value"
      },
      closeButton = {
        valuetype = "Button",
        description = "(Readonly) Button*\nClose button.",
        type = "value"
      },
      title = {
        description = "String",
        type = "value"
      },
      path = {
        description = "String\nCurrent directory.",
        type = "value"
      },
      fileName = {
        description = "String",
        type = "value"
      },
      filter = {
        description = "(Readonly) String",
        type = "value"
      },
      filterIndex = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      directoryMode = {
        description = "bool\nDirectory mode flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  FileSelectorEntry = {
    childs = {
      name = {
        description = "String",
        type = "value"
      },
      directory = {
        description = "bool",
        type = "value"
      },
    },
    type = "class"
  },
  FileSystem = {
    childs = {
      SetCurrentDir = {
        args = "(const String pathName)",
        description = "Set the current working directory.",
        returns = "(bool)",
        type = "method"
      },
      CreateDir = {
        args = "(const String pathName)",
        description = "Create a directory.",
        returns = "(bool)",
        type = "method"
      },
      SystemCommand = {
        args = "(const String commandLine)",
        description = "Run a program using the command interpreter, block until it exits and return the exit code. Will fail if any allowed paths are defined.",
        returns = "(int)",
        type = "method"
      },
      SystemRun = {
        args = "(const String fileName, const Vector<String>& arguments)",
        returns = "(int)",
        type = "method"
      },
      SystemOpen = {
        args = "(const String fileName, const String mode = String::EMPTY)",
        description = "Open a file in an external program, with mode such as \"edit\" optionally specified. Will fail if any allowed paths are defined.",
        returns = "(bool)",
        type = "method"
      },
      Copy = {
        args = "(const String srcFileName, const String destFileName)",
        description = "Copy a file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Rename = {
        args = "(const String srcFileName, const String destFileName)",
        description = "Rename a file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Delete = {
        args = "(const String fileName)",
        description = "Delete a file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      RegisterPath = {
        args = "(const String pathName)",
        description = "Register a path as allowed to access. If no paths are registered, all are allowed.",
        returns = "()",
        type = "method"
      },
      GetCurrentDir = {
        args = "()",
        description = "Return the absolute current working directory.",
        returns = "(String)",
        type = "method"
      },
      HasRegisteredPaths = {
        args = "()",
        description = "Return whether paths have been registered.",
        returns = "(bool)",
        type = "method"
      },
      CheckAccess = {
        args = "(const String pathName)",
        description = "Check if a path is allowed to be accessed. If no paths are registered, all are allowed.",
        returns = "(bool)",
        type = "method"
      },
      GetLastModifiedTime = {
        args = "(const String fileName)",
        description = "Returns the file's last modified time as seconds since 1.1.1970, or 0 if can not be accessed.",
        returns = "(unsigned)",
        type = "method"
      },
      FileExists = {
        args = "(const String fileName)",
        description = "Check if a file exists.",
        returns = "(bool)",
        type = "method"
      },
      DirExists = {
        args = "(const String pathName)",
        description = "Check if a directory exists.",
        returns = "(bool)",
        type = "method"
      },
      ScanDir = {
        args = "(const String pathName, const String filter, unsigned flags, bool recursive)",
        returns = "(const Vector<String>&)",
        valuetype = "Vector<String>",
        type = "method"
      },
      GetProgramDir = {
        args = "()",
        description = "Return the program's directory. If it does not contain the Urho3D default CoreData and Data directories, and the current working directory does, return the working directory instead.",
        returns = "(String)",
        type = "method"
      },
      GetUserDocumentsDir = {
        args = "()",
        description = "Return the user documents directory.",
        returns = "(String)",
        type = "method"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  FileWatcher = {
    childs = {
      StartWatching = {
        args = "(const String pathName, bool watchSubDirs)",
        description = "Start watching a directory. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      StopWatching = {
        args = "()",
        description = "Stop watching the directory.",
        returns = "()",
        type = "method"
      },
      AddChange = {
        args = "(const String fileName)",
        description = "Add a file change into the changes queue.",
        returns = "()",
        type = "method"
      },
      GetPath = {
        args = "()",
        description = "Return the path being watched, or empty if not watching.",
        returns = "(const String)",
        type = "method"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  FocusParameters = {
    childs = {
      new = {
        args = "()",
        description = "(FocusParameters*) new (bool focus, bool nonUniform, bool autoSize, float quantize, float minView)",
        returns = "(FocusParameters*)",
        valuetype = "FocusParameters",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
    },
    type = "class"
  },
  Font = {
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    type = "class"
  },
  Frustum = {
    childs = {
      new = {
        args = "()",
        description = "(Frustum*) new (const Frustum& frustum)",
        returns = "(Frustum*)",
        valuetype = "Frustum",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(float fov, float aspectRatio, float zoom, float nearZ, float farZ)",
        description = "() Define (float fov, float aspectRatio, float zoom, float nearZ, float farZ, const Matrix3x4& transform),\n() Define (const Vector3& near, const Vector3& far),\n() Define (const Vector3& near, const Vector3& far, const Matrix3x4& transform),\n() Define (const BoundingBox& box),\n() Define (const BoundingBox& box, const Matrix3x4& transform)\nDefine with projection parameters and a transform matrix.",
        returns = "()",
        type = "method"
      },
      DefineOrtho = {
        args = "(float orthoSize, float aspectRatio, float zoom, float nearZ, float farZ)",
        description = "() DefineOrtho (float orthoSize, float aspectRatio, float zoom, float nearZ, float farZ, const Matrix3x4& transform)\nDefine with orthographic projection parameters and a transform matrix.",
        returns = "()",
        type = "method"
      },
      Transform = {
        args = "(const Matrix3& transform)",
        description = "() Transform (const Matrix3x4& transform)\nTransform by a 3x3 matrix.",
        returns = "()",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "(Intersection) IsInside (const Sphere& sphere),\n(Intersection) IsInside (const BoundingBox& box)\nTest if a point is inside or outside.",
        returns = "(Intersection)",
        type = "method"
      },
      IsInsideFast = {
        args = "(const Sphere& sphere)",
        description = "(Intersection) IsInsideFast (const BoundingBox& box)",
        returns = "(Intersection)",
        type = "method"
      },
      Distance = {
        args = "(const Vector3& point)",
        returns = "(float)",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3& transform)",
        description = "(Frustum) Transformed (const Matrix3x4& transform)",
        returns = "(Frustum)",
        type = "method"
      },
      Projected = {
        args = "(const Matrix4& transform)",
        returns = "(Rect)",
        type = "method"
      },
      UpdatePlanes = {
        args = "()",
        returns = "()",
        type = "method"
      },
    },
    type = "class"
  },
  Graphics = {
    childs = {
      SetWindowTitle = {
        args = "(const String windowTitle)",
        returns = "()",
        type = "method"
      },
      SetWindowIcon = {
        args = "(Image* windowIcon)",
        returns = "()",
        type = "method"
      },
      SetWindowPosition = {
        args = "(const IntVector2& position)",
        description = "() SetWindowPosition (int x, int y)",
        returns = "()",
        type = "method"
      },
      SetMode = {
        args = "(int width, int height, bool fullscreen, bool borderless, bool resizable, bool vsync, bool tripleBuffer, int multiSample)",
        description = "(bool) SetMode (int width, int height)",
        returns = "(bool)",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      SetFlushGPU = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      ToggleFullscreen = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      Maximize = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Minimize = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Close = {
        args = "()",
        returns = "()",
        type = "method"
      },
      TakeScreenShot = {
        args = "(Image& destImage)",
        returns = "(bool)",
        type = "method"
      },
      BeginDumpShaders = {
        args = "(const String fileName)",
        returns = "()",
        type = "method"
      },
      EndDumpShaders = {
        args = "()",
        returns = "()",
        type = "method"
      },
      PrecacheShaders = {
        args = "(Deserializer& source)",
        description = "() PrecacheShaders (const String fileName)",
        returns = "()",
        type = "method"
      },
      IsInitialized = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetExternalWindow = {
        args = "()",
        returns = "(void*)",
        type = "method"
      },
      GetWindowTitle = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetWindowPosition = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetMultiSample = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetFullscreen = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetResizable = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetBorderless = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetVSync = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetTripleBuffer = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetFlushGPU = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsDeviceLost = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetNumPrimitives = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumBatches = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetDummyColorFormat = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMapFormat = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetHiresShadowMapFormat = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetSM3Support = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetInstancingSupport = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetLightPrepassSupport = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetDeferredSupport = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetHardwareShadowSupport = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetStreamOffsetSupport = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetSRGBSupport = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetSRGBWriteSupport = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetDesktopResolution = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      GetRGBFormat = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      initialized = {
        description = "(Readonly) bool",
        type = "value"
      },
      windowTitle = {
        description = "String",
        type = "value"
      },
      windowPosition = {
        description = "IntVector2",
        type = "value"
      },
      width = {
        description = "(Readonly) int",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
      multiSample = {
        description = "(Readonly) int",
        type = "value"
      },
      fullscreen = {
        description = "(Readonly) bool",
        type = "value"
      },
      resizable = {
        description = "(Readonly) bool",
        type = "value"
      },
      borderless = {
        description = "(Readonly) bool",
        type = "value"
      },
      vSync = {
        description = "(Readonly) bool",
        type = "value"
      },
      tripleBuffer = {
        description = "(Readonly) bool",
        type = "value"
      },
      sRGB = {
        description = "bool",
        type = "value"
      },
      flushGPU = {
        description = "bool",
        type = "value"
      },
      deviceLost = {
        description = "(Readonly) bool",
        type = "value"
      },
      numPrimitives = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numBatches = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      dummyColorFormat = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      shadowMapFormat = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      hiresShadowMapFormat = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      sM3Support = {
        description = "(Readonly) bool",
        type = "value"
      },
      instancingSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      lightPrepassSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      deferredSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      hardwareShadowSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      streamOffsetSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      sRGBSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      sRGBWriteSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      desktopResolution = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  HttpRequest = {
    childs = {
      GetURL = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetVerb = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetError = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      GetState = {
        args = "()",
        returns = "(HttpRequestState)",
        type = "method"
      },
      GetAvailableSize = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      IsOpen = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      URL = {
        description = "(Readonly) String",
        type = "value"
      },
      verb = {
        description = "(Readonly) String",
        type = "value"
      },
      error = {
        description = "(Readonly) String",
        type = "value"
      },
      state = {
        description = "(Readonly) HttpRequestState",
        type = "value"
      },
      availableSize = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      open = {
        description = "(Readonly) bool",
        type = "value"
      },
      Read = {
        args = "(unsigned size)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      Seek = {
        args = "(unsigned position)",
        description = "Set position from the beginning of the stream.",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name of the stream.",
        returns = "(const String)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        description = "Return a checksum if applicable.",
        returns = "(unsigned)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return current position.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(unsigned)",
        type = "method"
      },
      IsEof = {
        args = "()",
        description = "Return whether the end of stream has been reached.",
        returns = "(bool)",
        type = "method"
      },
      ReadInt = {
        args = "()",
        description = "Read a 32-bit integer.",
        returns = "(int)",
        type = "method"
      },
      ReadShort = {
        args = "()",
        description = "Read a 16-bit integer.",
        returns = "(short)",
        type = "method"
      },
      ReadByte = {
        args = "()",
        description = "Read an 8-bit integer.",
        returns = "(char)",
        type = "method"
      },
      ReadUInt = {
        args = "()",
        description = "Read a 32-bit unsigned integer.",
        returns = "(unsigned)",
        type = "method"
      },
      ReadUShort = {
        args = "()",
        description = "Read a 16-bit unsigned integer.",
        returns = "(short)",
        type = "method"
      },
      ReadUByte = {
        args = "()",
        description = "Read an 8-bit unsigned integer.",
        returns = "(char)",
        type = "method"
      },
      ReadBool = {
        args = "()",
        description = "Read a bool.",
        returns = "(bool)",
        type = "method"
      },
      ReadFloat = {
        args = "()",
        description = "Read a float.",
        returns = "(float)",
        type = "method"
      },
      ReadIntRect = {
        args = "()",
        description = "Read an IntRect.",
        returns = "(IntRect)",
        type = "method"
      },
      ReadIntVector2 = {
        args = "()",
        description = "Read an IntVector2.",
        returns = "(IntVector2)",
        type = "method"
      },
      ReadRect = {
        args = "()",
        description = "Read a Rect.",
        returns = "(Rect)",
        type = "method"
      },
      ReadVector2 = {
        args = "()",
        description = "Read a Vector2.",
        returns = "(Vector2)",
        type = "method"
      },
      ReadVector3 = {
        args = "()",
        description = "Read a Vector3.",
        returns = "(Vector3)",
        type = "method"
      },
      ReadPackedVector3 = {
        args = "(float maxAbsCoord)",
        description = "Read a Vector3 packed into 3 x 16 bits with the specified maximum absolute range.",
        returns = "(Vector3)",
        type = "method"
      },
      ReadVector4 = {
        args = "()",
        description = "Read a Vector4.",
        returns = "(Vector4)",
        type = "method"
      },
      ReadQuaternion = {
        args = "()",
        description = "Read a quaternion.",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadPackedQuaternion = {
        args = "()",
        description = "Read a quaternion with each component packed in 16 bits.",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadColor = {
        args = "()",
        description = "Read a color.",
        returns = "(Color)",
        type = "method"
      },
      ReadBoundingBox = {
        args = "()",
        description = "Read a bounding box.",
        returns = "(BoundingBox)",
        type = "method"
      },
      ReadString = {
        args = "()",
        description = "Read a null-terminated string.",
        returns = "(String)",
        type = "method"
      },
      ReadFileID = {
        args = "()",
        description = "Read a four-letter file ID.",
        returns = "(String)",
        type = "method"
      },
      ReadStringHash = {
        args = "()",
        description = "Read a 32-bit StringHash.",
        returns = "(StringHash)",
        type = "method"
      },
      ReadShortStringHash = {
        args = "()",
        description = "Read a 16-bit ShortStringHash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      ReadBuffer = {
        args = "()",
        description = "Read a buffer with size encoded as VLE.",
        returns = "(VectorBuffer)",
        type = "method"
      },
      ReadResourceRef = {
        args = "()",
        description = "Read a resource reference.",
        returns = "(ResourceRef)",
        type = "method"
      },
      ReadResourceRefList = {
        args = "()",
        description = "Read a resource reference list.",
        returns = "(ResourceRefList)",
        type = "method"
      },
      ReadVariant = {
        args = "()",
        description = "(Variant) ReadVariant (VariantType type)\nRead a variant.",
        returns = "(Variant)",
        type = "method"
      },
      ReadVariantVector = {
        args = "()",
        description = "Read a variant vector.",
        returns = "(VariantVector)",
        type = "method"
      },
      ReadVariantMap = {
        args = "()",
        description = "Read a variant map.",
        returns = "(VariantMap)",
        type = "method"
      },
      ReadVLE = {
        args = "()",
        description = "Read a variable-length encoded unsigned integer, which can use 29 bits maximum.",
        returns = "(unsigned)",
        type = "method"
      },
      ReadNetID = {
        args = "()",
        description = "Read a 24-bit network object ID.",
        returns = "(unsigned)",
        type = "method"
      },
      ReadLine = {
        args = "()",
        description = "Read a text line.",
        returns = "(String)",
        type = "method"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      position = {
        description = "(Readonly) unsigned\nStream position.",
        type = "value"
      },
      size = {
        description = "(Readonly) unsigned\nStream size.",
        type = "value"
      },
      eof = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  Image = {
    childs = {
      new = {
        args = "()",
        returns = "(Image*)",
        valuetype = "Image",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(int width, int height, unsigned components)",
        description = "(bool) SetSize (int width, int height, int depth, unsigned components)\nSet 2D size and number of color components. Old image data will be destroyed and new data is undefined. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetPixel = {
        args = "(int x, int y, const Color& color)",
        description = "() SetPixel (int x, int y, int z, const Color& color)\nSet a 2D pixel.",
        returns = "()",
        type = "method"
      },
      LoadColorLUT = {
        args = "(Deserializer& source)",
        description = "(bool) LoadColorLUT (const String fileName)\nLoad as color LUT. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FlipVertical = {
        args = "()",
        description = "Flip image vertically.",
        returns = "()",
        type = "method"
      },
      Resize = {
        args = "(int width, int height)",
        description = "Resize image by bilinear resampling. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Clear = {
        args = "(const Color& color)",
        description = "Clear the image with a color.",
        returns = "()",
        type = "method"
      },
      SaveBMP = {
        args = "(const String fileName)",
        description = "Save in BMP format. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SavePNG = {
        args = "(const String fileName)",
        description = "Save in PNG format. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveTGA = {
        args = "(const String fileName)",
        description = "Save in TGA format. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveJPG = {
        args = "(const String fileName, int quality)",
        description = "Save in JPG format with compression quality. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetPixel = {
        args = "(int x, int y)",
        description = "(Color) GetPixel (int x, int y, int z)\nReturn a 2D pixel color.",
        returns = "(Color)",
        type = "method"
      },
      GetPixelBilinear = {
        args = "(float x, float y)",
        description = "Return a bilinearly sampled 2D pixel color. X and Y have the range 0-1.",
        returns = "(Color)",
        type = "method"
      },
      GetPixelTrilinear = {
        args = "(float x, float y, float z)",
        description = "Return a trilinearly sampled 3D pixel color. X, Y and Z have the range 0-1.",
        returns = "(Color)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetDepth = {
        args = "()",
        description = "Return depth.",
        returns = "(int)",
        type = "method"
      },
      GetComponents = {
        args = "()",
        description = "Return number of color components.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether is compressed.",
        returns = "(bool)",
        type = "method"
      },
      GetCompressedFormat = {
        args = "()",
        description = "Return compressed format.",
        returns = "(CompressedFormat)",
        type = "method"
      },
      GetNumCompressedLevels = {
        args = "()",
        description = "Return number of compressed mip levels.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCompressedLevel = {
        args = "(unsigned index)",
        description = "Return a compressed mip level.",
        returns = "(CompressedLevel)",
        type = "method"
      },
      width = {
        description = "(Readonly) int\nWidth.",
        type = "value"
      },
      height = {
        description = "(Readonly) int\nHeight.",
        type = "value"
      },
      depth = {
        description = "(Readonly) int\nDepth.",
        type = "value"
      },
      components = {
        description = "(Readonly) unsigned\nNumber of color components.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      compressedFormat = {
        description = "(Readonly) CompressedFormat\nCompressed format.",
        type = "value"
      },
      numCompressedLevels = {
        description = "(Readonly) unsigned\nNumber of compressed mip levels.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Input = {
    childs = {
      SetToggleFullscreen = {
        args = "(bool enable)",
        description = "Set whether ALT-ENTER fullscreen toggle is enabled.",
        returns = "()",
        type = "method"
      },
      SetMouseVisible = {
        args = "(bool enable)",
        description = "Set whether the operating system mouse cursor is visible. When not visible (default), is kept centered to prevent leaving the window.",
        returns = "()",
        type = "method"
      },
      OpenJoystick = {
        args = "(unsigned index)",
        description = "Open a joystick. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      CloseJoystick = {
        args = "(unsigned index)",
        description = "Close a joystick.",
        returns = "()",
        type = "method"
      },
      DetectJoysticks = {
        args = "()",
        description = "Redetect joysticks. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetScreenKeyboardVisible = {
        args = "(bool enable)",
        description = "Show or hide on-screen keyboard on platforms that support it. When shown, keypresses from it are delivered as key events.",
        returns = "()",
        type = "method"
      },
      GetKeyDown = {
        args = "(int key)",
        description = "Check if a key is held down.",
        returns = "(bool)",
        type = "method"
      },
      GetKeyPress = {
        args = "(int key)",
        description = "Check if a key has been pressed on this frame.",
        returns = "(bool)",
        type = "method"
      },
      GetMouseButtonDown = {
        args = "(int button)",
        description = "Check if a mouse button is held down.",
        returns = "(bool)",
        type = "method"
      },
      GetMouseButtonPress = {
        args = "(int button)",
        description = "Check if a mouse button has been pressed on this frame.",
        returns = "(bool)",
        type = "method"
      },
      GetQualifierDown = {
        args = "(int qualifier)",
        description = "Check if a qualifier key is held down.",
        returns = "(bool)",
        type = "method"
      },
      GetQualifierPress = {
        args = "(int qualifier)",
        description = "Check if a qualifier key has been pressed on this frame.",
        returns = "(bool)",
        type = "method"
      },
      GetQualifiers = {
        args = "()",
        description = "Return the currently held down qualifiers.",
        returns = "(int)",
        type = "method"
      },
      GetMousePosition = {
        args = "()",
        description = "Return mouse position within window. Should only be used with a visible mouse cursor.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetMouseMove = {
        args = "()",
        description = "Return mouse movement since last frame.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMouseMoveX = {
        args = "()",
        description = "Return horizontal mouse movement since last frame.",
        returns = "(int)",
        type = "method"
      },
      GetMouseMoveY = {
        args = "()",
        description = "Return vertical mouse movement since last frame.",
        returns = "(int)",
        type = "method"
      },
      GetMouseMoveWheel = {
        args = "()",
        description = "Return mouse wheel movement since last frame.",
        returns = "(int)",
        type = "method"
      },
      GetNumTouches = {
        args = "()",
        description = "Return number of active finger touches.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTouch = {
        args = "(unsigned index)",
        description = "Return active finger touch by index.",
        returns = "(TouchState*)",
        valuetype = "TouchState",
        type = "method"
      },
      GetNumJoysticks = {
        args = "()",
        description = "Return number of connected joysticks.",
        returns = "(unsigned)",
        type = "method"
      },
      GetJoystickName = {
        args = "(unsigned index)",
        description = "Return joystick name by index.",
        returns = "(const String)",
        type = "method"
      },
      GetJoystick = {
        args = "(unsigned index)",
        description = "Return joystick state by index. Automatically open if not opened yet.",
        returns = "(JoystickState*)",
        valuetype = "JoystickState",
        type = "method"
      },
      GetToggleFullscreen = {
        args = "()",
        description = "Return whether fullscreen toggle is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetScreenKeyboardSupport = {
        args = "()",
        description = "Return whether on-screen keyboard is supported.",
        returns = "(bool)",
        type = "method"
      },
      IsScreenKeyboardVisible = {
        args = "()",
        description = "Return whether on-screen keyboard is being shown.",
        returns = "(bool)",
        type = "method"
      },
      IsMouseVisible = {
        args = "()",
        description = "Return whether the operating system mouse cursor is visible.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether application window has input focus.",
        returns = "(bool)",
        type = "method"
      },
      IsMinimized = {
        args = "()",
        description = "Return whether application window is minimized.",
        returns = "(bool)",
        type = "method"
      },
      qualifiers = {
        description = "(Readonly) int",
        type = "value"
      },
      mousePosition = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      mouseMove = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nMouse movement since last frame.",
        type = "value"
      },
      mouseMoveX = {
        description = "(Readonly) int",
        type = "value"
      },
      mouseMoveY = {
        description = "(Readonly) int",
        type = "value"
      },
      mouseMoveWheel = {
        description = "(Readonly) int\nMouse wheel movement since last frame.",
        type = "value"
      },
      numTouches = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numJoysticks = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      toggleFullscreen = {
        description = "(Readonly) bool\nFullscreen toggle flag.",
        type = "value"
      },
      screenKeyboardSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      screenKeyboardVisible = {
        description = "bool",
        type = "value"
      },
      mouseVisible = {
        description = "bool\nOperating system mouse cursor visible flag.",
        type = "value"
      },
      focus = {
        description = "(Readonly) bool",
        type = "value"
      },
      minimized = {
        description = "(Readonly) bool\nMinimized flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  IntRect = {
    childs = {
      new = {
        args = "()",
        description = "(IntRect*) new (int left, int top, int right, int bottom)",
        returns = "(IntRect*)",
        valuetype = "IntRect",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Size = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      Width = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      Height = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      IsInside = {
        args = "(const IntVector2& point)",
        returns = "(Intersection)",
        type = "method"
      },
      left = {
        description = "int",
        type = "value"
      },
      top = {
        description = "int",
        type = "value"
      },
      right = {
        description = "int",
        type = "value"
      },
      bottom = {
        description = "int",
        type = "value"
      },
      ZERO = {
        description = "const IntRect",
        type = "value"
      },
      size = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      width = {
        description = "(Readonly) int",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
    },
    type = "class"
  },
  IntVector2 = {
    childs = {
      new = {
        args = "()",
        description = "(IntVector2*) new (int x, int y),\n(IntVector2*) new (const IntVector2& rhs)",
        returns = "(IntVector2*)",
        valuetype = "IntVector2",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      x = {
        description = "int",
        type = "value"
      },
      y = {
        description = "int",
        type = "value"
      },
      ZERO = {
        description = "const IntVector2",
        type = "value"
      },
    },
    type = "class"
  },
  JoystickState = {
    childs = {
      GetNumButtons = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumAxes = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumHats = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetButtonDown = {
        args = "(unsigned index)",
        returns = "(bool)",
        type = "method"
      },
      GetButtonPress = {
        args = "(unsigned index)",
        returns = "(bool)",
        type = "method"
      },
      GetAxisPosition = {
        args = "(unsigned index)",
        returns = "(float)",
        type = "method"
      },
      GetHatPosition = {
        args = "(unsigned index)",
        returns = "(int)",
        type = "method"
      },
      numButtons = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numAxes = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numHats = {
        description = "(Readonly) unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  Light = {
    childs = {
      SetLightType = {
        args = "(LightType type)",
        description = "Set light type.",
        returns = "()",
        type = "method"
      },
      SetPerVertex = {
        args = "(bool enable)",
        description = "Set vertex lighting mode.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "Set color.",
        returns = "()",
        type = "method"
      },
      SetSpecularIntensity = {
        args = "(float intensity)",
        description = "Set specular intensity.",
        returns = "()",
        type = "method"
      },
      SetRange = {
        args = "(float range)",
        description = "Set range.",
        returns = "()",
        type = "method"
      },
      SetFov = {
        args = "(float fov)",
        description = "Set spotlight field of view.",
        returns = "()",
        type = "method"
      },
      SetAspectRatio = {
        args = "(float aspectRatio)",
        description = "Set spotlight aspect ratio.",
        returns = "()",
        type = "method"
      },
      SetFadeDistance = {
        args = "(float distance)",
        description = "Set fade out start distance.",
        returns = "()",
        type = "method"
      },
      SetShadowFadeDistance = {
        args = "(float distance)",
        description = "Set shadow fade out start distance. Only has effect if shadow distance is also non-zero.",
        returns = "()",
        type = "method"
      },
      SetShadowBias = {
        args = "(const BiasParameters& parameters)",
        description = "Set shadow depth bias parameters.",
        returns = "()",
        type = "method"
      },
      SetShadowCascade = {
        args = "(const CascadeParameters& parameters)",
        description = "Set directional light cascaded shadow parameters.",
        returns = "()",
        type = "method"
      },
      SetShadowFocus = {
        args = "(const FocusParameters& parameters)",
        description = "Set shadow map focusing parameters.",
        returns = "()",
        type = "method"
      },
      SetShadowIntensity = {
        args = "(float intensity)",
        description = "Set shadow intensity between 0.0 - 1.0. 0.0 (the default) gives fully dark shadows.",
        returns = "()",
        type = "method"
      },
      SetShadowResolution = {
        args = "(float resolution)",
        description = "Set shadow resolution between 0.25 - 1.0. Determines the shadow map to use.",
        returns = "()",
        type = "method"
      },
      SetShadowNearFarRatio = {
        args = "(float nearFarRatio)",
        description = "Set shadow camera near/far clip distance ratio.",
        returns = "()",
        type = "method"
      },
      SetRampTexture = {
        args = "(Texture* texture)",
        description = "Set range attenuation texture.",
        returns = "()",
        type = "method"
      },
      SetShapeTexture = {
        args = "(Texture* texture)",
        description = "Set spotlight attenuation texture.",
        returns = "()",
        type = "method"
      },
      GetLightType = {
        args = "()",
        description = "Return light type.",
        returns = "(LightType)",
        type = "method"
      },
      GetPerVertex = {
        args = "()",
        description = "Return vertex lighting mode.",
        returns = "(bool)",
        type = "method"
      },
      GetColor = {
        args = "()",
        description = "Return color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetSpecularIntensity = {
        args = "()",
        description = "Return specular intensity.",
        returns = "(float)",
        type = "method"
      },
      GetRange = {
        args = "()",
        description = "Return range.",
        returns = "(float)",
        type = "method"
      },
      GetFov = {
        args = "()",
        description = "Return spotlight field of view.",
        returns = "(float)",
        type = "method"
      },
      GetAspectRatio = {
        args = "()",
        description = "Return spotlight aspect ratio.",
        returns = "(float)",
        type = "method"
      },
      GetFadeDistance = {
        args = "()",
        description = "Return fade start distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowFadeDistance = {
        args = "()",
        description = "Return shadow fade start distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowBias = {
        args = "()",
        description = "Return shadow depth bias parameters.",
        returns = "(const BiasParameters&)",
        valuetype = "BiasParameters",
        type = "method"
      },
      GetShadowCascade = {
        args = "()",
        description = "Return directional light cascaded shadow parameters.",
        returns = "(const CascadeParameters&)",
        valuetype = "CascadeParameters",
        type = "method"
      },
      GetShadowFocus = {
        args = "()",
        description = "Return shadow map focus parameters.",
        returns = "(const FocusParameters&)",
        valuetype = "FocusParameters",
        type = "method"
      },
      GetShadowIntensity = {
        args = "()",
        description = "Return shadow intensity.",
        returns = "(float)",
        type = "method"
      },
      GetShadowResolution = {
        args = "()",
        description = "Return shadow resolution.",
        returns = "(float)",
        type = "method"
      },
      GetShadowNearFarRatio = {
        args = "()",
        description = "Return shadow camera near/far clip distance ratio.",
        returns = "(float)",
        type = "method"
      },
      GetRampTexture = {
        args = "()",
        description = "Return range attenuation texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetShapeTexture = {
        args = "()",
        description = "Return spotlight attenuation texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetFrustum = {
        args = "()",
        description = "Return spotlight frustum.",
        returns = "(Frustum)",
        type = "method"
      },
      lightType = {
        description = "LightType\nLight type.",
        type = "value"
      },
      perVertex = {
        description = "bool\nPer-vertex lighting flag.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColor.",
        type = "value"
      },
      specularIntensity = {
        description = "float\nSpecular intensity.",
        type = "value"
      },
      range = {
        description = "float\nRange.",
        type = "value"
      },
      fov = {
        description = "float\nSpotlight field of view.",
        type = "value"
      },
      aspectRatio = {
        description = "float\nSpotlight aspect ratio.",
        type = "value"
      },
      fadeDistance = {
        description = "float\nFade start distance.",
        type = "value"
      },
      shadowFadeDistance = {
        description = "float\nShadow fade start distance.",
        type = "value"
      },
      shadowBias = {
        valuetype = "BiasParameters",
        description = "BiasParameters&\nShadow depth bias parameters.",
        type = "value"
      },
      shadowCascade = {
        valuetype = "CascadeParameters",
        description = "CascadeParameters&\nDirectional light cascaded shadow parameters.",
        type = "value"
      },
      shadowFocus = {
        valuetype = "FocusParameters",
        description = "FocusParameters&\nShadow map focus parameters.",
        type = "value"
      },
      shadowIntensity = {
        description = "float\nShadow intensity.",
        type = "value"
      },
      shadowResolution = {
        description = "float\nShadow resolution.",
        type = "value"
      },
      shadowNearFarRatio = {
        description = "float\nShadow camera near/far clip distance ratio.",
        type = "value"
      },
      rampTexture = {
        valuetype = "Texture",
        description = "Texture*\nRange attenuation texture.",
        type = "value"
      },
      shapeTexture = {
        valuetype = "Texture",
        description = "Texture*\nSpotlight attenuation texture.",
        type = "value"
      },
      frustum = {
        description = "(Readonly) Frustum",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  LineEdit = {
    childs = {
      new = {
        args = "()",
        returns = "(LineEdit*)",
        valuetype = "LineEdit",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetText = {
        args = "(const String text)",
        description = "Set text.",
        returns = "()",
        type = "method"
      },
      SetCursorPosition = {
        args = "(unsigned position)",
        description = "Set cursor position.",
        returns = "()",
        type = "method"
      },
      SetCursorBlinkRate = {
        args = "(float rate)",
        description = "Set cursor blink rate. 0 disables blinking.",
        returns = "()",
        type = "method"
      },
      SetMaxLength = {
        args = "(unsigned length)",
        description = "Set maximum text length. 0 for unlimited.",
        returns = "()",
        type = "method"
      },
      SetEchoCharacter = {
        args = "(unsigned c)",
        description = "Set echo character for password entry and such. 0 (default) shows the actual text.",
        returns = "()",
        type = "method"
      },
      SetCursorMovable = {
        args = "(bool enable)",
        description = "Set whether can move cursor with arrows or mouse, default true.",
        returns = "()",
        type = "method"
      },
      SetTextSelectable = {
        args = "(bool enable)",
        description = "Set whether selections are allowed, default true.",
        returns = "()",
        type = "method"
      },
      SetTextCopyable = {
        args = "(bool enable)",
        description = "Set whether copy-paste operations are allowed, default true.",
        returns = "()",
        type = "method"
      },
      GetText = {
        args = "()",
        description = "Return text.",
        returns = "(const String)",
        type = "method"
      },
      GetCursorPosition = {
        args = "()",
        description = "Return cursor position.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCursorBlinkRate = {
        args = "()",
        description = "Return cursor blink rate.",
        returns = "(float)",
        type = "method"
      },
      GetMaxLength = {
        args = "()",
        description = "Return maximum text length.",
        returns = "(unsigned)",
        type = "method"
      },
      GetEchoCharacter = {
        args = "()",
        description = "Return echo character.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCursorMovable = {
        args = "()",
        description = "Return whether can move cursor with arrows or mouse.",
        returns = "(bool)",
        type = "method"
      },
      IsTextSelectable = {
        args = "()",
        description = "Return whether selections are allowed.",
        returns = "(bool)",
        type = "method"
      },
      IsTextCopyable = {
        args = "()",
        description = "Return whether copy-paste operations are allowed.",
        returns = "(bool)",
        type = "method"
      },
      GetTextElement = {
        args = "()",
        description = "Return text element.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetCursor = {
        args = "()",
        description = "Return cursor element.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      text = {
        description = "String\nText element.",
        type = "value"
      },
      cursorPosition = {
        description = "unsigned\nText edit cursor position.",
        type = "value"
      },
      cursorBlinkRate = {
        description = "float\nCursor blink rate.",
        type = "value"
      },
      maxLength = {
        description = "unsigned\nMaximum text length.",
        type = "value"
      },
      echoCharacter = {
        description = "unsigned\nEcho character.",
        type = "value"
      },
      cursorMovable = {
        description = "bool\nCursor movable flag.",
        type = "value"
      },
      textSelectable = {
        description = "bool\nText selectable flag.",
        type = "value"
      },
      textCopyable = {
        description = "bool\nCopy-paste enable flag.",
        type = "value"
      },
      textElement = {
        valuetype = "Text",
        description = "(Readonly) Text*",
        type = "value"
      },
      cursor = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nCursor element.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ListView = {
    childs = {
      new = {
        args = "()",
        returns = "(ListView*)",
        valuetype = "ListView",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      AddItem = {
        args = "(UIElement* item)",
        description = "Add item to the end of the list.",
        returns = "()",
        type = "method"
      },
      InsertItem = {
        args = "(unsigned index, UIElement* item, UIElement* parentItem = 0)",
        description = "And if the index is lesser than the index of the parent item itself then the new item is inserted before the first child item.",
        returns = "()",
        type = "method"
      },
      RemoveItem = {
        args = "(UIElement* item, unsigned index = 0)",
        description = "() RemoveItem (unsigned index)\nRemove specific item, starting search at the specified index if provided. In hierarchy mode will also remove any children.",
        returns = "()",
        type = "method"
      },
      RemoveAllItems = {
        args = "()",
        description = "Remove all items.",
        returns = "()",
        type = "method"
      },
      SetSelection = {
        args = "(unsigned index)",
        description = "Set selection.",
        returns = "()",
        type = "method"
      },
      SetSelections = {
        args = "(const PODVector<unsigned>& indices)",
        returns = "()",
        type = "method"
      },
      AddSelection = {
        args = "(unsigned index)",
        description = "Add item to the selection, multiselect mode only.",
        returns = "()",
        type = "method"
      },
      RemoveSelection = {
        args = "(unsigned index)",
        description = "Remove item from the selection.",
        returns = "()",
        type = "method"
      },
      ToggleSelection = {
        args = "(unsigned index)",
        description = "Toggle selection of an item.",
        returns = "()",
        type = "method"
      },
      ChangeSelection = {
        args = "(int delta, bool additive = false)",
        description = "Move selection by a delta and clamp at list ends. If additive (multiselect only), will add to the existing selection.",
        returns = "()",
        type = "method"
      },
      ClearSelection = {
        args = "()",
        description = "Clear selection.",
        returns = "()",
        type = "method"
      },
      SetHighlightMode = {
        args = "(HighlightMode mode)",
        description = "Set selected items' highlight mode.",
        returns = "()",
        type = "method"
      },
      SetMultiselect = {
        args = "(bool enable)",
        description = "Enable multiselect.",
        returns = "()",
        type = "method"
      },
      SetHierarchyMode = {
        args = "(bool enable)",
        description = "All items in the list will be lost during mode change.",
        returns = "()",
        type = "method"
      },
      SetBaseIndent = {
        args = "(int baseIndent)",
        description = "Set base indent, i.e. the indent level of the ultimate parent item.",
        returns = "()",
        type = "method"
      },
      SetClearSelectionOnDefocus = {
        args = "(bool enable)",
        description = "Enable clearing of selection on defocus.",
        returns = "()",
        type = "method"
      },
      Expand = {
        args = "(unsigned index, bool enable, bool recursive = false)",
        description = "Expand item at index. Only has effect in hierarchy mode.",
        returns = "()",
        type = "method"
      },
      ToggleExpand = {
        args = "(unsigned index, bool recursive = false)",
        description = "Toggle item's expanded flag at index. Only has effect in hierarchy mode.",
        returns = "()",
        type = "method"
      },
      GetNumItems = {
        args = "()",
        description = "Return number of items.",
        returns = "(unsigned)",
        type = "method"
      },
      GetItem = {
        args = "(unsigned index)",
        description = "Return item at index.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetItems = {
        args = "()",
        description = "Return all items.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      FindItem = {
        args = "(UIElement* item)",
        description = "Return index of item, or M_MAX_UNSIGNED If not found.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelection = {
        args = "()",
        description = "Return first selected index, or M_MAX_UNSIGNED if none selected.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelections = {
        args = "()",
        description = "Return all selected indices.",
        returns = "(const PODVector<unsigned>&)",
        valuetype = "PODVector<unsigned>",
        type = "method"
      },
      GetSelectedItem = {
        args = "()",
        description = "Return first selected item, or null if none selected.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetSelectedItems = {
        args = "()",
        description = "Return all selected items.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      IsSelected = {
        args = "(unsigned index)",
        description = "Return whether an item at index is seleccted.",
        returns = "(bool)",
        type = "method"
      },
      IsExpanded = {
        args = "(unsigned index)",
        description = "Return whether an item at index has its children expanded (in hierachy mode only).",
        returns = "(bool)",
        type = "method"
      },
      GetHighlightMode = {
        args = "()",
        description = "Return highlight mode.",
        returns = "(HighlightMode)",
        type = "method"
      },
      GetMultiselect = {
        args = "()",
        description = "Return whether multiselect enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetClearSelectionOnDefocus = {
        args = "()",
        description = "Return whether selection is cleared on defocus.",
        returns = "(bool)",
        type = "method"
      },
      GetHierarchyMode = {
        args = "()",
        description = "Return whether hierarchy mode enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetBaseIndent = {
        args = "()",
        description = "Return base indent.",
        returns = "(int)",
        type = "method"
      },
      numItems = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      selection = {
        description = "unsigned",
        type = "value"
      },
      selectedItem = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      highlightMode = {
        description = "HighlightMode\nHighlight mode.",
        type = "value"
      },
      multiselect = {
        description = "bool\nMultiselect flag.",
        type = "value"
      },
      clearSelectionOnDefocus = {
        description = "bool\nClear selection on defocus flag.",
        type = "value"
      },
      hierarchyMode = {
        description = "bool\nHierarchy mode flag.",
        type = "value"
      },
      baseIndent = {
        description = "int\nBase indent, used in hierarchy mode only.",
        type = "value"
      },
      SetContentElement = {
        args = "(UIElement* element)",
        description = "Set content element.",
        returns = "()",
        type = "method"
      },
      SetViewPosition = {
        args = "(const IntVector2& position)",
        description = "() SetViewPosition (int x, int y)\nSet view offset from the top-left corner.",
        returns = "()",
        type = "method"
      },
      SetScrollBarsVisible = {
        args = "(bool horizontal, bool vertical)",
        description = "Set scrollbars' visibility manually. Disables scrollbar autoshow/hide.",
        returns = "()",
        type = "method"
      },
      SetScrollBarsAutoVisible = {
        args = "(bool enable)",
        description = "Set whether to automatically show/hide scrollbars. Default true.",
        returns = "()",
        type = "method"
      },
      SetScrollStep = {
        args = "(float step)",
        description = "Set arrow key scroll step. Also sets it on the scrollbars.",
        returns = "()",
        type = "method"
      },
      SetPageStep = {
        args = "(float step)",
        description = "Set arrow key page step.",
        returns = "()",
        type = "method"
      },
      GetViewPosition = {
        args = "()",
        description = "Return view offset from the top-left corner.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetContentElement = {
        args = "()",
        description = "Return content element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetHorizontalScrollBar = {
        args = "()",
        description = "Return horizontal scroll bar.",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      GetVerticalScrollBar = {
        args = "()",
        description = "Return vertical scroll bar.",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      GetScrollPanel = {
        args = "()",
        description = "Return scroll panel.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      GetScrollBarsAutoVisible = {
        args = "()",
        description = "Return whether scrollbars are automatically shown/hidden.",
        returns = "(bool)",
        type = "method"
      },
      GetScrollStep = {
        args = "()",
        description = "Return arrow key scroll step.",
        returns = "(float)",
        type = "method"
      },
      GetPageStep = {
        args = "()",
        description = "Return arrow key page step.",
        returns = "(float)",
        type = "method"
      },
      viewPosition = {
        valuetype = "IntVector2",
        description = "IntVector2&\nCurrent view offset from the top-left corner.",
        type = "value"
      },
      contentElement = {
        valuetype = "UIElement",
        description = "UIElement*\nContent element.",
        type = "value"
      },
      horizontalScrollBar = {
        valuetype = "ScrollBar",
        description = "(Readonly) ScrollBar*\nHorizontal scroll bar.",
        type = "value"
      },
      verticalScrollBar = {
        valuetype = "ScrollBar",
        description = "(Readonly) ScrollBar*\nVertical scroll bar.",
        type = "value"
      },
      scrollPanel = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nScroll panel element.",
        type = "value"
      },
      scrollBarsAutoVisible = {
        description = "bool\nAutomatically show/hide scrollbars flag.",
        type = "value"
      },
      scrollStep = {
        description = "float",
        type = "value"
      },
      pageStep = {
        description = "float\nArrow key page step.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Log = {
    childs = {
      Open = {
        args = "(const String fileName)",
        description = "Open the log file.",
        returns = "()",
        type = "method"
      },
      Close = {
        args = "()",
        description = "Close the log file.",
        returns = "()",
        type = "method"
      },
      SetLevel = {
        args = "(int level)",
        description = "Set logging level.",
        returns = "()",
        type = "method"
      },
      SetTimeStamp = {
        args = "(bool enable)",
        description = "Set whether to timestamp log messages.",
        returns = "()",
        type = "method"
      },
      SetQuiet = {
        args = "(bool quiet)",
        description = "Set quiet mode ie. only print error entries to standard error stream (which is normally redirected to console also). Output to log file is not affected by this mode.",
        returns = "()",
        type = "method"
      },
      GetLevel = {
        args = "()",
        description = "Return logging level.",
        returns = "(int)",
        type = "method"
      },
      GetTimeStamp = {
        args = "()",
        description = "Return whether log messages are timestamped.",
        returns = "(bool)",
        type = "method"
      },
      GetLastMessage = {
        args = "()",
        description = "Return last log message.",
        returns = "(String)",
        type = "method"
      },
      IsQuiet = {
        args = "()",
        description = "Return whether log is in quiet mode (only errors printed to standard error stream).",
        returns = "(bool)",
        type = "method"
      },
      Write = {
        args = "(int level, const String message)",
        description = "Write to the log. If logging level is higher than the level of the message, the message is ignored.",
        returns = "()",
        type = "method"
      },
      WriteRaw = {
        args = "(const String message, bool error = false)",
        description = "Write raw output to the log.",
        returns = "()",
        type = "method"
      },
      level = {
        description = "int\nLogging level.",
        type = "value"
      },
      timeStamp = {
        description = "bool\nTimestamp log messages flag.",
        type = "value"
      },
      quiet = {
        description = "bool\nQuiet mode flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  LuaScriptInstance = {
    childs = {
      CreateObject = {
        args = "(const String scriptObjectType)",
        description = "(bool) CreateObject (const String scriptFileName, const String scriptObjectType)\nCreate script object. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetScriptFileName = {
        args = "(const String scriptFileName)",
        description = "Set script file name.",
        returns = "()",
        type = "method"
      },
      SetScriptObjectType = {
        args = "(const String scriptObjectType)",
        description = "Set script object type.",
        returns = "()",
        type = "method"
      },
      SubscribeToEvent = {
        args = "(const String eventName, const String functionName)",
        description = "() SubscribeToEvent (void* sender, const String eventName, const String functionName)",
        returns = "()",
        type = "method"
      },
      UnsubscribeFromEvent = {
        args = "(const String eventName)",
        description = "() UnsubscribeFromEvent (void* sender, const String eventName)",
        returns = "()",
        type = "method"
      },
      UnsubscribeFromAllEvents = {
        args = "()",
        returns = "()",
        type = "method"
      },
      UnsubscribeFromEvents = {
        args = "(void* sender)",
        returns = "()",
        type = "method"
      },
      GetScriptFileName = {
        args = "()",
        description = "Return script file name.",
        returns = "(const String)",
        type = "method"
      },
      GetScriptObjectType = {
        args = "()",
        description = "Return script object type.",
        returns = "(const String)",
        type = "method"
      },
      scriptFileName = {
        description = "const String\nScript file name.",
        type = "value"
      },
      scriptObjectType = {
        description = "const String\nScript object type.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Material = {
    childs = {
      new = {
        args = "()",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetNumTechniques = {
        args = "(unsigned num)",
        description = "Set number of techniques.",
        returns = "()",
        type = "method"
      },
      SetTechnique = {
        args = "(unsigned index, Technique* tech, unsigned qualityLevel = 0, float lodDistance = 0.0f)",
        description = "Set technique.",
        returns = "()",
        type = "method"
      },
      SetShaderParameter = {
        args = "(const String name, const Variant& value)",
        description = "Set shader parameter.",
        returns = "()",
        type = "method"
      },
      SetTexture = {
        args = "(TextureUnit unit, Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetUVTransform = {
        args = "(const Vector2& offset, float rotation, const Vector2& repeat)",
        description = "() SetUVTransform (const Vector2& offset, float rotation, float repeat)\nSet texture coordinate transform.",
        returns = "()",
        type = "method"
      },
      SetCullMode = {
        args = "(CullMode mode)",
        description = "Set culling mode.",
        returns = "()",
        type = "method"
      },
      SetShadowCullMode = {
        args = "(CullMode mode)",
        description = "Set culling mode for shadows.",
        returns = "()",
        type = "method"
      },
      SetDepthBias = {
        args = "(const BiasParameters& parameters)",
        description = "Set depth bias.",
        returns = "()",
        type = "method"
      },
      RemoveShaderParameter = {
        args = "(const String name)",
        description = "Remove shader parameter.",
        returns = "()",
        type = "method"
      },
      ReleaseShaders = {
        args = "()",
        description = "Reset all shader pointers.",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(const String cloneName = String::EMPTY)",
        description = "Clone material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      SortTechniques = {
        args = "()",
        description = "Ensure that material techniques are listed in correct order.",
        returns = "()",
        type = "method"
      },
      MarkForAuxView = {
        args = "(unsigned frameNumber)",
        description = "Mark material for auxiliary view rendering.",
        returns = "()",
        type = "method"
      },
      GetNumTechniques = {
        args = "()",
        description = "Return number of techniques.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTechnique = {
        args = "(unsigned index)",
        description = "Return technique by index.",
        returns = "(Technique*)",
        valuetype = "Technique",
        type = "method"
      },
      GetPass = {
        args = "(unsigned index, StringHash passType)",
        description = "(Pass*) GetPass (unsigned index, const String passType)\nReturn pass by technique index and pass type.",
        returns = "(Pass*)",
        valuetype = "Pass",
        type = "method"
      },
      GetTexture = {
        args = "(TextureUnit unit)",
        description = "Return texture by unit.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetCullMode = {
        args = "()",
        description = "Return normal culling mode.",
        returns = "(CullMode)",
        type = "method"
      },
      GetShadowCullMode = {
        args = "()",
        description = "Return culling mode for shadows.",
        returns = "(CullMode)",
        type = "method"
      },
      GetDepthBias = {
        args = "()",
        description = "Return depth bias.",
        returns = "(const BiasParameters&)",
        valuetype = "BiasParameters",
        type = "method"
      },
      GetAuxViewFrameNumber = {
        args = "()",
        description = "Return last auxiliary view rendered frame number.",
        returns = "(unsigned)",
        type = "method"
      },
      GetOcclusion = {
        args = "()",
        description = "Return whether should render occlusion.",
        returns = "(bool)",
        type = "method"
      },
      GetSpecular = {
        args = "()",
        description = "Return whether should render specular.",
        returns = "(bool)",
        type = "method"
      },
      cullMode = {
        description = "(Readonly) CullMode\nNormal culling mode.",
        type = "value"
      },
      shadowCullMode = {
        description = "(Readonly) CullMode\nCulling mode for shadow rendering.",
        type = "value"
      },
      auxViewFrameNumber = {
        description = "(Readonly) unsigned\nLast auxiliary view rendered frame number.",
        type = "value"
      },
      occlusion = {
        description = "(Readonly) bool\nRender occlusion flag.",
        type = "value"
      },
      specular = {
        description = "(Readonly) bool\nSpecular lighting flag.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Matrix3 = {
    childs = {
      new = {
        args = "()",
        description = "(Matrix3*) new (const Matrix3& matrix),\n(Matrix3*) new (float v00, float v01, float v02, float v10, float v11, float v12, float v20, float v21, float v22)",
        returns = "(Matrix3*)",
        valuetype = "Matrix3",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(const Vector3& scale)",
        description = "() SetScale (float scale)",
        returns = "()",
        type = "method"
      },
      Scale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Transpose = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      Scaled = {
        args = "(const Vector3& scale)",
        returns = "(Matrix3)",
        type = "method"
      },
      Equals = {
        args = "(const Matrix3& rhs)",
        returns = "(bool)",
        type = "method"
      },
      Inverse = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      m00 = {
        description = "float",
        type = "value"
      },
      m01 = {
        description = "float",
        type = "value"
      },
      m02 = {
        description = "float",
        type = "value"
      },
      m10 = {
        description = "float",
        type = "value"
      },
      m11 = {
        description = "float",
        type = "value"
      },
      m12 = {
        description = "float",
        type = "value"
      },
      m20 = {
        description = "float",
        type = "value"
      },
      m21 = {
        description = "float",
        type = "value"
      },
      m22 = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Matrix3",
        type = "value"
      },
      IDENTITY = {
        description = "const Matrix3",
        type = "value"
      },
    },
    type = "class"
  },
  Matrix3x4 = {
    childs = {
      new = {
        args = "()",
        description = "(Matrix3x4*) new (const Matrix3x4& matrix),\n(Matrix3x4*) new (const Matrix3& matrix),\n(Matrix3x4*) new (const Matrix4& matrix),\n(Matrix3x4*) new (float v00, float v01, float v02, float v03, float v10, float v11, float v12, float v13, float v20, float v21, float v22, float v23),\n(Matrix3x4*) new (const Vector3& translation, const Quaternion& rotation, float scale),\n(Matrix3x4*) new (const Vector3& translation, const Quaternion& rotation, const Vector3& scale)",
        returns = "(Matrix3x4*)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetTranslation = {
        args = "(const Vector3& translation)",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Matrix3& rotation)",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(const Vector3& scale)",
        description = "() SetScale (float scale)",
        returns = "()",
        type = "method"
      },
      ToMatrix3 = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      ToMatrix4 = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      RotationMatrix = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      Translation = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Rotation = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      Scale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Equals = {
        args = "(const Matrix3x4& rhs)",
        returns = "(bool)",
        type = "method"
      },
      Decompose = {
        args = "(Vector3& translation, Quaternion& rotation, Vector3& scale)",
        returns = "()",
        type = "method"
      },
      Inverse = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      m00 = {
        description = "float",
        type = "value"
      },
      m01 = {
        description = "float",
        type = "value"
      },
      m02 = {
        description = "float",
        type = "value"
      },
      m03 = {
        description = "float",
        type = "value"
      },
      m10 = {
        description = "float",
        type = "value"
      },
      m11 = {
        description = "float",
        type = "value"
      },
      m12 = {
        description = "float",
        type = "value"
      },
      m13 = {
        description = "float",
        type = "value"
      },
      m20 = {
        description = "float",
        type = "value"
      },
      m21 = {
        description = "float",
        type = "value"
      },
      m22 = {
        description = "float",
        type = "value"
      },
      m23 = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Matrix3x4",
        type = "value"
      },
      IDENTITY = {
        description = "const Matrix3x4",
        type = "value"
      },
    },
    type = "class"
  },
  Matrix4 = {
    childs = {
      new = {
        args = "()",
        description = "(Matrix4*) new (const Matrix4& matrix),\n(Matrix4*) new (const Matrix3& matrix),\n(Matrix4*) new (float v00, float v01, float v02, float v03, float v10, float v11, float v12, float v13, float v20, float v21, float v22, float v23, float v30, float v31, float v32, float v33)",
        returns = "(Matrix4*)",
        valuetype = "Matrix4",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetTranslation = {
        args = "(const Vector3& translation)",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Matrix3& rotation)",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(const Vector3& scale)",
        description = "() SetScale (float scale)",
        returns = "()",
        type = "method"
      },
      ToMatrix3 = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      RotationMatrix = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      Translation = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Rotation = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      Scale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Transpose = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      Equals = {
        args = "(const Matrix4& rhs)",
        returns = "(bool)",
        type = "method"
      },
      Decompose = {
        args = "(Vector3& translation, Quaternion& rotation, Vector3& scale)",
        returns = "()",
        type = "method"
      },
      Inverse = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      m00 = {
        description = "float",
        type = "value"
      },
      m01 = {
        description = "float",
        type = "value"
      },
      m02 = {
        description = "float",
        type = "value"
      },
      m03 = {
        description = "float",
        type = "value"
      },
      m10 = {
        description = "float",
        type = "value"
      },
      m11 = {
        description = "float",
        type = "value"
      },
      m12 = {
        description = "float",
        type = "value"
      },
      m13 = {
        description = "float",
        type = "value"
      },
      m20 = {
        description = "float",
        type = "value"
      },
      m21 = {
        description = "float",
        type = "value"
      },
      m22 = {
        description = "float",
        type = "value"
      },
      m23 = {
        description = "float",
        type = "value"
      },
      m30 = {
        description = "float",
        type = "value"
      },
      m31 = {
        description = "float",
        type = "value"
      },
      m32 = {
        description = "float",
        type = "value"
      },
      m33 = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Matrix4",
        type = "value"
      },
      IDENTITY = {
        description = "const Matrix4",
        type = "value"
      },
    },
    type = "class"
  },
  Menu = {
    childs = {
      new = {
        args = "()",
        returns = "(Menu*)",
        valuetype = "Menu",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetPopup = {
        args = "(UIElement* element)",
        description = "Set popup element to show on selection.",
        returns = "()",
        type = "method"
      },
      SetPopupOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPopupOffset (int x, int y)\nSet popup element offset.",
        returns = "()",
        type = "method"
      },
      ShowPopup = {
        args = "(bool enable)",
        description = "Force the popup to show or hide.",
        returns = "()",
        type = "method"
      },
      SetAccelerator = {
        args = "(int key, int qualifiers)",
        description = "Set accelerator key (set zero key code to disable.)",
        returns = "()",
        type = "method"
      },
      GetPopup = {
        args = "()",
        description = "Return popup element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetPopupOffset = {
        args = "()",
        description = "Return popup element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetShowPopup = {
        args = "()",
        description = "Return whether popup is open.",
        returns = "(bool)",
        type = "method"
      },
      GetAcceleratorKey = {
        args = "()",
        description = "Return accelerator key code, 0 if disabled.",
        returns = "(int)",
        type = "method"
      },
      GetAcceleratorQualifiers = {
        args = "()",
        description = "Return accelerator qualifiers.",
        returns = "(int)",
        type = "method"
      },
      popup = {
        valuetype = "UIElement",
        description = "UIElement*\nPopup element.",
        type = "value"
      },
      popupOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPopup element offset.",
        type = "value"
      },
      showPopup = {
        description = "bool\nShow popup flag.",
        type = "value"
      },
      acceleratorKey = {
        description = "(Readonly) int\nAccelerator key code.",
        type = "value"
      },
      acceleratorQualifiers = {
        description = "(Readonly) int\nAccelerator qualifiers.",
        type = "value"
      },
      SetPressedOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedOffset (int x, int y)\nSet offset to image rectangle used when pressed.",
        returns = "()",
        type = "method"
      },
      SetPressedChildOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedChildOffset (int x, int y)\nSet offset of child elements when pressed.",
        returns = "()",
        type = "method"
      },
      SetRepeat = {
        args = "(float delay, float rate)",
        description = "Set repeat properties. Rate 0 (default) disables repeat.",
        returns = "()",
        type = "method"
      },
      SetRepeatDelay = {
        args = "(float delay)",
        description = "Set repeat delay.",
        returns = "()",
        type = "method"
      },
      SetRepeatRate = {
        args = "(float rate)",
        description = "Set repeat rate.",
        returns = "()",
        type = "method"
      },
      GetPressedOffset = {
        args = "()",
        description = "Return pressed image offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPressedChildOffset = {
        args = "()",
        description = "Return offset of child elements when pressed.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetRepeatDelay = {
        args = "()",
        description = "Return repeat delay.",
        returns = "(float)",
        type = "method"
      },
      GetRepeatRate = {
        args = "()",
        description = "Return repeat rate.",
        returns = "(float)",
        type = "method"
      },
      IsPressed = {
        args = "()",
        description = "Return whether is currently pressed.",
        returns = "(bool)",
        type = "method"
      },
      pressedOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed image offset.",
        type = "value"
      },
      pressedChildOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed label offset.",
        type = "value"
      },
      repeatDelay = {
        description = "float\nRepeat delay.",
        type = "value"
      },
      repeatRate = {
        description = "float\nRepeat rate.",
        type = "value"
      },
      pressed = {
        description = "(Readonly) bool\nCurrent pressed state.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  MessageBox = {
    childs = {
      new = {
        args = "(const String messageString = String::EMPTY, const String titleString = String::EMPTY, XMLFile* layoutFile = 0, XMLFile* styleFile = 0)",
        returns = "(MessageBox*)",
        valuetype = "MessageBox",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetTitle = {
        args = "(const String text)",
        description = "Set title text. No-ops if there is no title text element.",
        returns = "()",
        type = "method"
      },
      SetMessage = {
        args = "(const String text)",
        description = "Set message text. No-ops if there is no message text element.",
        returns = "()",
        type = "method"
      },
      GetTitle = {
        args = "()",
        description = "Return title text. Return empty string if there is no title text element.",
        returns = "(const String)",
        type = "method"
      },
      GetMessage = {
        args = "()",
        description = "Return message text. Return empty string if there is no message text element.",
        returns = "(const String)",
        type = "method"
      },
      GetWindow = {
        args = "()",
        description = "Return dialog window.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      title = {
        description = "String",
        type = "value"
      },
      message = {
        description = "String",
        type = "value"
      },
      window = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*\nUI element containing the whole UI layout. Typically it is a Window element type.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Model = {
    childs = {
      GetBoundingBox = {
        args = "()",
        description = "Return bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetSkeleton = {
        args = "()",
        description = "Return skeleton.",
        returns = "(Skeleton&)",
        valuetype = "Skeleton",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumGeometryLodLevels = {
        args = "(unsigned index)",
        description = "Return number of LOD levels in geometry.",
        returns = "(unsigned)",
        type = "method"
      },
      GetGeometry = {
        args = "(unsigned index, unsigned lodLevel)",
        description = "Return geometry by index and LOD level. The LOD level is clamped if out of range.",
        returns = "(Geometry*)",
        valuetype = "Geometry",
        type = "method"
      },
      GetNumMorphs = {
        args = "()",
        description = "Return number of vertex morphs.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMorph = {
        args = "(const String name)",
        description = "(const ModelMorph*) GetMorph (StringHash nameHash),\n(const ModelMorph*) GetMorph (unsigned index)\nReturn vertex morph by name.",
        returns = "(const ModelMorph*)",
        valuetype = "ModelMorph",
        type = "method"
      },
      GetMorphRangeStart = {
        args = "(unsigned bufferIndex)",
        description = "Return vertex buffer morph range start.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMorphRangeCount = {
        args = "(unsigned bufferIndex)",
        description = "Return vertex buffer morph range vertex count.",
        returns = "(unsigned)",
        type = "method"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&\nBounding box.",
        type = "value"
      },
      skeleton = {
        description = "(Readonly) Skeleton\nSkeleton.",
        type = "value"
      },
      numGeometries = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numMorphs = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Navigable = {
    childs = {
      SetRecursive = {
        args = "(bool enable)",
        description = "Set whether geometry is automatically collected from child nodes. Default true.",
        returns = "()",
        type = "method"
      },
      IsRecursive = {
        args = "()",
        description = "Return whether geometry is automatically collected from child nodes.",
        returns = "(bool)",
        type = "method"
      },
      recursive = {
        description = "bool\nRecursive flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  NavigationGeometryInfo = {
    childs = {
      component = {
        valuetype = "Component",
        description = "Component*",
        type = "value"
      },
      lodLevel = {
        description = "unsigned",
        type = "value"
      },
      transform = {
        description = "Matrix3x4",
        type = "value"
      },
      boundingBox = {
        description = "BoundingBox",
        type = "value"
      },
    },
    type = "class"
  },
  NavigationMesh = {
    childs = {
      SetTileSize = {
        args = "(int size)",
        description = "Set tile size.",
        returns = "()",
        type = "method"
      },
      SetCellSize = {
        args = "(float size)",
        description = "Set cell size.",
        returns = "()",
        type = "method"
      },
      SetCellHeight = {
        args = "(float height)",
        description = "Set cell height.",
        returns = "()",
        type = "method"
      },
      SetAgentHeight = {
        args = "(float height)",
        description = "Set navigation agent height.",
        returns = "()",
        type = "method"
      },
      SetAgentRadius = {
        args = "(float radius)",
        description = "Set navigation agent radius.",
        returns = "()",
        type = "method"
      },
      SetAgentMaxClimb = {
        args = "(float maxClimb)",
        description = "Set navigation agent max vertical climb.",
        returns = "()",
        type = "method"
      },
      SetAgentMaxSlope = {
        args = "(float maxSlope)",
        description = "Set navigation agent max slope.",
        returns = "()",
        type = "method"
      },
      SetRegionMinSize = {
        args = "(float size)",
        description = "Set region minimum size.",
        returns = "()",
        type = "method"
      },
      SetRegionMergeSize = {
        args = "(float size)",
        description = "Set region merge size.",
        returns = "()",
        type = "method"
      },
      SetEdgeMaxLength = {
        args = "(float length)",
        description = "Set edge max length.",
        returns = "()",
        type = "method"
      },
      SetEdgeMaxError = {
        args = "(float error)",
        description = "Set edge max error.",
        returns = "()",
        type = "method"
      },
      SetDetailSampleDistance = {
        args = "(float distance)",
        description = "Set detail sampling distance.",
        returns = "()",
        type = "method"
      },
      SetDetailSampleMaxError = {
        args = "(float error)",
        description = "Set detail sampling maximum error.",
        returns = "()",
        type = "method"
      },
      SetPadding = {
        args = "(const Vector3& padding)",
        description = "Set padding of the navigation mesh bounding box. Having enough padding allows to add geometry on the extremities of the navigation mesh when doing partial rebuilds.",
        returns = "()",
        type = "method"
      },
      Build = {
        args = "()",
        description = "(bool) Build (const BoundingBox& boundingBox)\nRebuild the navigation mesh. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FindNearestPoint = {
        args = "(const Vector3& point)",
        description = "(Vector3) FindNearestPoint (const Vector3& point, const Vector3& extents)\nFind the nearest point on the navigation mesh to a given point. Extens specifies how far out from the specified point to check along each axis.",
        returns = "(Vector3)",
        type = "method"
      },
      MoveAlongSurface = {
        args = "(const Vector3& start, const Vector3& end)",
        description = "(Vector3) MoveAlongSurface (const Vector3& start, const Vector3& end, const Vector3& extents, int maxVisited = 3)\nTry to move along the surface from one point to another",
        returns = "(Vector3)",
        type = "method"
      },
      FindPath = {
        args = "(const Vector3& start, const Vector3& end)",
        description = "(const PODVector<Vector3>&) FindPath (const Vector3& start, const Vector3& end, const Vector3& extents)",
        returns = "(const PODVector<Vector3>&)",
        valuetype = "PODVector<Vector3>",
        type = "method"
      },
      GetRandomPoint = {
        args = "()",
        description = "Return a random point on the navigation mesh.",
        returns = "(Vector3)",
        type = "method"
      },
      GetRandomPointInCircle = {
        args = "(const Vector3& center, float radius)",
        description = "(Vector3) GetRandomPointInCircle (const Vector3& center, float radius, const Vector3& extents)\nReturn a random point on the navigation mesh within a circle. The circle radius is only a guideline and in practice the returned point may be further away.",
        returns = "(Vector3)",
        type = "method"
      },
      GetDistanceToWall = {
        args = "(const Vector3& point, float radius)",
        description = "(float) GetDistanceToWall (const Vector3& point, float radius, const Vector3& extents)\nReturn distance to wall from a point. Maximum search radius must be specified.",
        returns = "(float)",
        type = "method"
      },
      Raycast = {
        args = "(const Vector3& start, const Vector3& end)",
        description = "(Vector3) Raycast (const Vector3& start, const Vector3& end, const Vector3& extents)\nPerform a walkability raycast on the navigation mesh between start and end and return the point where a wall was hit, or the end point if no walls.",
        returns = "(Vector3)",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Add debug geometry to the debug renderer.",
        returns = "()",
        type = "method"
      },
      GetTileSize = {
        args = "()",
        description = "Return tile size.",
        returns = "(int)",
        type = "method"
      },
      GetCellSize = {
        args = "()",
        description = "Return cell size.",
        returns = "(float)",
        type = "method"
      },
      GetCellHeight = {
        args = "()",
        description = "Return cell height.",
        returns = "(float)",
        type = "method"
      },
      GetAgentHeight = {
        args = "()",
        description = "Return navigation agent height.",
        returns = "(float)",
        type = "method"
      },
      GetAgentRadius = {
        args = "()",
        description = "Return navigation agent radius.",
        returns = "(float)",
        type = "method"
      },
      GetAgentMaxClimb = {
        args = "()",
        description = "Return navigation agent max vertical climb.",
        returns = "(float)",
        type = "method"
      },
      GetAgentMaxSlope = {
        args = "()",
        description = "Return navigation agent max slope.",
        returns = "(float)",
        type = "method"
      },
      GetRegionMinSize = {
        args = "()",
        description = "Return region minimum size.",
        returns = "(float)",
        type = "method"
      },
      GetRegionMergeSize = {
        args = "()",
        description = "Return region merge size.",
        returns = "(float)",
        type = "method"
      },
      GetEdgeMaxLength = {
        args = "()",
        description = "Return edge max length.",
        returns = "(float)",
        type = "method"
      },
      GetEdgeMaxError = {
        args = "()",
        description = "Return edge max error.",
        returns = "(float)",
        type = "method"
      },
      GetDetailSampleDistance = {
        args = "()",
        description = "Return detail sampling distance.",
        returns = "(float)",
        type = "method"
      },
      GetDetailSampleMaxError = {
        args = "()",
        description = "Return detail sampling maximum error.",
        returns = "(float)",
        type = "method"
      },
      GetPadding = {
        args = "()",
        description = "Return navigation mesh bounding box padding.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      IsInitialized = {
        args = "()",
        description = "Return whether has been initialized with valid navigation data.",
        returns = "(bool)",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box of the navigation mesh.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world space bounding box of the navigation mesh.",
        returns = "(BoundingBox)",
        type = "method"
      },
      GetNumTiles = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      tileSize = {
        description = "int\nTile size.",
        type = "value"
      },
      cellSize = {
        description = "float\nCell size.",
        type = "value"
      },
      cellHeight = {
        description = "float\nCell height.",
        type = "value"
      },
      agentHeight = {
        description = "float\nNavigation agent height.",
        type = "value"
      },
      agentRadius = {
        description = "float\nNavigation agent radius.",
        type = "value"
      },
      agentMaxClimb = {
        description = "float\nNavigation agent max vertical climb.",
        type = "value"
      },
      agentMaxSlope = {
        description = "float\nNavigation agent max slope.",
        type = "value"
      },
      regionMinSize = {
        description = "float\nRegion minimum size.",
        type = "value"
      },
      regionMergeSize = {
        description = "float\nRegion merge size.",
        type = "value"
      },
      edgeMaxLength = {
        description = "float\nEdge max length.",
        type = "value"
      },
      edgeMaxError = {
        description = "float\nEdge max error.",
        type = "value"
      },
      detailSampleDistance = {
        description = "float\nDetail sampling distance.",
        type = "value"
      },
      detailSampleMaxError = {
        description = "float\nDetail sampling maximum error.",
        type = "value"
      },
      padding = {
        valuetype = "Vector3",
        description = "Vector3&\nBounding box padding.",
        type = "value"
      },
      initialized = {
        description = "(Readonly) bool",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&\nWhole navigation mesh bounding box.",
        type = "value"
      },
      worldBoundingBox = {
        description = "(Readonly) BoundingBox",
        type = "value"
      },
      numTiles = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Network = {
    childs = {
      Connect = {
        args = "(const String address, short port, Scene* scene)",
        description = "(bool) Connect (const String address, short port, Scene* scene, const VariantMap& identity)",
        returns = "(bool)",
        type = "method"
      },
      Disconnect = {
        args = "(int waitMSec = 0)",
        description = "Disconnect the connection to the server. If wait time is non-zero, will block while waiting for disconnect to finish.",
        returns = "()",
        type = "method"
      },
      StartServer = {
        args = "(short port)",
        returns = "(bool)",
        type = "method"
      },
      StopServer = {
        args = "()",
        description = "Stop the server.",
        returns = "()",
        type = "method"
      },
      BroadcastMessage = {
        args = "(int msgID, bool reliable, bool inOrder, const VectorBuffer& msg, unsigned contentID = 0)",
        description = "Broadcast a message with content ID to all client connections.",
        returns = "()",
        type = "method"
      },
      BroadcastRemoteEvent = {
        args = "(StringHash eventType, bool inOrder)",
        description = "() BroadcastRemoteEvent (StringHash eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (const String eventType, bool inOrder),\n() BroadcastRemoteEvent (const String eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (Scene* scene, StringHash eventType, bool inOrder),\n() BroadcastRemoteEvent (Scene* scene, StringHash eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (Scene* scene, const String eventType, bool inOrder),\n() BroadcastRemoteEvent (Scene* scene, const String eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (Node* node, StringHash eventType, bool inOrder),\n() BroadcastRemoteEvent (Node* node, StringHash eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (Node* node, const String eventType, bool inOrder),\n() BroadcastRemoteEvent (Node* node, const String eventType, bool inOrder, const VariantMap& eventData)\nBroadcast a remote event to all client connections.",
        returns = "()",
        type = "method"
      },
      SetUpdateFps = {
        args = "(int fps)",
        description = "Set network update FPS.",
        returns = "()",
        type = "method"
      },
      RegisterRemoteEvent = {
        args = "(StringHash eventType)",
        description = "() RegisterRemoteEvent (const String eventType)\nRegister a remote event as allowed to be sent and received. If no events are registered, all are allowed.",
        returns = "()",
        type = "method"
      },
      UnregisterRemoteEvent = {
        args = "(StringHash eventType)",
        description = "() UnregisterRemoteEvent (const String eventType)\nUnregister a remote event as allowed to be sent and received.",
        returns = "()",
        type = "method"
      },
      UnregisterAllRemoteEvents = {
        args = "()",
        description = "Unregister all remote events. This results in all being allowed.",
        returns = "()",
        type = "method"
      },
      SetPackageCacheDir = {
        args = "(const String path)",
        description = "Set the package download cache directory.",
        returns = "()",
        type = "method"
      },
      MakeHttpRequest = {
        args = "(const String url, const String verb = String::EMPTY)",
        description = "(HttpRequest*) MakeHttpRequest (const String url, const String verb, const Vector<String>& headers, const String postData = String::EMPTY)",
        returns = "(HttpRequest*)",
        valuetype = "HttpRequest",
        type = "method"
      },
      GetUpdateFps = {
        args = "()",
        description = "Return network update FPS.",
        returns = "(int)",
        type = "method"
      },
      GetServerConnection = {
        args = "()",
        description = "Return the connection to the server. Null if not connected.",
        returns = "(Connection*)",
        valuetype = "Connection",
        type = "method"
      },
      IsServerRunning = {
        args = "()",
        description = "Return whether the server is running.",
        returns = "(bool)",
        type = "method"
      },
      CheckRemoteEvent = {
        args = "(StringHash eventType)",
        description = "Return whether a remote event is allowed to be sent and received. If no events are registered, all are allowed.",
        returns = "(bool)",
        type = "method"
      },
      GetPackageCacheDir = {
        args = "()",
        description = "Return the package download cache directory.",
        returns = "(const String)",
        type = "method"
      },
      updateFps = {
        description = "int\nUpdate FPS.",
        type = "value"
      },
      serverConnection = {
        valuetype = "Connection",
        description = "(Readonly) Connection*\nClient's server connection.",
        type = "value"
      },
      serverRunning = {
        description = "(Readonly) bool",
        type = "value"
      },
      packageCacheDir = {
        description = "String\nPackage cache directory.",
        type = "value"
      },
    },
    type = "class"
  },
  NetworkPriority = {
    childs = {
      SetBasePriority = {
        args = "(float priority)",
        description = "Set base priority. Default 100 (send updates at full frequency.)",
        returns = "()",
        type = "method"
      },
      SetDistanceFactor = {
        args = "(float factor)",
        description = "Set priority reduction distance factor. Default 0 (no effect.)",
        returns = "()",
        type = "method"
      },
      SetMinPriority = {
        args = "(float priority)",
        description = "Set minimum priority. Default 0 (no updates when far away enough.)",
        returns = "()",
        type = "method"
      },
      SetAlwaysUpdateOwner = {
        args = "(bool enable)",
        description = "Set whether updates to owner should be sent always at full rate. Default true.",
        returns = "()",
        type = "method"
      },
      GetBasePriority = {
        args = "()",
        description = "Return base priority.",
        returns = "(float)",
        type = "method"
      },
      GetDistanceFactor = {
        args = "()",
        description = "Return priority reduction distance factor.",
        returns = "(float)",
        type = "method"
      },
      GetMinPriority = {
        args = "()",
        description = "Return minimum priority.",
        returns = "(float)",
        type = "method"
      },
      GetAlwaysUpdateOwner = {
        args = "()",
        description = "Return whether updates to owner should be sent always at full rate.",
        returns = "(bool)",
        type = "method"
      },
      CheckUpdate = {
        args = "(float distance, float accumulator)",
        description = "Increment and check priority accumulator. Return true if should update. Called by Connection.",
        returns = "(bool)",
        type = "method"
      },
      basePriority = {
        description = "float\nBase priority.",
        type = "value"
      },
      distanceFactor = {
        description = "float\nPriority reduction distance factor.",
        type = "value"
      },
      minPriority = {
        description = "float\nMinimum priority.",
        type = "value"
      },
      alwaysUpdateOwner = {
        description = "bool\nUpdate owner at full rate flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Node = {
    childs = {
      new = {
        args = "()",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SaveXML = {
        args = "(File* dest)",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name of the scene node. Names are not required to be unique.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set position in parent space. If the scene node is on the root level (is child of the scene itself), this is same as world space.",
        returns = "()",
        type = "method"
      },
      SetPositionXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set rotation in parent space.",
        returns = "()",
        type = "method"
      },
      SetRotationXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetDirection = {
        args = "(const Vector3& direction)",
        description = "Set forward direction in parent space. Positive Z axis equals identity rotation.",
        returns = "()",
        type = "method"
      },
      SetDirectionXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(float scale)",
        description = "() SetScale (const Vector3& scale)\nSet uniform scale in parent space.",
        returns = "()",
        type = "method"
      },
      SetScaleXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "() SetTransform (const Vector3& position, const Quaternion& rotation, float scale),\n() SetTransform (const Vector3& position, const Quaternion& rotation, const Vector3& scale)\nSet both position and rotation in parent space as an atomic operation. This is faster than setting position and rotation separately.",
        returns = "()",
        type = "method"
      },
      SetWorldPosition = {
        args = "(const Vector3& position)",
        description = "Set position in world space.",
        returns = "()",
        type = "method"
      },
      SetWorldPositionXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetWorldRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set rotation in world space.",
        returns = "()",
        type = "method"
      },
      SetWorldRotationXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetWorldDirection = {
        args = "(const Vector3& direction)",
        description = "Set forward direction in world space.",
        returns = "()",
        type = "method"
      },
      SetWorldDirectionXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetWorldScale = {
        args = "(float scale)",
        description = "() SetWorldScale (const Vector3& scale)\nSet uniform scale in world space.",
        returns = "()",
        type = "method"
      },
      SetWorldScaleXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetWorldTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "() SetWorldTransform (const Vector3& position, const Quaternion& rotation, float scale),\n() SetWorldTransform (const Vector3& position, const Quaternion& rotation, const Vector3& scale)\nSet both position and rotation in world space as an atomic operation.",
        returns = "()",
        type = "method"
      },
      Translate = {
        args = "(const Vector3& delta)",
        description = "Move the scene node in parent space, which is the same as world space if the scene node is on the root level.",
        returns = "()",
        type = "method"
      },
      TranslateXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      TranslateRelative = {
        args = "(const Vector3& delta)",
        description = "Move the scene node in parent space relative to its current rotation.",
        returns = "()",
        type = "method"
      },
      TranslateRelativeXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      Rotate = {
        args = "(const Quaternion& delta, bool fixedAxis = false)",
        description = "Rotate the scene node in parent space either relative to its current rotation axes, or a fixed axis.",
        returns = "()",
        type = "method"
      },
      RotateXYZ = {
        args = "(float x, float y, float z, bool fixedAxis = false)",
        returns = "()",
        type = "method"
      },
      Pitch = {
        args = "(float angle, bool fixedAxis = false)",
        description = "Rotate around the X axis.",
        returns = "()",
        type = "method"
      },
      Yaw = {
        args = "(float angle, bool fixedAxis = false)",
        description = "Rotate around the Y axis.",
        returns = "()",
        type = "method"
      },
      Roll = {
        args = "(float angle, bool fixedAxis = false)",
        description = "Rotate around the Z axis.",
        returns = "()",
        type = "method"
      },
      LookAt = {
        args = "(const Vector3& target)",
        description = "() LookAt (const Vector3& target, const Vector3& upAxis)\nLook at a target world position.",
        returns = "()",
        type = "method"
      },
      LookAtXYZ = {
        args = "(float x, float y, float z, float upX = 0.0f, float upY = 1.0f, float upZ = 0.0f)",
        returns = "()",
        type = "method"
      },
      Scale = {
        args = "(float scale)",
        description = "() Scale (const Vector3& scale)\nModify scale in parent space uniformly.",
        returns = "()",
        type = "method"
      },
      ScaleXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "() SetEnabled (bool enable, bool recursive)\nSet enabled/disabled state without recursion. Components in a disabled node become effectively disabled regardless of their own enable/disable state.",
        returns = "()",
        type = "method"
      },
      SetOwner = {
        args = "(Connection* owner)",
        description = "Set owner connection for networking.",
        returns = "()",
        type = "method"
      },
      MarkDirty = {
        args = "()",
        description = "Mark node and child nodes to need world transform recalculation. Notify listener components.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0)",
        description = "(Node*) CreateChild (unsigned id, CreateMode mode)\nCreate a child scene node (with specified ID if provided).",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      AddChild = {
        args = "(Node* node)",
        description = "Add a child scene node.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(Node* node)",
        description = "Remove a child scene node.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child scene nodes.",
        returns = "()",
        type = "method"
      },
      RemoveChildren = {
        args = "(bool removeReplicated, bool removeLocal, bool recursive)",
        description = "Remove child scene nodes that match criteria.",
        returns = "()",
        type = "method"
      },
      RemoveComponent = {
        args = "(Component* component)",
        description = "() RemoveComponent (ShortStringHash type),\n() RemoveComponent (const String type)\nRemove a component from this node.",
        returns = "()",
        type = "method"
      },
      RemoveAllComponents = {
        args = "()",
        description = "Remove all components from this node.",
        returns = "()",
        type = "method"
      },
      RemoveComponents = {
        args = "(bool removeReplicated, bool removeLocal)",
        description = "Remove components that match criteria.",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(CreateMode mode = REPLICATED)",
        description = "Clone scene node, components and child nodes. Return the clone.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      SetParent = {
        args = "(Node* parent)",
        description = "Set parent scene node. Retains the world transform.",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      AddListener = {
        args = "(Component* component)",
        description = "Add listener component that is notified of node being dirtied. Can either be in the same node or another.",
        returns = "()",
        type = "method"
      },
      RemoveListener = {
        args = "(Component* component)",
        description = "Remove listener component.",
        returns = "()",
        type = "method"
      },
      CreateComponent = {
        args = "(const String type, CreateMode mode = REPLICATED, unsigned id = 0)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      CreateScriptObject = {
        args = "(const String scriptObjectType)",
        description = "(int) CreateScriptObject (const String fileName, const String scriptObjectType)",
        returns = "(int)",
        type = "method"
      },
      GetScriptObject = {
        args = "()",
        description = "(int) GetScriptObject (const String scriptObjectType)",
        returns = "(int)",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return scene.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled. Disables nodes effectively disable all their components.",
        returns = "(bool)",
        type = "method"
      },
      GetOwner = {
        args = "()",
        description = "Return owner connection in networking.",
        returns = "(Connection*)",
        valuetype = "Connection",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position in parent space.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetPositionXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return rotation in parent space.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetRotationXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetRotationWXYZ = {
        args = "(float w = 0.0f, float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetDirection = {
        args = "()",
        description = "Return forward direction in parent space. Positive Z axis equals identity rotation.",
        returns = "(Vector3)",
        type = "method"
      },
      GetDirectionXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetUp = {
        args = "()",
        description = "Return up direction in parent space. Positive Y axis equals identity rotation.",
        returns = "(Vector3)",
        type = "method"
      },
      GetUpXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetRight = {
        args = "()",
        description = "Return right direction in parent space. Positive X axis equals identity rotation.",
        returns = "(Vector3)",
        type = "method"
      },
      GetRightXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetScale = {
        args = "()",
        description = "Return scale in parent space.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetScaleXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetTransform = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      GetWorldPosition = {
        args = "()",
        description = "Return position in world space.",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldPositionXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldRotation = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      GetWorldRotationXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldRotationWXYZ = {
        args = "(float w = 0.0f, float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldDirection = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldDirectionXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldUp = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldUpXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldRight = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldRightXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldScale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldScaleXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldTransform = {
        args = "()",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      LocalToWorld = {
        args = "(const Vector3& position)",
        description = "(Vector3) LocalToWorld (const Vector4& vector)",
        returns = "(Vector3)",
        type = "method"
      },
      WorldToLocal = {
        args = "(const Vector3& position)",
        description = "(Vector3) WorldToLocal (const Vector4& vector)",
        returns = "(Vector3)",
        type = "method"
      },
      IsDirty = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(Node*) GetChild (StringHash nameHash, bool recursive = false),\n(Node*) GetChild (unsigned index)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetNumComponents = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumNetworkComponents = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      HasComponent = {
        args = "(ShortStringHash type)",
        description = "(bool) HasComponent (const String type)",
        returns = "(bool)",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      GetComponent = {
        args = "(const String type)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetID = {
        args = "(unsigned id)",
        returns = "()",
        type = "method"
      },
      SetScene = {
        args = "(Scene* scene)",
        returns = "()",
        type = "method"
      },
      ResetScene = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      LoadXML = {
        args = "(const XMLElement& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      AddComponent = {
        args = "(Component* component, unsigned id, CreateMode mode)",
        returns = "()",
        type = "method"
      },
      ID = {
        description = "unsigned",
        type = "value"
      },
      name = {
        description = "String",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      parent = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "Scene*",
        type = "value"
      },
      enabled = {
        description = "bool",
        type = "value"
      },
      owner = {
        valuetype = "Connection",
        description = "Connection*",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      rotation = {
        valuetype = "Quaternion",
        description = "Quaternion&",
        type = "value"
      },
      direction = {
        description = "Vector3",
        type = "value"
      },
      up = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      right = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      scale = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      transform = {
        description = "(Readonly) Matrix3x4",
        type = "value"
      },
      worldPosition = {
        description = "Vector3",
        type = "value"
      },
      worldRotation = {
        description = "Quaternion",
        type = "value"
      },
      worldDirection = {
        description = "Vector3",
        type = "value"
      },
      worldUp = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      worldRight = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      worldScale = {
        description = "Vector3",
        type = "value"
      },
      worldTransform = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&",
        type = "value"
      },
      dirty = {
        description = "(Readonly) bool",
        type = "value"
      },
      numComponents = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numNetworkComponents = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Object = {
    childs = {
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Octree = {
    childs = {
      SetSize = {
        args = "(const BoundingBox& box, unsigned numLevels)",
        description = "Set size and maximum subdivision levels. If octree is not empty, drawable objects will be temporarily moved to the root.",
        returns = "()",
        type = "method"
      },
      Update = {
        args = "(const FrameInfo& frame)",
        description = "Update and reinsert drawable objects.",
        returns = "()",
        type = "method"
      },
      AddManualDrawable = {
        args = "(Drawable* drawable)",
        description = "Add a drawable manually.",
        returns = "()",
        type = "method"
      },
      RemoveManualDrawable = {
        args = "(Drawable* drawable)",
        description = "Remove a manually added drawable.",
        returns = "()",
        type = "method"
      },
      GetDrawables = {
        args = "(const Vector3& point, char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK)",
        description = "(const PODVector<OctreeQueryResult>&) GetDrawables (const BoundingBox& box, char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK),\n(const PODVector<OctreeQueryResult>&) GetDrawables (const Frustum& frustum, char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK),\n(const PODVector<OctreeQueryResult>&) GetDrawables (const Sphere& sphere, char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK)",
        returns = "(const PODVector<OctreeQueryResult>&)",
        valuetype = "PODVector<OctreeQueryResult>",
        type = "method"
      },
      Raycast = {
        args = "(const Ray& ray, RayQueryLevel level, float maxDistance, char drawableFlags)",
        returns = "(const PODVector<RayQueryResult>&)",
        valuetype = "PODVector<RayQueryResult>",
        type = "method"
      },
      RaycastSingle = {
        args = "(const Ray& ray, RayQueryLevel level, float maxDistance, char drawableFlags)",
        returns = "(RayQueryResult)",
        type = "method"
      },
      GetNumLevels = {
        args = "()",
        description = "Return subdivision levels.",
        returns = "(unsigned)",
        type = "method"
      },
      QueueUpdate = {
        args = "(Drawable* drawable)",
        description = "Mark drawable object as requiring an update and a reinsertion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      numLevels = {
        description = "(Readonly) unsigned\nSubdivision level.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  OctreeQueryResult = {
    childs = {
      new = {
        args = "()",
        returns = "(OctreeQueryResult*)",
        valuetype = "OctreeQueryResult",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      drawable = {
        valuetype = "Drawable",
        description = "Drawable*",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
    },
    type = "class"
  },
  OffMeshConnection = {
    childs = {
      SetEndPoint = {
        args = "(Node* node)",
        description = "Set endpoint node.",
        returns = "()",
        type = "method"
      },
      SetRadius = {
        args = "(float radius)",
        description = "Set radius.",
        returns = "()",
        type = "method"
      },
      SetBidirectional = {
        args = "(bool enabled)",
        description = "Set bidirectional flag. Default true.",
        returns = "()",
        type = "method"
      },
      GetEndPoint = {
        args = "()",
        description = "Return endpoint node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetRadius = {
        args = "()",
        description = "Return radius.",
        returns = "(float)",
        type = "method"
      },
      IsBidirectional = {
        args = "()",
        description = "Return whether is bidirectional.",
        returns = "(bool)",
        type = "method"
      },
      endPoint = {
        valuetype = "Node",
        description = "Node*\nEndpoint node.",
        type = "value"
      },
      radius = {
        description = "float\nRadius.",
        type = "value"
      },
      bidirectional = {
        description = "bool\nBidirectional flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  PackageEntry = {
    childs = {
      offset = {
        description = "unsigned",
        type = "value"
      },
      size = {
        description = "unsigned",
        type = "value"
      },
      checksum = {
        description = "unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  PackageFile = {
    childs = {
      new = {
        args = "()",
        description = "(PackageFile*) new (const String fileName, unsigned startOffset = 0)",
        returns = "(PackageFile*)",
        valuetype = "PackageFile",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Open = {
        args = "(const String fileName, unsigned startOffset = 0)",
        description = "Open the package file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Exists = {
        args = "(const String fileName)",
        description = "Check if a file exists within the package file.",
        returns = "(bool)",
        type = "method"
      },
      GetEntry = {
        args = "(const String fileName)",
        description = "Return the file entry corresponding to the name, or null if not found.",
        returns = "(const PackageEntry*)",
        valuetype = "PackageEntry",
        type = "method"
      },
      GetEntries = {
        args = "()",
        description = "Return all file entries.",
        returns = "(const HashMap<String,PackageEntry>&)",
        valuetype = "HashMap<String,PackageEntry>",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return the package file name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return hash of the package file name.",
        returns = "(StringHash)",
        type = "method"
      },
      GetNumFiles = {
        args = "()",
        description = "Return number of files.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTotalSize = {
        args = "()",
        description = "Return total size of the package file.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        description = "Return checksum of the package file contents.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether the files are compressed.",
        returns = "(bool)",
        type = "method"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nPackage file name hash.",
        type = "value"
      },
      numFiles = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      totalSize = {
        description = "(Readonly) unsigned\nPackage file total size.",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned\nPackage file checksum.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool\nCompressed flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ParticleEmitter = {
    childs = {
      Load = {
        args = "(XMLFile* file)",
        description = "Load emitter parameters from an XML file.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(XMLFile* file)",
        description = "Save particle emitter parameters to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetNumParticles = {
        args = "(unsigned num)",
        description = "Set maximum number of particles.",
        returns = "()",
        type = "method"
      },
      SetEmissionRate = {
        args = "(float rate)",
        description = "Set emission rate (both minimum and maximum.)",
        returns = "()",
        type = "method"
      },
      SetMinEmissionRate = {
        args = "(float rate)",
        description = "Set minimum emission rate.",
        returns = "()",
        type = "method"
      },
      SetMaxEmissionRate = {
        args = "(float rate)",
        description = "Set maximum emission rate.",
        returns = "()",
        type = "method"
      },
      SetEmitterType = {
        args = "(EmitterType type)",
        description = "Set emitter type.",
        returns = "()",
        type = "method"
      },
      SetEmitterSize = {
        args = "(const Vector3& size)",
        description = "Set emitter size.",
        returns = "()",
        type = "method"
      },
      SetActiveTime = {
        args = "(float time)",
        description = "Set emission active period length (0 = infinite.)",
        returns = "()",
        type = "method"
      },
      SetInactiveTime = {
        args = "(float time)",
        description = "Set emission inactive period length (0 = infinite.)",
        returns = "()",
        type = "method"
      },
      SetEmitting = {
        args = "(bool enable, bool resetPeriod = false)",
        description = "Set whether should be emitting and optionally reset emission period.",
        returns = "()",
        type = "method"
      },
      SetUpdateInvisible = {
        args = "(bool enable)",
        description = "Set whether to update when particles are not visible.",
        returns = "()",
        type = "method"
      },
      SetTimeToLive = {
        args = "(float time)",
        description = "Set particle time to live (both minimum and maximum.)",
        returns = "()",
        type = "method"
      },
      SetMinTimeToLive = {
        args = "(float time)",
        description = "Set particle minimum time to live.",
        returns = "()",
        type = "method"
      },
      SetMaxTimeToLive = {
        args = "(float time)",
        description = "Set particle maximum time to live.",
        returns = "()",
        type = "method"
      },
      SetParticleSize = {
        args = "(const Vector2& size)",
        description = "Set particle size (both minimum and maximum.)",
        returns = "()",
        type = "method"
      },
      SetMinParticleSize = {
        args = "(const Vector2& size)",
        description = "Set particle minimum size.",
        returns = "()",
        type = "method"
      },
      SetMaxParticleSize = {
        args = "(const Vector2& size)",
        description = "Set particle maximum size.",
        returns = "()",
        type = "method"
      },
      SetMinDirection = {
        args = "(const Vector3& direction)",
        description = "Set negative direction limit.",
        returns = "()",
        type = "method"
      },
      SetMaxDirection = {
        args = "(const Vector3& direction)",
        description = "Set positive direction limit.",
        returns = "()",
        type = "method"
      },
      SetVelocity = {
        args = "(float velocity)",
        description = "Set particle velocity (both minimum and maximum.)",
        returns = "()",
        type = "method"
      },
      SetMinVelocity = {
        args = "(float velocity)",
        description = "Set particle minimum velocity.",
        returns = "()",
        type = "method"
      },
      SetMaxVelocity = {
        args = "(float velocity)",
        description = "Set particle maximum velocity.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(float rotation)",
        description = "Set particle rotation (both minimum and maximum.)",
        returns = "()",
        type = "method"
      },
      SetMinRotation = {
        args = "(float rotation)",
        description = "Set particle minimum rotation.",
        returns = "()",
        type = "method"
      },
      SetMaxRotation = {
        args = "(float rotation)",
        description = "Set particle maximum rotation.",
        returns = "()",
        type = "method"
      },
      SetRotationSpeed = {
        args = "(float speed)",
        description = "Set particle rotation speed (both minimum and maximum.)",
        returns = "()",
        type = "method"
      },
      SetMinRotationSpeed = {
        args = "(float speed)",
        description = "Set particle minimum rotation speed.",
        returns = "()",
        type = "method"
      },
      SetMaxRotationSpeed = {
        args = "(float speed)",
        description = "Set particle maximum rotation speed.",
        returns = "()",
        type = "method"
      },
      SetConstantForce = {
        args = "(const Vector3& force)",
        description = "Set constant force acting on particles.",
        returns = "()",
        type = "method"
      },
      SetDampingForce = {
        args = "(float force)",
        description = "Set particle velocity damping force.",
        returns = "()",
        type = "method"
      },
      SetSizeAdd = {
        args = "(float sizeAdd)",
        description = "Set particle size additive modifier.",
        returns = "()",
        type = "method"
      },
      SetSizeMul = {
        args = "(float sizeMul)",
        description = "Set particle size multiplicative modifier.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "Set color of particles.",
        returns = "()",
        type = "method"
      },
      SetNumColors = {
        args = "(unsigned num)",
        description = "Set number of color animation frames.",
        returns = "()",
        type = "method"
      },
      SetNumTextureFrames = {
        args = "(unsigned num)",
        description = "Set number of texture animation frames.",
        returns = "()",
        type = "method"
      },
      GetNumParticles = {
        args = "()",
        description = "Return maximum number of particles.",
        returns = "(unsigned)",
        type = "method"
      },
      IsEmitting = {
        args = "()",
        description = "Return whether is currently emitting.",
        returns = "(bool)",
        type = "method"
      },
      GetUpdateInvisible = {
        args = "()",
        description = "Return whether to update when particles are not visible.",
        returns = "(bool)",
        type = "method"
      },
      GetMinEmissionRate = {
        args = "()",
        description = "Return minimum emission rate.",
        returns = "(float)",
        type = "method"
      },
      GetMaxEmissionRate = {
        args = "()",
        description = "Return maximum emission rate.",
        returns = "(float)",
        type = "method"
      },
      GetEmitterType = {
        args = "()",
        description = "Return emitter type.",
        returns = "(EmitterType)",
        type = "method"
      },
      GetEmitterSize = {
        args = "()",
        description = "Return emitter size.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetActiveTime = {
        args = "()",
        description = "Return emission active period length (0 = infinite.)",
        returns = "(float)",
        type = "method"
      },
      GetInactiveTime = {
        args = "()",
        description = "Return emission inactive period length (0 = infinite.)",
        returns = "(float)",
        type = "method"
      },
      GetMinTimeToLive = {
        args = "()",
        description = "Return particle minimum time to live.",
        returns = "(float)",
        type = "method"
      },
      GetMaxTimeToLive = {
        args = "()",
        description = "Return particle maximum time to live.",
        returns = "(float)",
        type = "method"
      },
      GetMinParticleSize = {
        args = "()",
        description = "Return particle minimum size.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxParticleSize = {
        args = "()",
        description = "Return particle maximum size.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinDirection = {
        args = "()",
        description = "Return negative direction limit.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetMaxDirection = {
        args = "()",
        description = "Return positive direction limit.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetMinVelocity = {
        args = "()",
        description = "Return particle minimum velocity.",
        returns = "(float)",
        type = "method"
      },
      GetMaxVelocity = {
        args = "()",
        description = "Return particle maximum velocity.",
        returns = "(float)",
        type = "method"
      },
      GetMinRotation = {
        args = "()",
        description = "Return particle minimum rotation.",
        returns = "(float)",
        type = "method"
      },
      GetMaxRotation = {
        args = "()",
        description = "Return particle maximum rotation.",
        returns = "(float)",
        type = "method"
      },
      GetMinRotationSpeed = {
        args = "()",
        description = "Return particle minimum rotation speed.",
        returns = "(float)",
        type = "method"
      },
      GetMaxRotationSpeed = {
        args = "()",
        description = "Return particle maximum rotation speed.",
        returns = "(float)",
        type = "method"
      },
      GetConstantForce = {
        args = "()",
        description = "Return constant force acting on particles.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetDampingForce = {
        args = "()",
        description = "Return particle velocity damping force.",
        returns = "(float)",
        type = "method"
      },
      GetSizeAdd = {
        args = "()",
        description = "Return particle size additive modifier.",
        returns = "(float)",
        type = "method"
      },
      GetSizeMul = {
        args = "()",
        description = "Return particle size multiplicative modifier.",
        returns = "(float)",
        type = "method"
      },
      GetNumColors = {
        args = "()",
        description = "Return number of color animation frames.",
        returns = "(unsigned)",
        type = "method"
      },
      GetColor = {
        args = "(unsigned index)",
        returns = "(ColorFrame*)",
        valuetype = "ColorFrame",
        type = "method"
      },
      GetNumTextureFrames = {
        args = "()",
        description = "Return number of texture animation frames.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTextureFrame = {
        args = "(unsigned index)",
        returns = "(TextureFrame*)",
        valuetype = "TextureFrame",
        type = "method"
      },
      numParticles = {
        description = "unsigned",
        type = "value"
      },
      emissionRate = {
        description = "float",
        type = "value"
      },
      emitting = {
        description = "bool\nCurrently emitting flag.",
        type = "value"
      },
      updateInvisible = {
        description = "bool\nUpdate when invisible flag.",
        type = "value"
      },
      minEmissionRate = {
        description = "float",
        type = "value"
      },
      maxEmissionRate = {
        description = "float",
        type = "value"
      },
      emitterType = {
        description = "EmitterType\nEmitter shape.",
        type = "value"
      },
      emitterSize = {
        valuetype = "Vector3",
        description = "Vector3&\nEmitter size.",
        type = "value"
      },
      activeTime = {
        description = "float\nActive period.",
        type = "value"
      },
      inactiveTime = {
        description = "float\nInactive period.",
        type = "value"
      },
      timeToLive = {
        description = "float",
        type = "value"
      },
      minTimeToLive = {
        description = "float",
        type = "value"
      },
      maxTimeToLive = {
        description = "float",
        type = "value"
      },
      particleSize = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      minParticleSize = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxParticleSize = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      minDirection = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      maxDirection = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      velocity = {
        description = "float",
        type = "value"
      },
      minVelocity = {
        description = "float",
        type = "value"
      },
      maxVelocity = {
        description = "float",
        type = "value"
      },
      rotation = {
        description = "float",
        type = "value"
      },
      minRotation = {
        description = "float",
        type = "value"
      },
      maxRotation = {
        description = "float",
        type = "value"
      },
      rotationSpeed = {
        description = "float",
        type = "value"
      },
      minRotationSpeed = {
        description = "float",
        type = "value"
      },
      maxRotationSpeed = {
        description = "float",
        type = "value"
      },
      constantForce = {
        valuetype = "Vector3",
        description = "Vector3&\nParticle constant force.",
        type = "value"
      },
      dampingForce = {
        description = "float\nParticle velocity damping force.",
        type = "value"
      },
      sizeAdd = {
        description = "float\nParticle size additive parameter.",
        type = "value"
      },
      sizeMul = {
        description = "float\nParticle size multiplicative parameter.",
        type = "value"
      },
      numColors = {
        description = "unsigned",
        type = "value"
      },
      numTextureFrames = {
        description = "unsigned",
        type = "value"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetNumBillboards = {
        args = "(unsigned num)",
        description = "Set number of billboards.",
        returns = "()",
        type = "method"
      },
      SetRelative = {
        args = "(bool enable)",
        description = "Set whether billboards are relative to the scene node. Default true.",
        returns = "()",
        type = "method"
      },
      SetScaled = {
        args = "(bool enable)",
        description = "Set whether scene node scale affects billboards' size. Default true.",
        returns = "()",
        type = "method"
      },
      SetSorted = {
        args = "(bool enable)",
        description = "Set whether billboards are sorted by distance. Default false.",
        returns = "()",
        type = "method"
      },
      SetFaceCamera = {
        args = "(bool enable)",
        description = "Set whether billboards face the camera automatically. Default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationLodBias = {
        args = "(float bias)",
        description = "Set animation LOD bias.",
        returns = "()",
        type = "method"
      },
      Commit = {
        args = "()",
        description = "Mark for bounding box and vertex buffer update. Call after modifying the billboards.",
        returns = "()",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetNumBillboards = {
        args = "()",
        description = "Return number of billboards.",
        returns = "(unsigned)",
        type = "method"
      },
      GetBillboard = {
        args = "(unsigned index)",
        description = "Return billboard by index.",
        returns = "(Billboard*)",
        valuetype = "Billboard",
        type = "method"
      },
      IsRelative = {
        args = "()",
        description = "Return whether billboards are relative to the scene node.",
        returns = "(bool)",
        type = "method"
      },
      IsScaled = {
        args = "()",
        description = "Return whether scene node scale affects billboards' size.",
        returns = "(bool)",
        type = "method"
      },
      IsSorted = {
        args = "()",
        description = "Return whether billboards are sorted.",
        returns = "(bool)",
        type = "method"
      },
      GetFaceCamera = {
        args = "()",
        description = "Return whether faces the camera automatically.",
        returns = "(bool)",
        type = "method"
      },
      GetAnimationLodBias = {
        args = "()",
        description = "Return animation LOD bias.",
        returns = "(float)",
        type = "method"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      numBillboards = {
        description = "unsigned",
        type = "value"
      },
      relative = {
        description = "bool\nBillboards relative flag.",
        type = "value"
      },
      scaled = {
        description = "bool\nScale affects billboard scale flag.",
        type = "value"
      },
      sorted = {
        description = "bool\nBillboards sorted flag.",
        type = "value"
      },
      faceCamera = {
        description = "bool\nFace camera flag.",
        type = "value"
      },
      animationLodBias = {
        description = "float\nAnimation LOD bias.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ParticleEmitter2D = {
    childs = {
      SetModel = {
        args = "(ParticleModel2D* model)",
        description = "Set particle model.",
        returns = "()",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return particle model.",
        returns = "(ParticleModel2D*)",
        valuetype = "ParticleModel2D",
        type = "method"
      },
      model = {
        valuetype = "ParticleModel2D",
        description = "ParticleModel2D*\nParticle model.",
        type = "value"
      },
      SetPixelsPerUnit = {
        args = "(float pixelsPerUnit)",
        description = "Set pixels per coordinate unit.",
        returns = "()",
        type = "method"
      },
      SetSprite = {
        args = "(Sprite2D* sprite)",
        description = "Set sprite.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetZValue = {
        args = "(float zValue)",
        description = "Set Z value.",
        returns = "()",
        type = "method"
      },
      GetPixelsPerUnit = {
        args = "()",
        description = "Return pixels per coordinate unit.",
        returns = "(float)",
        type = "method"
      },
      GetSprite = {
        args = "()",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      GetZValue = {
        args = "()",
        description = "Return Z value.",
        returns = "(float)",
        type = "method"
      },
      pixelsPerUnit = {
        description = "float\nPixels per coordinate unit.",
        type = "value"
      },
      sprite = {
        valuetype = "Sprite2D",
        description = "Sprite2D*\nSprite.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*\nMaterial. If null, use a default material. If non-null, use a clone of this for updating the diffuse texture.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode.",
        type = "value"
      },
      zValue = {
        description = "float\nZ value.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ParticleModel2D = {
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    type = "class"
  },
  Pass = {
    type = "class"
  },
  PhysicsRaycastResult = {
    childs = {
      new = {
        args = "()",
        returns = "(PhysicsRaycastResult*)",
        valuetype = "PhysicsRaycastResult",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      position = {
        description = "Vector3",
        type = "value"
      },
      normal = {
        description = "Vector3",
        type = "value"
      },
      distance = {
        description = "float",
        type = "value"
      },
      body = {
        valuetype = "RigidBody",
        description = "RigidBody*",
        type = "value"
      },
    },
    type = "class"
  },
  PhysicsWorld = {
    childs = {
      Update = {
        args = "(float timeStep)",
        description = "Step the simulation forward.",
        returns = "()",
        type = "method"
      },
      UpdateCollisions = {
        args = "()",
        description = "Refresh collisions only without updating dynamics.",
        returns = "()",
        type = "method"
      },
      SetFps = {
        args = "(int fps)",
        description = "Set simulation steps per second.",
        returns = "()",
        type = "method"
      },
      SetGravity = {
        args = "(Vector3 gravity)",
        description = "Set gravity.",
        returns = "()",
        type = "method"
      },
      SetNumIterations = {
        args = "(int num)",
        description = "Set number of constraint solver iterations.",
        returns = "()",
        type = "method"
      },
      SetInterpolation = {
        args = "(bool enable)",
        description = "Set whether to interpolate between simulation steps.",
        returns = "()",
        type = "method"
      },
      SetInternalEdge = {
        args = "(bool enable)",
        description = "Set whether to use Bullet's internal edge utility for trimesh collisions. Disabled by default.",
        returns = "()",
        type = "method"
      },
      SetSplitImpulse = {
        args = "(bool enable)",
        description = "Set split impulse collision mode. This is more accurate, but slower. Disabled by default.",
        returns = "()",
        type = "method"
      },
      SetMaxNetworkAngularVelocity = {
        args = "(float velocity)",
        description = "Set maximum angular velocity for network replication.",
        returns = "()",
        type = "method"
      },
      Raycast = {
        args = "(const Ray& ray, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(const PODVector<PhysicsRaycastResult>&)",
        valuetype = "PODVector<PhysicsRaycastResult>",
        type = "method"
      },
      RaycastSingle = {
        args = "(const Ray& ray, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(PhysicsRaycastResult)",
        type = "method"
      },
      SphereCast = {
        args = "(const Ray& ray, float radius, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(PhysicsRaycastResult)",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Add debug geometry to the debug renderer.",
        returns = "()",
        type = "method"
      },
      RemoveCachedGeometry = {
        args = "(Model* model)",
        description = "Invalidate cached collision geometry for a model.",
        returns = "()",
        type = "method"
      },
      GetGravity = {
        args = "()",
        description = "Return gravity.",
        returns = "(Vector3)",
        type = "method"
      },
      GetNumIterations = {
        args = "()",
        description = "Return number of constraint solver iterations.",
        returns = "(int)",
        type = "method"
      },
      GetInterpolation = {
        args = "()",
        description = "Return whether interpolation between simulation steps is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetInternalEdge = {
        args = "()",
        description = "Return whether Bullet's internal edge utility for trimesh collisions is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetSplitImpulse = {
        args = "()",
        description = "Return whether split impulse collision mode is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetFps = {
        args = "()",
        description = "Return simulation steps per second.",
        returns = "(int)",
        type = "method"
      },
      GetMaxNetworkAngularVelocity = {
        args = "()",
        description = "Return maximum angular velocity for network replication.",
        returns = "(float)",
        type = "method"
      },
      gravity = {
        description = "Vector3",
        type = "value"
      },
      numIterations = {
        description = "int",
        type = "value"
      },
      interpolation = {
        description = "bool\nInterpolation flag.",
        type = "value"
      },
      internalEdge = {
        description = "bool\nUse internal edge utility flag.",
        type = "value"
      },
      splitImpulse = {
        description = "bool",
        type = "value"
      },
      fps = {
        description = "int\nSimulation steps per second.",
        type = "value"
      },
      maxNetworkAngularVelocity = {
        description = "float\nMaximum angular velocity for network replication.",
        type = "value"
      },
      applyingTransforms = {
        description = "bool\nApplying transforms flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Plane = {
    childs = {
      new = {
        args = "()",
        description = "(Plane*) new (const Plane& plane),\n(Plane*) new (const Vector3& v0, const Vector3& v1, const Vector3& v2),\n(Plane*) new (const Vector3& normal, const Vector3& point),\n(Plane*) new (const Vector4& plane)",
        returns = "(Plane*)",
        valuetype = "Plane",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const Vector3& v0, const Vector3& v1, const Vector3& v2)",
        description = "() Define (const Vector3& normal, const Vector3& point),\n() Define (const Vector4& plane)",
        returns = "()",
        type = "method"
      },
      Transform = {
        args = "(const Matrix3& transform)",
        description = "() Transform (const Matrix3x4& transform),\n() Transform (const Matrix4& transform)",
        returns = "()",
        type = "method"
      },
      Distance = {
        args = "(const Vector3& point)",
        returns = "(float)",
        type = "method"
      },
      Reflect = {
        args = "(const Vector3& direction)",
        returns = "(Vector3)",
        type = "method"
      },
      ReflectionMatrix = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3& transform)",
        description = "(Plane) Transformed (const Matrix3x4& transform),\n(Plane) Transformed (const Matrix4& transform)",
        returns = "(Plane)",
        type = "method"
      },
      ToVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      normal = {
        description = "Vector3",
        type = "value"
      },
      absNormal = {
        description = "Vector3",
        type = "value"
      },
      d = {
        description = "float",
        type = "value"
      },
      UP = {
        description = "const Plane",
        type = "value"
      },
    },
    type = "class"
  },
  Polyhedron = {
    childs = {
      new = {
        args = "()",
        description = "(Polyhedron*) new (const Polyhedron& polyhedron),\n(Polyhedron*) new (const BoundingBox& box),\n(Polyhedron*) new (const Frustum& frustum)",
        returns = "(Polyhedron*)",
        valuetype = "Polyhedron",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const BoundingBox& box)",
        description = "() Define (const Frustum& frustum)",
        returns = "()",
        type = "method"
      },
      AddFace = {
        args = "(const Vector3& v0, const Vector3& v1, const Vector3& v2)",
        description = "() AddFace (const Vector3& v0, const Vector3& v1, const Vector3& v2, const Vector3& v3)",
        returns = "()",
        type = "method"
      },
      Clip = {
        args = "(const Plane& plane)",
        description = "() Clip (const BoundingBox& box),\n() Clip (const Frustum& box)",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Transform = {
        args = "(const Matrix3& transform)",
        description = "() Transform (const Matrix3x4& transform)",
        returns = "()",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3& transform)",
        description = "(Polyhedron) Transformed (const Matrix3x4& transform)",
        returns = "(Polyhedron)",
        type = "method"
      },
      Empty = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      empty = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  Quaternion = {
    childs = {
      new = {
        args = "()",
        description = "(Quaternion*) new (const Quaternion& quat),\n(Quaternion*) new (float w, float x, float y, float z),\n(Quaternion*) new (float angle, const Vector3& axis),\n(Quaternion*) new (float x, float y, float z),\n(Quaternion*) new (const Vector3& start, const Vector3& end),\n(Quaternion*) new (const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis),\n(Quaternion*) new (const Matrix3& matrix)",
        returns = "(Quaternion*)",
        valuetype = "Quaternion",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      FromAngleAxis = {
        args = "(float angle, const Vector3& axis)",
        returns = "()",
        type = "method"
      },
      FromEulerAngles = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      FromRotationTo = {
        args = "(const Vector3& start, const Vector3& end)",
        returns = "()",
        type = "method"
      },
      FromAxes = {
        args = "(const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis)",
        returns = "()",
        type = "method"
      },
      FromRotationMatrix = {
        args = "(const Matrix3& matrix)",
        returns = "()",
        type = "method"
      },
      FromLookRotation = {
        args = "(const Vector3& direction, const Vector3& up)",
        returns = "()",
        type = "method"
      },
      Normalize = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Normalized = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      Inverse = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      LengthSquared = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      DotProduct = {
        args = "(const Quaternion& rhs)",
        returns = "(float)",
        type = "method"
      },
      Equals = {
        args = "(const Quaternion& rhs)",
        returns = "(bool)",
        type = "method"
      },
      Conjugate = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      EulerAngles = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      YawAngle = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      PitchAngle = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      RollAngle = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      RotationMatrix = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      Slerp = {
        args = "(Quaternion rhs, float t)",
        returns = "(Quaternion)",
        type = "method"
      },
      Nlerp = {
        args = "(Quaternion rhs, float t, bool shortestPath)",
        returns = "(Quaternion)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      w = {
        description = "float",
        type = "value"
      },
      x = {
        description = "float",
        type = "value"
      },
      y = {
        description = "float",
        type = "value"
      },
      z = {
        description = "float",
        type = "value"
      },
      IDENTITY = {
        description = "const Quaternion",
        type = "value"
      },
    },
    type = "class"
  },
  Ray = {
    childs = {
      new = {
        args = "()",
        description = "(Ray*) new (const Vector3& origin, const Vector3& direction),\n(Ray*) new (const Ray& ray)",
        returns = "(Ray*)",
        valuetype = "Ray",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const Vector3& origin, const Vector3& direction)",
        returns = "()",
        type = "method"
      },
      Project = {
        args = "(const Vector3& point)",
        returns = "(Vector3)",
        type = "method"
      },
      Distance = {
        args = "(const Vector3& point)",
        returns = "(float)",
        type = "method"
      },
      ClosestPoint = {
        args = "(const Ray& ray)",
        returns = "(Vector3)",
        type = "method"
      },
      HitDistance = {
        args = "(const Plane& plane)",
        description = "(float) HitDistance (const BoundingBox& box),\n(float) HitDistance (const Frustum& frustum, bool solidInside = true),\n(float) HitDistance (const Sphere& sphere),\n(float) HitDistance (const Vector3& v0, const Vector3& v1, const Vector3& v2)",
        returns = "(float)",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3x4& transform)",
        returns = "(Ray)",
        type = "method"
      },
      origin = {
        description = "Vector3",
        type = "value"
      },
      direction = {
        description = "Vector3",
        type = "value"
      },
    },
    type = "class"
  },
  RayQueryResult = {
    childs = {
      new = {
        args = "()",
        returns = "(RayQueryResult*)",
        valuetype = "RayQueryResult",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      position = {
        description = "Vector3",
        type = "value"
      },
      normal = {
        description = "Vector3",
        type = "value"
      },
      distance = {
        description = "float",
        type = "value"
      },
      drawable = {
        valuetype = "Drawable",
        description = "Drawable*",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
      subObject = {
        description = "unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  Rect = {
    childs = {
      new = {
        args = "()",
        description = "(Rect*) new (const Rect& rect),\n(Rect*) new (const Vector2& min, const Vector2& max),\n(Rect*) new (float left, float top, float right, float bottom),\n(Rect*) new (const Vector4& vector)",
        returns = "(Rect*)",
        valuetype = "Rect",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const Rect& rect)",
        description = "() Define (const Vector2& min, const Vector2& max),\n() Define (const Vector2& point)",
        returns = "()",
        type = "method"
      },
      Merge = {
        args = "(const Vector2& point)",
        description = "() Merge (const Rect& rect)",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Clip = {
        args = "(const Rect& rect)",
        returns = "()",
        type = "method"
      },
      Center = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      Size = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      HalfSize = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      Equals = {
        args = "(const Rect& rhs)",
        returns = "(bool)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector2& point)",
        returns = "(Intersection)",
        type = "method"
      },
      ToVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      min = {
        description = "Vector2",
        type = "value"
      },
      max = {
        description = "Vector2",
        type = "value"
      },
      FULL = {
        description = "const Rect",
        type = "value"
      },
      POSITIVE = {
        description = "const Rect",
        type = "value"
      },
      ZERO = {
        description = "const Rect",
        type = "value"
      },
      center = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      size = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      halfSize = {
        description = "(Readonly) Vector2",
        type = "value"
      },
    },
    type = "class"
  },
  RemoteEvent = {
    childs = {
      senderID = {
        description = "unsigned",
        type = "value"
      },
      eventType = {
        description = "StringHash",
        type = "value"
      },
      eventData = {
        description = "VariantMap",
        type = "value"
      },
      inOrder = {
        description = "bool",
        type = "value"
      },
    },
    type = "class"
  },
  RenderPath = {
    childs = {
      Clone = {
        args = "()",
        description = "Clone the rendering path.",
        returns = "(RenderPath*)",
        valuetype = "RenderPath",
        type = "method"
      },
      Load = {
        args = "(XMLFile* file)",
        description = "Clear existing data and load from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Append = {
        args = "(XMLFile* file)",
        description = "Append data from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetEnabled = {
        args = "(const String tag, bool active)",
        description = "Enable/disable commands and rendertargets by tag.",
        returns = "()",
        type = "method"
      },
      ToggleEnabled = {
        args = "(const String tag)",
        description = "Toggle enabled state of commands and rendertargets by tag.",
        returns = "()",
        type = "method"
      },
      SetRenderTarget = {
        args = "(unsigned index, const RenderTargetInfo& info)",
        description = "Assign rendertarget at index.",
        returns = "()",
        type = "method"
      },
      AddRenderTarget = {
        args = "(const RenderTargetInfo& info)",
        description = "Add a rendertarget.",
        returns = "()",
        type = "method"
      },
      RemoveRenderTarget = {
        args = "(const String name)",
        description = "() RemoveRenderTarget (unsigned index)\nRemove a rendertarget by name.",
        returns = "()",
        type = "method"
      },
      RemoveRenderTargets = {
        args = "(const String tag)",
        description = "Remove rendertargets by tag name.",
        returns = "()",
        type = "method"
      },
      SetCommand = {
        args = "(unsigned index, const RenderPathCommand& command)",
        description = "Assign command at index.",
        returns = "()",
        type = "method"
      },
      AddCommand = {
        args = "(const RenderPathCommand& command)",
        description = "Add a command to the end of the list.",
        returns = "()",
        type = "method"
      },
      InsertCommand = {
        args = "(unsigned index, const RenderPathCommand& command)",
        description = "Insert a command at a position.",
        returns = "()",
        type = "method"
      },
      RemoveCommand = {
        args = "(unsigned index)",
        description = "Remove a command by index.",
        returns = "()",
        type = "method"
      },
      RemoveCommands = {
        args = "(const String tag)",
        description = "Remove commands by tag name.",
        returns = "()",
        type = "method"
      },
      SetShaderParameter = {
        args = "(const String name, const Variant& value)",
        description = "Set a shader parameter in all commands that define it.",
        returns = "()",
        type = "method"
      },
      GetNumRenderTargets = {
        args = "()",
        description = "Return number of rendertargets.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumCommands = {
        args = "()",
        description = "Return number of commands.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShaderParameter = {
        args = "(const String name)",
        description = "Return a shader parameter (first appearance in any command.)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
    },
    type = "class"
  },
  RenderSurface = {
    childs = {
      new = {
        args = "(Texture* parentTexture)",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetNumViewports = {
        args = "(unsigned num)",
        returns = "()",
        type = "method"
      },
      SetViewport = {
        args = "(unsigned index, Viewport* viewport)",
        returns = "()",
        type = "method"
      },
      SetUpdateMode = {
        args = "(RenderSurfaceUpdateMode mode)",
        returns = "()",
        type = "method"
      },
      SetLinkedRenderTarget = {
        args = "(RenderSurface* renderTarget)",
        returns = "()",
        type = "method"
      },
      SetLinkedDepthStencil = {
        args = "(RenderSurface* depthStencil)",
        returns = "()",
        type = "method"
      },
      QueueUpdate = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Release = {
        args = "()",
        returns = "()",
        type = "method"
      },
      GetParentTexture = {
        args = "()",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetWidth = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetNumViewports = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetViewport = {
        args = "(unsigned index)",
        returns = "(Viewport*)",
        valuetype = "Viewport",
        type = "method"
      },
      GetUpdateMode = {
        args = "()",
        returns = "(RenderSurfaceUpdateMode)",
        type = "method"
      },
      GetLinkedRenderTarget = {
        args = "()",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      GetLinkedDepthStencil = {
        args = "()",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      parentTexture = {
        valuetype = "Texture",
        description = "(Readonly) Texture*",
        type = "value"
      },
      width = {
        description = "(Readonly) int",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage",
        type = "value"
      },
      numViewports = {
        description = "unsigned",
        type = "value"
      },
      updateMode = {
        description = "RenderSurfaceUpdateMode",
        type = "value"
      },
      linkedRenderTarget = {
        valuetype = "RenderSurface",
        description = "RenderSurface*",
        type = "value"
      },
      linkedDepthStencil = {
        valuetype = "RenderSurface",
        description = "RenderSurface*",
        type = "value"
      },
    },
    type = "class"
  },
  Renderer = {
    childs = {
      SetNumViewports = {
        args = "(unsigned num)",
        description = "Set number of backbuffer viewports to render.",
        returns = "()",
        type = "method"
      },
      SetViewport = {
        args = "(unsigned index, Viewport* viewport)",
        description = "Set a backbuffer viewport.",
        returns = "()",
        type = "method"
      },
      SetDefaultRenderPath = {
        args = "(RenderPath* renderPath)",
        description = "() SetDefaultRenderPath (XMLFile* file)\nSet default renderpath.",
        returns = "()",
        type = "method"
      },
      SetHDRRendering = {
        args = "(bool enable)",
        description = "Set HDR rendering on/off.",
        returns = "()",
        type = "method"
      },
      SetSpecularLighting = {
        args = "(bool enable)",
        description = "Set specular lighting on/off.",
        returns = "()",
        type = "method"
      },
      SetTextureAnisotropy = {
        args = "(int level)",
        description = "Set texture anisotropy.",
        returns = "()",
        type = "method"
      },
      SetTextureFilterMode = {
        args = "(TextureFilterMode mode)",
        description = "Set texture filtering.",
        returns = "()",
        type = "method"
      },
      SetTextureQuality = {
        args = "(int quality)",
        description = "Set texture quality level.",
        returns = "()",
        type = "method"
      },
      SetMaterialQuality = {
        args = "(int quality)",
        description = "Set material quality level.",
        returns = "()",
        type = "method"
      },
      SetDrawShadows = {
        args = "(bool enable)",
        description = "Set shadows on/off.",
        returns = "()",
        type = "method"
      },
      SetShadowMapSize = {
        args = "(int size)",
        description = "Set shadow map resolution.",
        returns = "()",
        type = "method"
      },
      SetShadowQuality = {
        args = "(int quality)",
        description = "Set shadow quality (amount of samples and bit depth.)",
        returns = "()",
        type = "method"
      },
      SetReuseShadowMaps = {
        args = "(bool enable)",
        description = "Set reuse of shadow maps. Default is true. If disabled, also transparent geometry can be shadowed.",
        returns = "()",
        type = "method"
      },
      SetMaxShadowMaps = {
        args = "(int shadowMaps)",
        description = "Set maximum number of shadow maps created for one resolution. Only has effect if reuse of shadow maps is disabled.",
        returns = "()",
        type = "method"
      },
      SetMaxShadowCascades = {
        args = "(int cascades)",
        description = "Set maximum number of directional light shadow map cascades. Affects the size of directional light shadow maps.",
        returns = "()",
        type = "method"
      },
      SetDynamicInstancing = {
        args = "(bool enable)",
        description = "Set dynamic instancing on/off.",
        returns = "()",
        type = "method"
      },
      SetMinInstances = {
        args = "(int instances)",
        description = "Set minimum number of instances required in a batch group to render as instanced.",
        returns = "()",
        type = "method"
      },
      SetMaxInstanceTriangles = {
        args = "(int triangles)",
        description = "Set maximum number of triangles per object for instancing.",
        returns = "()",
        type = "method"
      },
      SetMaxSortedInstances = {
        args = "(int instances)",
        description = "Set maximum number of sorted instances per batch group. If exceeded, instances are rendered unsorted.",
        returns = "()",
        type = "method"
      },
      SetMaxOccluderTriangles = {
        args = "(int triangles)",
        description = "Set maximum number of occluder trianges.",
        returns = "()",
        type = "method"
      },
      SetOcclusionBufferSize = {
        args = "(int size)",
        description = "Set occluder buffer width.",
        returns = "()",
        type = "method"
      },
      SetOccluderSizeThreshold = {
        args = "(float screenSize)",
        description = "Set required screen size (1.0 = full screen) for occluders.",
        returns = "()",
        type = "method"
      },
      ReloadShaders = {
        args = "()",
        description = "Force reload of shaders.",
        returns = "()",
        type = "method"
      },
      GetNumViewports = {
        args = "()",
        description = "Return number of backbuffer viewports.",
        returns = "(unsigned)",
        type = "method"
      },
      GetViewport = {
        args = "(unsigned index)",
        description = "Return backbuffer viewport by index.",
        returns = "(Viewport*)",
        valuetype = "Viewport",
        type = "method"
      },
      GetDefaultRenderPath = {
        args = "()",
        description = "Return default renderpath.",
        returns = "(RenderPath*)",
        valuetype = "RenderPath",
        type = "method"
      },
      GetHDRRendering = {
        args = "()",
        description = "Return whether HDR rendering is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetSpecularLighting = {
        args = "()",
        description = "Return whether specular lighting is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetDrawShadows = {
        args = "()",
        description = "Return whether drawing shadows is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetTextureAnisotropy = {
        args = "()",
        description = "Return texture anisotropy.",
        returns = "(int)",
        type = "method"
      },
      GetTextureFilterMode = {
        args = "()",
        description = "Return texture filtering.",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetTextureQuality = {
        args = "()",
        description = "Return texture quality level.",
        returns = "(int)",
        type = "method"
      },
      GetMaterialQuality = {
        args = "()",
        description = "Return material quality level.",
        returns = "(int)",
        type = "method"
      },
      GetShadowMapSize = {
        args = "()",
        description = "Return shadow map resolution.",
        returns = "(int)",
        type = "method"
      },
      GetShadowQuality = {
        args = "()",
        description = "Return shadow quality.",
        returns = "(int)",
        type = "method"
      },
      GetReuseShadowMaps = {
        args = "()",
        description = "Return whether shadow maps are reused.",
        returns = "(bool)",
        type = "method"
      },
      GetMaxShadowMaps = {
        args = "()",
        description = "Return maximum number of shadow maps per resolution.",
        returns = "(int)",
        type = "method"
      },
      GetMaxShadowCascades = {
        args = "()",
        description = "Return maximum number of directional light shadow map cascades.",
        returns = "(int)",
        type = "method"
      },
      GetDynamicInstancing = {
        args = "()",
        description = "Return whether dynamic instancing is in use.",
        returns = "(bool)",
        type = "method"
      },
      GetMinInstances = {
        args = "()",
        description = "Return minimum number of instances required in a batch group to render as instanced.",
        returns = "(int)",
        type = "method"
      },
      GetMaxInstanceTriangles = {
        args = "()",
        description = "Return maximum number of triangles per object for instancing.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSortedInstances = {
        args = "()",
        description = "Return maximum number of sorted instances per batch group.",
        returns = "(int)",
        type = "method"
      },
      GetMaxOccluderTriangles = {
        args = "()",
        description = "Return maximum number of occluder triangles.",
        returns = "(int)",
        type = "method"
      },
      GetOcclusionBufferSize = {
        args = "()",
        description = "Return occlusion buffer width.",
        returns = "(int)",
        type = "method"
      },
      GetOccluderSizeThreshold = {
        args = "()",
        description = "Return occluder screen size threshold.",
        returns = "(float)",
        type = "method"
      },
      GetNumViews = {
        args = "()",
        description = "Return number of views rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumPrimitives = {
        args = "()",
        description = "Return number of primitives rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumBatches = {
        args = "()",
        description = "Return number of batches rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumGeometries = {
        args = "(bool allViews = false)",
        description = "Return number of geometries rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumLights = {
        args = "(bool allViews = false)",
        description = "Return number of lights rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumShadowMaps = {
        args = "(bool allViews = false)",
        description = "Return number of shadow maps rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumOccluders = {
        args = "(bool allViews = false)",
        description = "Return number of occluders rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDefaultZone = {
        args = "()",
        description = "Return the default zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      GetQuadDirLight = {
        args = "()",
        description = "Return the directional light for fullscreen quad rendering.",
        returns = "(Light*)",
        valuetype = "Light",
        type = "method"
      },
      GetDefaultMaterial = {
        args = "()",
        description = "Return the default material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetDefaultLightRamp = {
        args = "()",
        description = "Return the default range attenuation texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetDefaultLightSpot = {
        args = "()",
        description = "Return the default spotlight attenuation texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetFaceSelectCubeMap = {
        args = "()",
        description = "Return the shadowed pointlight face selection cube map.",
        returns = "(TextureCube*)",
        valuetype = "TextureCube",
        type = "method"
      },
      GetIndirectionCubeMap = {
        args = "()",
        description = "Return the shadowed pointlight indirection cube map.",
        returns = "(TextureCube*)",
        valuetype = "TextureCube",
        type = "method"
      },
      GetInstancingBuffer = {
        args = "()",
        returns = "(VertexBuffer*)",
        valuetype = "VertexBuffer",
        type = "method"
      },
      GetFrameInfo = {
        args = "()",
        description = "Return the frame update parameters.",
        returns = "(const FrameInfo&)",
        valuetype = "FrameInfo",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Add debug geometry to the debug renderer.",
        returns = "()",
        type = "method"
      },
      numViewports = {
        description = "unsigned",
        type = "value"
      },
      defaultRenderPath = {
        valuetype = "RenderPath",
        description = "RenderPath*\nDefault renderpath.",
        type = "value"
      },
      HDRRendering = {
        description = "bool",
        type = "value"
      },
      specularLighting = {
        description = "bool\nSpecular lighting flag.",
        type = "value"
      },
      drawShadows = {
        description = "bool\nDraw shadows flag.",
        type = "value"
      },
      textureAnisotropy = {
        description = "int\nTexture anisotropy level.",
        type = "value"
      },
      textureFilterMode = {
        description = "TextureFilterMode\nTexture filtering mode.",
        type = "value"
      },
      textureQuality = {
        description = "int\nTexture quality level.",
        type = "value"
      },
      materialQuality = {
        description = "int\nMaterial quality level.",
        type = "value"
      },
      shadowMapSize = {
        description = "int\nShadow map resolution.",
        type = "value"
      },
      shadowQuality = {
        description = "int\nShadow quality.",
        type = "value"
      },
      reuseShadowMaps = {
        description = "bool\nShadow map reuse flag.",
        type = "value"
      },
      maxShadowMaps = {
        description = "int\nMaximum number of shadow maps per resolution.",
        type = "value"
      },
      maxShadowCascades = {
        description = "int\nMaximum number of directional light shadow cascades.",
        type = "value"
      },
      dynamicInstancing = {
        description = "bool\nDynamic instancing flag.",
        type = "value"
      },
      minInstances = {
        description = "int\nMinimum number of instances required in a batch group to render as instanced.",
        type = "value"
      },
      maxInstanceTriangles = {
        description = "int\nMaximum triangles per object for instancing.",
        type = "value"
      },
      maxSortedInstances = {
        description = "int\nMaximum sorted instances per batch group.",
        type = "value"
      },
      maxOccluderTriangles = {
        description = "int\nMaximum occluder triangles.",
        type = "value"
      },
      occlusionBufferSize = {
        description = "int\nOcclusion buffer width.",
        type = "value"
      },
      occluderSizeThreshold = {
        description = "float\nOccluder screen size threshold.",
        type = "value"
      },
      numViews = {
        description = "(Readonly) unsigned\nNumber of views.",
        type = "value"
      },
      numPrimitives = {
        description = "(Readonly) unsigned\nNumber of primitives (3D geometry only.)",
        type = "value"
      },
      numBatches = {
        description = "(Readonly) unsigned\nNumber of batches (3D geometry only.)",
        type = "value"
      },
      defaultZone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*\nDefault zone.",
        type = "value"
      },
      defaultMaterial = {
        valuetype = "Material",
        description = "(Readonly) Material*\nDefault material.",
        type = "value"
      },
      defaultLightRamp = {
        valuetype = "Texture2D",
        description = "(Readonly) Texture2D*\nDefault range attenuation texture.",
        type = "value"
      },
      defaultLightSpot = {
        valuetype = "Texture2D",
        description = "(Readonly) Texture2D*\nDefault spotlight attenuation texture.",
        type = "value"
      },
    },
    type = "class"
  },
  Resource = {
    childs = {
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  ResourceCache = {
    childs = {
      ReleaseAllResources = {
        args = "(bool force = false)",
        description = "Release all resources. When called with the force flag false, releases all currently unused resources.",
        returns = "()",
        type = "method"
      },
      ReloadResource = {
        args = "(Resource* resource)",
        description = "Reload a resource. Return false and release it if fails.",
        returns = "(bool)",
        type = "method"
      },
      SetMemoryBudget = {
        args = "(ShortStringHash type, unsigned budget)",
        description = "() SetMemoryBudget (const String type, unsigned budget)\nSet memory budget for a specific resource type, default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetAutoReloadResources = {
        args = "(bool enable)",
        description = "Enable or disable automatic reloading of resources as files are modified. Default false.",
        returns = "()",
        type = "method"
      },
      SetReturnFailedResources = {
        args = "(bool enable)",
        description = "Enable or disable returning resources that failed to load. Default false. This may be useful in editing to not lose resource ref attributes.",
        returns = "()",
        type = "method"
      },
      SetSearchPackagesFirst = {
        args = "(bool value)",
        description = "Define whether when getting resources should check package files or directories first. True for packages, false for directories.",
        returns = "()",
        type = "method"
      },
      GetFile = {
        args = "(const String name)",
        description = "Open and return a file from the resource load paths or from inside a package file. If not found, use a fallback search with absolute path. Return null if fails.",
        returns = "(File*)",
        valuetype = "File",
        type = "method"
      },
      GetResource = {
        args = "(const String type, const String name, bool SendEventOnFailure = true)",
        returns = "(Resource*)",
        valuetype = "Resource",
        type = "method"
      },
      Exists = {
        args = "(const String name)",
        description = "Return whether a file exists by name.",
        returns = "(bool)",
        type = "method"
      },
      GetMemoryBudget = {
        args = "(ShortStringHash type)",
        description = "Return memory budget for a resource type.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMemoryUse = {
        args = "(ShortStringHash type)",
        description = "Return total memory use for a resource type.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTotalMemoryUse = {
        args = "()",
        description = "Return total memory use for all resources.",
        returns = "(unsigned)",
        type = "method"
      },
      GetResourceFileName = {
        args = "(const String name)",
        description = "Return full absolute file name of resource if possible.",
        returns = "(String)",
        type = "method"
      },
      GetAutoReloadResources = {
        args = "()",
        description = "Return whether automatic resource reloading is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetReturnFailedResources = {
        args = "()",
        description = "Return whether resources that failed to load are returned.",
        returns = "(bool)",
        type = "method"
      },
      GetSearchPackagesFirst = {
        args = "()",
        description = "Define whether when getting resources should check package files or directories first.",
        returns = "(bool)",
        type = "method"
      },
      GetPreferredResourceDir = {
        args = "(const String path)",
        description = "Return either the path itself or its parent, based on which of them has recognized resource subdirectories.",
        returns = "(String)",
        type = "method"
      },
      SanitateResourceName = {
        args = "(const String name)",
        description = "Remove unsupported constructs from the resource name to prevent ambiguity, and normalize absolute filename to resource path relative if possible.",
        returns = "(String)",
        type = "method"
      },
      SanitateResourceDirName = {
        args = "(const String name)",
        description = "Remove unnecessary constructs from a resource directory name and ensure it to be an absolute path.",
        returns = "(String)",
        type = "method"
      },
      totalMemoryUse = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      autoReloadResources = {
        description = "(Readonly) bool\nAutomatic resource reloading flag.",
        type = "value"
      },
      returnFailedResources = {
        description = "(Readonly) bool\nReturn failed resources flag.",
        type = "value"
      },
      searchPackagesFirst = {
        description = "(Readonly) bool\nSearch priority flag.",
        type = "value"
      },
    },
    type = "class"
  },
  ResourceRef = {
    childs = {
      new = {
        args = "()",
        description = "(ResourceRef*) new (ShortStringHash type),\n(ResourceRef*) new (ShortStringHash type, String name),\n(ResourceRef*) new (const ResourceRef& rhs)",
        returns = "(ResourceRef*)",
        valuetype = "ResourceRef",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      type = {
        description = "ShortStringHash",
        type = "value"
      },
      name = {
        description = "String",
        type = "value"
      },
    },
    type = "class"
  },
  ResourceRefList = {
    childs = {
      new = {
        args = "()",
        description = "(ResourceRefList*) new (ShortStringHash type)",
        returns = "(ResourceRefList*)",
        valuetype = "ResourceRefList",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      type = {
        description = "ShortStringHash",
        type = "value"
      },
    },
    type = "class"
  },
  RigidBody = {
    childs = {
      SetMass = {
        args = "(float mass)",
        description = "Set mass. Zero mass makes the body static.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(Vector3 position)",
        description = "Set rigid body position in world space.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(Quaternion rotation)",
        description = "Set rigid body rotation in world space.",
        returns = "()",
        type = "method"
      },
      SetTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "Set rigid body position and rotation in world space as an atomic operation.",
        returns = "()",
        type = "method"
      },
      SetLinearVelocity = {
        args = "(Vector3 velocity)",
        description = "Set linear velocity.",
        returns = "()",
        type = "method"
      },
      SetLinearFactor = {
        args = "(Vector3 factor)",
        description = "Set linear degrees of freedom. Use 1 to enable an axis or 0 to disable. Default is all axes enabled (1, 1, 1).",
        returns = "()",
        type = "method"
      },
      SetLinearRestThreshold = {
        args = "(float threshold)",
        description = "Set linear velocity deactivation threshold.",
        returns = "()",
        type = "method"
      },
      SetLinearDamping = {
        args = "(float damping)",
        description = "Set linear velocity damping factor.",
        returns = "()",
        type = "method"
      },
      SetAngularVelocity = {
        args = "(Vector3 angularVelocity)",
        description = "Set angular velocity.",
        returns = "()",
        type = "method"
      },
      SetAngularFactor = {
        args = "(Vector3 factor)",
        description = "Set angular degrees of freedom. Use 1 to enable an axis or 0 to disable. Default is all axes enabled (1, 1, 1).",
        returns = "()",
        type = "method"
      },
      SetAngularRestThreshold = {
        args = "(float threshold)",
        description = "Set angular velocity deactivation threshold.",
        returns = "()",
        type = "method"
      },
      SetAngularDamping = {
        args = "(float factor)",
        description = "Set angular velocity damping factor.",
        returns = "()",
        type = "method"
      },
      SetFriction = {
        args = "(float friction)",
        description = "Set friction coefficient.",
        returns = "()",
        type = "method"
      },
      SetAnisotropicFriction = {
        args = "(Vector3 friction)",
        description = "Set anisotropic friction.",
        returns = "()",
        type = "method"
      },
      SetRollingFriction = {
        args = "(float friction)",
        description = "Set rolling friction coefficient.",
        returns = "()",
        type = "method"
      },
      SetRestitution = {
        args = "(float restitution)",
        description = "Set restitution coefficient.",
        returns = "()",
        type = "method"
      },
      SetContactProcessingThreshold = {
        args = "(float threshold)",
        description = "Set contact processing threshold.",
        returns = "()",
        type = "method"
      },
      SetCcdRadius = {
        args = "(float radius)",
        description = "Set continuous collision detection swept sphere radius.",
        returns = "()",
        type = "method"
      },
      SetCcdMotionThreshold = {
        args = "(float threshold)",
        description = "Set continuous collision detection motion-per-simulation-step threshold. 0 disables, which is the default.",
        returns = "()",
        type = "method"
      },
      SetUseGravity = {
        args = "(bool enable)",
        description = "Set whether gravity is applied to rigid body.",
        returns = "()",
        type = "method"
      },
      SetGravityOverride = {
        args = "(const Vector3& gravity)",
        description = "Set gravity override. If zero, uses physics world's gravity.",
        returns = "()",
        type = "method"
      },
      SetKinematic = {
        args = "(bool enable)",
        description = "Set rigid body kinematic mode. In kinematic mode forces are not applied to the rigid body.",
        returns = "()",
        type = "method"
      },
      SetPhantom = {
        args = "(bool enable)",
        description = "Set rigid body phantom mode. In phantom mode collisions are reported but do not apply forces.",
        returns = "()",
        type = "method"
      },
      SetCollisionLayer = {
        args = "(unsigned layer)",
        description = "Set collision layer.",
        returns = "()",
        type = "method"
      },
      SetCollisionMask = {
        args = "(unsigned mask)",
        description = "Set collision mask.",
        returns = "()",
        type = "method"
      },
      SetCollisionLayerAndMask = {
        args = "(unsigned layer, unsigned mask)",
        description = "Set collision group and mask.",
        returns = "()",
        type = "method"
      },
      SetCollisionEventMode = {
        args = "(CollisionEventMode mode)",
        description = "Set collision event signaling mode. Default is to signal when rigid bodies are active.",
        returns = "()",
        type = "method"
      },
      ApplyForce = {
        args = "(const Vector3& force)",
        description = "() ApplyForce (const Vector3& force, const Vector3& position)\nApply force to center of mass.",
        returns = "()",
        type = "method"
      },
      ApplyTorque = {
        args = "(const Vector3& torque)",
        description = "Apply torque.",
        returns = "()",
        type = "method"
      },
      ApplyImpulse = {
        args = "(const Vector3& impulse)",
        description = "() ApplyImpulse (const Vector3& impulse, const Vector3& position)\nApply impulse to center of mass.",
        returns = "()",
        type = "method"
      },
      ApplyTorqueImpulse = {
        args = "(const Vector3& torque)",
        description = "Apply torque impulse.",
        returns = "()",
        type = "method"
      },
      ResetForces = {
        args = "()",
        description = "Reset accumulated forces.",
        returns = "()",
        type = "method"
      },
      Activate = {
        args = "()",
        description = "Activate rigid body if it was resting.",
        returns = "()",
        type = "method"
      },
      ReAddBodyToWorld = {
        args = "()",
        description = "Readd rigid body to the physics world to clean up internal state like stale contacts.",
        returns = "()",
        type = "method"
      },
      GetPhysicsWorld = {
        args = "()",
        description = "Return physics world.",
        returns = "(PhysicsWorld*)",
        valuetype = "PhysicsWorld",
        type = "method"
      },
      GetMass = {
        args = "()",
        description = "Return mass.",
        returns = "(float)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return rigid body position in world space.",
        returns = "(Vector3)",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return rigid body rotation in world space.",
        returns = "(Quaternion)",
        type = "method"
      },
      GetLinearVelocity = {
        args = "()",
        description = "Return linear velocity.",
        returns = "(Vector3)",
        type = "method"
      },
      GetLinearFactor = {
        args = "()",
        description = "Return linear degrees of freedom.",
        returns = "(Vector3)",
        type = "method"
      },
      GetVelocityAtPoint = {
        args = "(const Vector3& position)",
        description = "Return linear velocity at local point.",
        returns = "(Vector3)",
        type = "method"
      },
      GetLinearRestThreshold = {
        args = "()",
        description = "Return linear velocity deactivation threshold.",
        returns = "(float)",
        type = "method"
      },
      GetLinearDamping = {
        args = "()",
        description = "Return linear velocity damping factor.",
        returns = "(float)",
        type = "method"
      },
      GetAngularVelocity = {
        args = "()",
        description = "Return angular velocity.",
        returns = "(Vector3)",
        type = "method"
      },
      GetAngularFactor = {
        args = "()",
        description = "Return angular degrees of freedom.",
        returns = "(Vector3)",
        type = "method"
      },
      GetAngularRestThreshold = {
        args = "()",
        description = "Return angular velocity deactivation threshold.",
        returns = "(float)",
        type = "method"
      },
      GetAngularDamping = {
        args = "()",
        description = "Return angular velocity damping factor.",
        returns = "(float)",
        type = "method"
      },
      GetFriction = {
        args = "()",
        description = "Return friction coefficient.",
        returns = "(float)",
        type = "method"
      },
      GetAnisotropicFriction = {
        args = "()",
        description = "Return anisotropic friction.",
        returns = "(Vector3)",
        type = "method"
      },
      GetRollingFriction = {
        args = "()",
        description = "Return rolling friction coefficient.",
        returns = "(float)",
        type = "method"
      },
      GetRestitution = {
        args = "()",
        description = "Return restitution coefficient.",
        returns = "(float)",
        type = "method"
      },
      GetContactProcessingThreshold = {
        args = "()",
        description = "Return contact processing threshold.",
        returns = "(float)",
        type = "method"
      },
      GetCcdRadius = {
        args = "()",
        description = "Return continuous collision detection swept sphere radius.",
        returns = "(float)",
        type = "method"
      },
      GetCcdMotionThreshold = {
        args = "()",
        description = "Return continuous collision detection motion-per-simulation-step threshold.",
        returns = "(float)",
        type = "method"
      },
      GetUseGravity = {
        args = "()",
        description = "Return whether rigid body uses gravity.",
        returns = "(bool)",
        type = "method"
      },
      GetGravityOverride = {
        args = "()",
        description = "Return gravity override. If zero (default), uses the physics world's gravity.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetCenterOfMass = {
        args = "()",
        description = "Return center of mass offset.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      IsKinematic = {
        args = "()",
        description = "Return kinematic mode flag.",
        returns = "(bool)",
        type = "method"
      },
      IsPhantom = {
        args = "()",
        description = "Return phantom mode flag.",
        returns = "(bool)",
        type = "method"
      },
      IsActive = {
        args = "()",
        description = "Return whether rigid body is active (not sleeping.)",
        returns = "(bool)",
        type = "method"
      },
      GetCollisionLayer = {
        args = "()",
        description = "Return collision layer.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCollisionMask = {
        args = "()",
        description = "Return collision mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCollisionEventMode = {
        args = "()",
        description = "Return collision event signaling mode.",
        returns = "(CollisionEventMode)",
        type = "method"
      },
      physicsWorld = {
        valuetype = "PhysicsWorld",
        description = "(Readonly) PhysicsWorld*\nPhysics world.",
        type = "value"
      },
      mass = {
        description = "float\nMass.",
        type = "value"
      },
      position = {
        description = "Vector3",
        type = "value"
      },
      rotation = {
        description = "Quaternion",
        type = "value"
      },
      linearVelocity = {
        description = "Vector3",
        type = "value"
      },
      linearFactor = {
        description = "Vector3",
        type = "value"
      },
      linearRestThreshold = {
        description = "float",
        type = "value"
      },
      linearDamping = {
        description = "float",
        type = "value"
      },
      angularVelocity = {
        description = "Vector3",
        type = "value"
      },
      angularFactor = {
        description = "Vector3",
        type = "value"
      },
      angularRestThreshold = {
        description = "float",
        type = "value"
      },
      angularDamping = {
        description = "float",
        type = "value"
      },
      friction = {
        description = "float",
        type = "value"
      },
      anisotropicFriction = {
        description = "Vector3",
        type = "value"
      },
      rollingFriction = {
        description = "float",
        type = "value"
      },
      restitution = {
        description = "float",
        type = "value"
      },
      contactProcessingThreshold = {
        description = "float",
        type = "value"
      },
      ccdRadius = {
        description = "float",
        type = "value"
      },
      ccdMotionThreshold = {
        description = "float",
        type = "value"
      },
      useGravity = {
        description = "bool\nUse gravity flag.",
        type = "value"
      },
      gravityOverride = {
        valuetype = "Vector3",
        description = "Vector3&\nGravity override vector.",
        type = "value"
      },
      centerOfMass = {
        valuetype = "Vector3",
        description = "(Readonly) Vector3&\nCenter of mass offset.",
        type = "value"
      },
      kinematic = {
        description = "bool\nKinematic flag.",
        type = "value"
      },
      phantom = {
        description = "bool\nPhantom flag.",
        type = "value"
      },
      active = {
        description = "(Readonly) bool",
        type = "value"
      },
      collisionLayer = {
        description = "unsigned\nCollision layer.",
        type = "value"
      },
      collisionMask = {
        description = "unsigned\nCollision mask.",
        type = "value"
      },
      collisionEventMode = {
        description = "CollisionEventMode\nCollision event signaling mode.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Scene = {
    childs = {
      new = {
        args = "()",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Load = {
        args = "(File* source)",
        description = "(bool) Load (const String fileName)",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(File* dest)",
        description = "(bool) Save (const String fileName)",
        returns = "(bool)",
        type = "method"
      },
      LoadXML = {
        args = "(File* source)",
        description = "(bool) LoadXML (const String fileName)",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(File* dest)",
        description = "(bool) SaveXML (const String fileName)",
        returns = "(bool)",
        type = "method"
      },
      Instantiate = {
        args = "(File* source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)",
        description = "(Node*) Instantiate (const String fileName, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      InstantiateXML = {
        args = "(File* source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)",
        description = "(Node*) InstantiateXML (const String fileName, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      LoadAsync = {
        args = "(File* file)",
        description = "(bool) LoadAsync (const String fileName)\nLoad from a binary file asynchronously. Return true if started successfully.",
        returns = "(bool)",
        type = "method"
      },
      LoadAsyncXML = {
        args = "(File* file)",
        description = "(bool) LoadAsyncXML (const String fileName)\nLoad from an XML file asynchronously. Return true if started successfully.",
        returns = "(bool)",
        type = "method"
      },
      StopAsyncLoading = {
        args = "()",
        description = "Stop asynchronous loading.",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "(bool clearReplicated = true, bool clearLocal = true)",
        description = "Clear scene completely of either replicated, local or all nodes and components.",
        returns = "()",
        type = "method"
      },
      SetUpdateEnabled = {
        args = "(bool enable)",
        description = "Enable or disable scene update.",
        returns = "()",
        type = "method"
      },
      SetTimeScale = {
        args = "(float scale)",
        description = "Set update time scale. 1.0 = real time (default.)",
        returns = "()",
        type = "method"
      },
      SetElapsedTime = {
        args = "(float time)",
        description = "Set elapsed time in seconds. This can be used to prevent inaccuracy in the timer if the scene runs for a long time.",
        returns = "()",
        type = "method"
      },
      SetSmoothingConstant = {
        args = "(float constant)",
        description = "Set network client motion smoothing constant.",
        returns = "()",
        type = "method"
      },
      SetSnapThreshold = {
        args = "(float threshold)",
        description = "Set network client motion smoothing snap threshold.",
        returns = "()",
        type = "method"
      },
      GetNode = {
        args = "(unsigned id)",
        description = "Return node from the whole scene by ID, or null if not found.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      IsUpdateEnabled = {
        args = "()",
        description = "Return whether updates are enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsAsyncLoading = {
        args = "()",
        description = "Return whether an asynchronous loading operation is in progress.",
        returns = "(bool)",
        type = "method"
      },
      GetAsyncProgress = {
        args = "()",
        description = "Return asynchronous loading progress between 0.0 and 1.0, or 1.0 if not in progress.",
        returns = "(float)",
        type = "method"
      },
      GetFileName = {
        args = "()",
        description = "Return source file name.",
        returns = "(const String)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        description = "Return source file checksum.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTimeScale = {
        args = "()",
        description = "Return update time scale.",
        returns = "(float)",
        type = "method"
      },
      GetElapsedTime = {
        args = "()",
        description = "Return elapsed time in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetSmoothingConstant = {
        args = "()",
        description = "Return motion smoothing constant.",
        returns = "(float)",
        type = "method"
      },
      GetSnapThreshold = {
        args = "()",
        description = "Return motion smoothing snap threshold.",
        returns = "(float)",
        type = "method"
      },
      GetVarName = {
        args = "(ShortStringHash hash)",
        description = "Return a node user variable name, or empty if not registered.",
        returns = "(const String)",
        type = "method"
      },
      Update = {
        args = "(float timeStep)",
        description = "Update scene. Called by HandleUpdate.",
        returns = "()",
        type = "method"
      },
      BeginThreadedUpdate = {
        args = "()",
        description = "Begin a threaded update. During threaded update components can choose to delay dirty processing.",
        returns = "()",
        type = "method"
      },
      EndThreadedUpdate = {
        args = "()",
        description = "End a threaded update. Notify components that marked themselves for delayed dirty processing.",
        returns = "()",
        type = "method"
      },
      DelayedMarkedDirty = {
        args = "(Component* component)",
        description = "Add a component to the delayed dirty notify queue. Is thread-safe.",
        returns = "()",
        type = "method"
      },
      IsThreadedUpdate = {
        args = "()",
        description = "Return threaded update flag.",
        returns = "(bool)",
        type = "method"
      },
      GetFreeNodeID = {
        args = "(CreateMode mode)",
        description = "Get free node ID, either non-local or local.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFreeComponentID = {
        args = "(CreateMode mode)",
        description = "Get free component ID, either non-local or local.",
        returns = "(unsigned)",
        type = "method"
      },
      NodeAdded = {
        args = "(Node* node)",
        description = "Node added. Assign scene pointer and add to ID map.",
        returns = "()",
        type = "method"
      },
      NodeRemoved = {
        args = "(Node* node)",
        description = "Node removed. Remove from ID map.",
        returns = "()",
        type = "method"
      },
      ComponentAdded = {
        args = "(Component* component)",
        description = "Component added. Add to ID map.",
        returns = "()",
        type = "method"
      },
      ComponentRemoved = {
        args = "(Component* component)",
        description = "Component removed. Remove from ID map.",
        returns = "()",
        type = "method"
      },
      SetVarNamesAttr = {
        args = "(String value)",
        description = "Set node user variable reverse mappings.",
        returns = "()",
        type = "method"
      },
      GetVarNamesAttr = {
        args = "()",
        description = "Return node user variable reverse mappings.",
        returns = "(String)",
        type = "method"
      },
      PrepareNetworkUpdate = {
        args = "()",
        description = "Prepare network update by comparing attributes and marking replication states dirty as necessary.",
        returns = "()",
        type = "method"
      },
      CleanupConnection = {
        args = "(Connection* connection)",
        description = "Clean up all references to a network connection that is about to be removed.",
        returns = "()",
        type = "method"
      },
      MarkNetworkUpdate = {
        args = "(Node* node)",
        description = "() MarkNetworkUpdate (Component* component)\nMark a node for attribute check on the next network update.",
        returns = "()",
        type = "method"
      },
      MarkReplicationDirty = {
        args = "(Node* node)",
        description = "Mark a node dirty in scene replication states. The node does not need to have own replication state yet.",
        returns = "()",
        type = "method"
      },
      updateEnabled = {
        description = "bool\nUpdate enabled flag.",
        type = "value"
      },
      asyncLoading = {
        description = "(Readonly) bool\nAsynchronous loading flag.",
        type = "value"
      },
      asyncProgress = {
        description = "(Readonly) float\nAsynchronous loading progress.",
        type = "value"
      },
      fileName = {
        description = "const String\nSource file name.",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned\nScene source file checksum.",
        type = "value"
      },
      timeScale = {
        description = "float\nScene update time scale.",
        type = "value"
      },
      elapsedTime = {
        description = "float\nElapsed time accumulator.",
        type = "value"
      },
      smoothingConstant = {
        description = "float\nMotion smoothing constant.",
        type = "value"
      },
      snapThreshold = {
        description = "float\nMotion smoothing snap threshold.",
        type = "value"
      },
      threadedUpdate = {
        description = "(Readonly) bool\nThreaded update flag.",
        type = "value"
      },
      varNamesAttr = {
        description = "String",
        type = "value"
      },
      SaveXML = {
        args = "(File* dest)",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name of the scene node. Names are not required to be unique.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set position in parent space. If the scene node is on the root level (is child of the scene itself), this is same as world space.",
        returns = "()",
        type = "method"
      },
      SetPositionXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set rotation in parent space.",
        returns = "()",
        type = "method"
      },
      SetRotationXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetDirection = {
        args = "(const Vector3& direction)",
        description = "Set forward direction in parent space. Positive Z axis equals identity rotation.",
        returns = "()",
        type = "method"
      },
      SetDirectionXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(float scale)",
        description = "() SetScale (const Vector3& scale)\nSet uniform scale in parent space.",
        returns = "()",
        type = "method"
      },
      SetScaleXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "() SetTransform (const Vector3& position, const Quaternion& rotation, float scale),\n() SetTransform (const Vector3& position, const Quaternion& rotation, const Vector3& scale)\nSet both position and rotation in parent space as an atomic operation. This is faster than setting position and rotation separately.",
        returns = "()",
        type = "method"
      },
      SetWorldPosition = {
        args = "(const Vector3& position)",
        description = "Set position in world space.",
        returns = "()",
        type = "method"
      },
      SetWorldPositionXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetWorldRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set rotation in world space.",
        returns = "()",
        type = "method"
      },
      SetWorldRotationXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetWorldDirection = {
        args = "(const Vector3& direction)",
        description = "Set forward direction in world space.",
        returns = "()",
        type = "method"
      },
      SetWorldDirectionXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetWorldScale = {
        args = "(float scale)",
        description = "() SetWorldScale (const Vector3& scale)\nSet uniform scale in world space.",
        returns = "()",
        type = "method"
      },
      SetWorldScaleXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetWorldTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "() SetWorldTransform (const Vector3& position, const Quaternion& rotation, float scale),\n() SetWorldTransform (const Vector3& position, const Quaternion& rotation, const Vector3& scale)\nSet both position and rotation in world space as an atomic operation.",
        returns = "()",
        type = "method"
      },
      Translate = {
        args = "(const Vector3& delta)",
        description = "Move the scene node in parent space, which is the same as world space if the scene node is on the root level.",
        returns = "()",
        type = "method"
      },
      TranslateXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      TranslateRelative = {
        args = "(const Vector3& delta)",
        description = "Move the scene node in parent space relative to its current rotation.",
        returns = "()",
        type = "method"
      },
      TranslateRelativeXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      Rotate = {
        args = "(const Quaternion& delta, bool fixedAxis = false)",
        description = "Rotate the scene node in parent space either relative to its current rotation axes, or a fixed axis.",
        returns = "()",
        type = "method"
      },
      RotateXYZ = {
        args = "(float x, float y, float z, bool fixedAxis = false)",
        returns = "()",
        type = "method"
      },
      Pitch = {
        args = "(float angle, bool fixedAxis = false)",
        description = "Rotate around the X axis.",
        returns = "()",
        type = "method"
      },
      Yaw = {
        args = "(float angle, bool fixedAxis = false)",
        description = "Rotate around the Y axis.",
        returns = "()",
        type = "method"
      },
      Roll = {
        args = "(float angle, bool fixedAxis = false)",
        description = "Rotate around the Z axis.",
        returns = "()",
        type = "method"
      },
      LookAt = {
        args = "(const Vector3& target)",
        description = "() LookAt (const Vector3& target, const Vector3& upAxis)\nLook at a target world position.",
        returns = "()",
        type = "method"
      },
      LookAtXYZ = {
        args = "(float x, float y, float z, float upX = 0.0f, float upY = 1.0f, float upZ = 0.0f)",
        returns = "()",
        type = "method"
      },
      Scale = {
        args = "(float scale)",
        description = "() Scale (const Vector3& scale)\nModify scale in parent space uniformly.",
        returns = "()",
        type = "method"
      },
      ScaleXYZ = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "() SetEnabled (bool enable, bool recursive)\nSet enabled/disabled state without recursion. Components in a disabled node become effectively disabled regardless of their own enable/disable state.",
        returns = "()",
        type = "method"
      },
      SetOwner = {
        args = "(Connection* owner)",
        description = "Set owner connection for networking.",
        returns = "()",
        type = "method"
      },
      MarkDirty = {
        args = "()",
        description = "Mark node and child nodes to need world transform recalculation. Notify listener components.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0)",
        description = "(Node*) CreateChild (unsigned id, CreateMode mode)\nCreate a child scene node (with specified ID if provided).",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      AddChild = {
        args = "(Node* node)",
        description = "Add a child scene node.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(Node* node)",
        description = "Remove a child scene node.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child scene nodes.",
        returns = "()",
        type = "method"
      },
      RemoveChildren = {
        args = "(bool removeReplicated, bool removeLocal, bool recursive)",
        description = "Remove child scene nodes that match criteria.",
        returns = "()",
        type = "method"
      },
      RemoveComponent = {
        args = "(Component* component)",
        description = "() RemoveComponent (ShortStringHash type),\n() RemoveComponent (const String type)\nRemove a component from this node.",
        returns = "()",
        type = "method"
      },
      RemoveAllComponents = {
        args = "()",
        description = "Remove all components from this node.",
        returns = "()",
        type = "method"
      },
      RemoveComponents = {
        args = "(bool removeReplicated, bool removeLocal)",
        description = "Remove components that match criteria.",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(CreateMode mode = REPLICATED)",
        description = "Clone scene node, components and child nodes. Return the clone.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      SetParent = {
        args = "(Node* parent)",
        description = "Set parent scene node. Retains the world transform.",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      AddListener = {
        args = "(Component* component)",
        description = "Add listener component that is notified of node being dirtied. Can either be in the same node or another.",
        returns = "()",
        type = "method"
      },
      RemoveListener = {
        args = "(Component* component)",
        description = "Remove listener component.",
        returns = "()",
        type = "method"
      },
      CreateComponent = {
        args = "(const String type, CreateMode mode = REPLICATED, unsigned id = 0)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      CreateScriptObject = {
        args = "(const String scriptObjectType)",
        description = "(int) CreateScriptObject (const String fileName, const String scriptObjectType)",
        returns = "(int)",
        type = "method"
      },
      GetScriptObject = {
        args = "()",
        description = "(int) GetScriptObject (const String scriptObjectType)",
        returns = "(int)",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return scene.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled. Disables nodes effectively disable all their components.",
        returns = "(bool)",
        type = "method"
      },
      GetOwner = {
        args = "()",
        description = "Return owner connection in networking.",
        returns = "(Connection*)",
        valuetype = "Connection",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position in parent space.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetPositionXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return rotation in parent space.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetRotationXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetRotationWXYZ = {
        args = "(float w = 0.0f, float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetDirection = {
        args = "()",
        description = "Return forward direction in parent space. Positive Z axis equals identity rotation.",
        returns = "(Vector3)",
        type = "method"
      },
      GetDirectionXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetUp = {
        args = "()",
        description = "Return up direction in parent space. Positive Y axis equals identity rotation.",
        returns = "(Vector3)",
        type = "method"
      },
      GetUpXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetRight = {
        args = "()",
        description = "Return right direction in parent space. Positive X axis equals identity rotation.",
        returns = "(Vector3)",
        type = "method"
      },
      GetRightXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetScale = {
        args = "()",
        description = "Return scale in parent space.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetScaleXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetTransform = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      GetWorldPosition = {
        args = "()",
        description = "Return position in world space.",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldPositionXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldRotation = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      GetWorldRotationXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldRotationWXYZ = {
        args = "(float w = 0.0f, float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldDirection = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldDirectionXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldUp = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldUpXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldRight = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldRightXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldScale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldScaleXYZ = {
        args = "(float x = 0.0f, float y = 0.0f, float z = 0.0f)",
        returns = "()",
        type = "method"
      },
      GetWorldTransform = {
        args = "()",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      LocalToWorld = {
        args = "(const Vector3& position)",
        description = "(Vector3) LocalToWorld (const Vector4& vector)",
        returns = "(Vector3)",
        type = "method"
      },
      WorldToLocal = {
        args = "(const Vector3& position)",
        description = "(Vector3) WorldToLocal (const Vector4& vector)",
        returns = "(Vector3)",
        type = "method"
      },
      IsDirty = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(Node*) GetChild (StringHash nameHash, bool recursive = false),\n(Node*) GetChild (unsigned index)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetNumComponents = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumNetworkComponents = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      HasComponent = {
        args = "(ShortStringHash type)",
        description = "(bool) HasComponent (const String type)",
        returns = "(bool)",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      GetComponent = {
        args = "(const String type)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetID = {
        args = "(unsigned id)",
        returns = "()",
        type = "method"
      },
      SetScene = {
        args = "(Scene* scene)",
        returns = "()",
        type = "method"
      },
      ResetScene = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      LoadXML = {
        args = "(const XMLElement& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      AddComponent = {
        args = "(Component* component, unsigned id, CreateMode mode)",
        returns = "()",
        type = "method"
      },
      ID = {
        description = "unsigned",
        type = "value"
      },
      name = {
        description = "String",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      parent = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "Scene*",
        type = "value"
      },
      enabled = {
        description = "bool",
        type = "value"
      },
      owner = {
        valuetype = "Connection",
        description = "Connection*",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      rotation = {
        valuetype = "Quaternion",
        description = "Quaternion&",
        type = "value"
      },
      direction = {
        description = "Vector3",
        type = "value"
      },
      up = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      right = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      scale = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      transform = {
        description = "(Readonly) Matrix3x4",
        type = "value"
      },
      worldPosition = {
        description = "Vector3",
        type = "value"
      },
      worldRotation = {
        description = "Quaternion",
        type = "value"
      },
      worldDirection = {
        description = "Vector3",
        type = "value"
      },
      worldUp = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      worldRight = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      worldScale = {
        description = "Vector3",
        type = "value"
      },
      worldTransform = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&",
        type = "value"
      },
      dirty = {
        description = "(Readonly) bool",
        type = "value"
      },
      numComponents = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numNetworkComponents = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ScrollBar = {
    childs = {
      new = {
        args = "()",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetOrientation = {
        args = "(Orientation orientation)",
        description = "Set orientation type.",
        returns = "()",
        type = "method"
      },
      SetRange = {
        args = "(float range)",
        description = "Set slider range maximum value (minimum value is always 0.)",
        returns = "()",
        type = "method"
      },
      SetValue = {
        args = "(float value)",
        description = "Set slider current value.",
        returns = "()",
        type = "method"
      },
      ChangeValue = {
        args = "(float delta)",
        description = "Change slider current value by a delta.",
        returns = "()",
        type = "method"
      },
      SetScrollStep = {
        args = "(float step)",
        description = "Set button scroll step.",
        returns = "()",
        type = "method"
      },
      SetStepFactor = {
        args = "(float factor)",
        description = "Set button step factor, can be used to adjust the step for constant pixel size.",
        returns = "()",
        type = "method"
      },
      StepBack = {
        args = "()",
        description = "Scroll back one step.",
        returns = "()",
        type = "method"
      },
      StepForward = {
        args = "()",
        description = "Scroll forward one step.",
        returns = "()",
        type = "method"
      },
      GetOrientation = {
        args = "()",
        description = "Return scrollbar orientation.",
        returns = "(Orientation)",
        type = "method"
      },
      GetRange = {
        args = "()",
        description = "Return slider range.",
        returns = "(float)",
        type = "method"
      },
      GetValue = {
        args = "()",
        description = "Return slider current value.",
        returns = "(float)",
        type = "method"
      },
      GetScrollStep = {
        args = "()",
        description = "Return button scroll step.",
        returns = "(float)",
        type = "method"
      },
      GetStepFactor = {
        args = "()",
        description = "Return button step factor.",
        returns = "(float)",
        type = "method"
      },
      GetEffectiveScrollStep = {
        args = "()",
        description = "Return scroll step multiplied by factor.",
        returns = "(float)",
        type = "method"
      },
      GetBackButton = {
        args = "()",
        description = "Return back button element.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetForwardButton = {
        args = "()",
        description = "Return forward button element.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetSlider = {
        args = "()",
        description = "Return slider element.",
        returns = "(Slider*)",
        valuetype = "Slider",
        type = "method"
      },
      orientation = {
        description = "Orientation",
        type = "value"
      },
      range = {
        description = "float",
        type = "value"
      },
      value = {
        description = "float",
        type = "value"
      },
      scrollStep = {
        description = "float\nScroll step.",
        type = "value"
      },
      stepFactor = {
        description = "float\nStep factor.",
        type = "value"
      },
      effectiveScrollStep = {
        description = "(Readonly) float",
        type = "value"
      },
      backButton = {
        valuetype = "Button",
        description = "(Readonly) Button*\nBack button.",
        type = "value"
      },
      forwardButton = {
        valuetype = "Button",
        description = "(Readonly) Button*\nForward button.",
        type = "value"
      },
      slider = {
        valuetype = "Slider",
        description = "(Readonly) Slider*\nSlider.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ScrollView = {
    childs = {
      new = {
        args = "()",
        returns = "(ScrollView*)",
        valuetype = "ScrollView",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetContentElement = {
        args = "(UIElement* element)",
        description = "Set content element.",
        returns = "()",
        type = "method"
      },
      SetViewPosition = {
        args = "(const IntVector2& position)",
        description = "() SetViewPosition (int x, int y)\nSet view offset from the top-left corner.",
        returns = "()",
        type = "method"
      },
      SetScrollBarsVisible = {
        args = "(bool horizontal, bool vertical)",
        description = "Set scrollbars' visibility manually. Disables scrollbar autoshow/hide.",
        returns = "()",
        type = "method"
      },
      SetScrollBarsAutoVisible = {
        args = "(bool enable)",
        description = "Set whether to automatically show/hide scrollbars. Default true.",
        returns = "()",
        type = "method"
      },
      SetScrollStep = {
        args = "(float step)",
        description = "Set arrow key scroll step. Also sets it on the scrollbars.",
        returns = "()",
        type = "method"
      },
      SetPageStep = {
        args = "(float step)",
        description = "Set arrow key page step.",
        returns = "()",
        type = "method"
      },
      GetViewPosition = {
        args = "()",
        description = "Return view offset from the top-left corner.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetContentElement = {
        args = "()",
        description = "Return content element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetHorizontalScrollBar = {
        args = "()",
        description = "Return horizontal scroll bar.",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      GetVerticalScrollBar = {
        args = "()",
        description = "Return vertical scroll bar.",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      GetScrollPanel = {
        args = "()",
        description = "Return scroll panel.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      GetScrollBarsAutoVisible = {
        args = "()",
        description = "Return whether scrollbars are automatically shown/hidden.",
        returns = "(bool)",
        type = "method"
      },
      GetScrollStep = {
        args = "()",
        description = "Return arrow key scroll step.",
        returns = "(float)",
        type = "method"
      },
      GetPageStep = {
        args = "()",
        description = "Return arrow key page step.",
        returns = "(float)",
        type = "method"
      },
      viewPosition = {
        valuetype = "IntVector2",
        description = "IntVector2&\nCurrent view offset from the top-left corner.",
        type = "value"
      },
      contentElement = {
        valuetype = "UIElement",
        description = "UIElement*\nContent element.",
        type = "value"
      },
      horizontalScrollBar = {
        valuetype = "ScrollBar",
        description = "(Readonly) ScrollBar*\nHorizontal scroll bar.",
        type = "value"
      },
      verticalScrollBar = {
        valuetype = "ScrollBar",
        description = "(Readonly) ScrollBar*\nVertical scroll bar.",
        type = "value"
      },
      scrollPanel = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nScroll panel element.",
        type = "value"
      },
      scrollBarsAutoVisible = {
        description = "bool\nAutomatically show/hide scrollbars flag.",
        type = "value"
      },
      scrollStep = {
        description = "float",
        type = "value"
      },
      pageStep = {
        description = "float\nArrow key page step.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Serializable = {
    childs = {
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Serializer = {
    childs = {
      Write = {
        args = "(const VectorBuffer& buffer)",
        returns = "(unsigned)",
        type = "method"
      },
      WriteInt = {
        args = "(int value)",
        description = "Write a 32-bit integer.",
        returns = "(bool)",
        type = "method"
      },
      WriteShort = {
        args = "(short value)",
        description = "Write a 16-bit integer.",
        returns = "(bool)",
        type = "method"
      },
      WriteByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt = {
        args = "(unsigned value)",
        description = "Write a 32-bit unsigned integer.",
        returns = "(bool)",
        type = "method"
      },
      WriteUShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBool = {
        args = "(bool value)",
        description = "Write a bool.",
        returns = "(bool)",
        type = "method"
      },
      WriteFloat = {
        args = "(float value)",
        description = "Write a float.",
        returns = "(bool)",
        type = "method"
      },
      WriteIntRect = {
        args = "(const IntRect& value)",
        description = "Write an IntRect.",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector2 = {
        args = "(const IntVector2& value)",
        description = "Write an IntVector2.",
        returns = "(bool)",
        type = "method"
      },
      WriteRect = {
        args = "(const Rect& value)",
        description = "Write a Rect.",
        returns = "(bool)",
        type = "method"
      },
      WriteVector2 = {
        args = "(const Vector2& value)",
        description = "Write a Vector2.",
        returns = "(bool)",
        type = "method"
      },
      WriteVector3 = {
        args = "(const Vector3& value)",
        description = "Write a Vector3.",
        returns = "(bool)",
        type = "method"
      },
      WritePackedVector3 = {
        args = "(const Vector3& value, float maxAbsCoord)",
        description = "Write a Vector3 packed into 3 x 16 bits with the specified maximum absolute range.",
        returns = "(bool)",
        type = "method"
      },
      WriteVector4 = {
        args = "(const Vector4& value)",
        description = "Write a Vector4.",
        returns = "(bool)",
        type = "method"
      },
      WriteQuaternion = {
        args = "(const Quaternion& value)",
        description = "Write a quaternion.",
        returns = "(bool)",
        type = "method"
      },
      WritePackedQuaternion = {
        args = "(const Quaternion& value)",
        description = "Write a quaternion with each component packed in 16 bits.",
        returns = "(bool)",
        type = "method"
      },
      WriteColor = {
        args = "(const Color& value)",
        description = "Write a color.",
        returns = "(bool)",
        type = "method"
      },
      WriteBoundingBox = {
        args = "(const BoundingBox& value)",
        description = "Write a bounding box.",
        returns = "(bool)",
        type = "method"
      },
      WriteString = {
        args = "(const String value)",
        description = "Write a null-terminated string.",
        returns = "(bool)",
        type = "method"
      },
      WriteFileID = {
        args = "(const String value)",
        description = "Write a four-letter file ID. If the string is not long enough, spaces will be appended.",
        returns = "(bool)",
        type = "method"
      },
      WriteStringHash = {
        args = "(const StringHash& value)",
        description = "Write a 32-bit StringHash.",
        returns = "(bool)",
        type = "method"
      },
      WriteShortStringHash = {
        args = "(const ShortStringHash& value)",
        description = "Write a 16-bit ShortStringHash.",
        returns = "(bool)",
        type = "method"
      },
      WriteBuffer = {
        args = "(const VectorBuffer& buffer)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRef = {
        args = "(const ResourceRef& value)",
        description = "Write a resource reference.",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRefList = {
        args = "(const ResourceRefList& value)",
        description = "Write a resource reference list.",
        returns = "(bool)",
        type = "method"
      },
      WriteVariant = {
        args = "(const Variant& value)",
        description = "Write a variant.",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantData = {
        args = "(const Variant& value)",
        description = "Write a variant without the type information.",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantVector = {
        args = "(const VariantVector& value)",
        description = "Write a variant vector.",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantMap = {
        args = "(const VariantMap& value)",
        description = "Write a variant map.",
        returns = "(bool)",
        type = "method"
      },
      WriteVLE = {
        args = "(unsigned value)",
        description = "Write a variable-length encoded unsigned integer, which can use 29 bits maximum.",
        returns = "(bool)",
        type = "method"
      },
      WriteNetID = {
        args = "(unsigned value)",
        description = "Write a 24-bit network object ID.",
        returns = "(bool)",
        type = "method"
      },
      WriteLine = {
        args = "(const String value)",
        description = "Write a text line. Char codes 13 & 10 will be automatically appended.",
        returns = "(bool)",
        type = "method"
      },
    },
    type = "class"
  },
  ShortStringHash = {
    childs = {
      new = {
        args = "()",
        description = "(ShortStringHash*) new (const ShortStringHash& rhs),\n(ShortStringHash*) new (const StringHash& rhs),\n(ShortStringHash*) new (short value),\n(ShortStringHash*) new (const String str)",
        returns = "(ShortStringHash*)",
        valuetype = "ShortStringHash",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Value = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      Calculate = {
        args = "(const char* str)",
        returns = "(short)",
        type = "method"
      },
      ZERO = {
        description = "const ShortStringHash",
        type = "value"
      },
      value = {
        description = "(Readonly) short",
        type = "value"
      },
    },
    type = "class"
  },
  Skeleton = {
    childs = {
      GetNumBones = {
        args = "()",
        description = "Return number of bones.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRootBone = {
        args = "()",
        description = "Return root bone.",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      GetBone = {
        args = "(const String name)",
        description = "(Bone*) GetBone (unsigned index)\nReturn bone by name.",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      numBones = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      rootBone = {
        valuetype = "Bone",
        description = "(Readonly) Bone*",
        type = "value"
      },
    },
    type = "class"
  },
  Skybox = {
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "(bool) SetMaterial (unsigned index, Material* material)\nSet material on all geometries.",
        returns = "()",
        type = "method"
      },
      SetOcclusionLodLevel = {
        args = "(unsigned level)",
        description = "Set occlusion LOD level. By default (M_MAX_UNSIGNED) same as visible.",
        returns = "()",
        type = "method"
      },
      ApplyMaterialList = {
        args = "(const String fileName = String::EMPTY)",
        description = "Apply default materials from a material list file. If filename is empty (default), the model's resource name with extension .txt will be used.",
        returns = "()",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaterial = {
        args = "(unsigned index = 0)",
        description = "Return material by geometry index.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetOcclusionLodLevel = {
        args = "()",
        description = "Return occlusion LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Determines if the given world space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideLocal = {
        args = "(const Vector3& point)",
        description = "Determines if the given local space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      numGeometries = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      occlusionLodLevel = {
        description = "unsigned\nOcclusion LOD level.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    type = "class"
  },
  Slider = {
    childs = {
      new = {
        args = "()",
        returns = "(Slider*)",
        valuetype = "Slider",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetOrientation = {
        args = "(Orientation orientation)",
        description = "Set orientation type.",
        returns = "()",
        type = "method"
      },
      SetRange = {
        args = "(float range)",
        description = "Set slider range maximum value (minimum value is always 0.)",
        returns = "()",
        type = "method"
      },
      SetValue = {
        args = "(float value)",
        description = "Set slider current value.",
        returns = "()",
        type = "method"
      },
      ChangeValue = {
        args = "(float delta)",
        description = "Change value by a delta.",
        returns = "()",
        type = "method"
      },
      SetRepeatRate = {
        args = "(float rate)",
        description = "Set paging minimum repeat rate (number of events per second).",
        returns = "()",
        type = "method"
      },
      GetOrientation = {
        args = "()",
        description = "Return orientation type.",
        returns = "(Orientation)",
        type = "method"
      },
      GetRange = {
        args = "()",
        description = "Return slider range.",
        returns = "(float)",
        type = "method"
      },
      GetValue = {
        args = "()",
        description = "Return slider current value.",
        returns = "(float)",
        type = "method"
      },
      GetKnob = {
        args = "()",
        description = "Return knob element.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      GetRepeatRate = {
        args = "()",
        description = "Return paging minimum repeat rate (number of events per second).",
        returns = "(float)",
        type = "method"
      },
      orientation = {
        description = "Orientation\nOrientation.",
        type = "value"
      },
      range = {
        description = "float\nSlider range.",
        type = "value"
      },
      value = {
        description = "float\nSlider current value.",
        type = "value"
      },
      knob = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nSlider knob.",
        type = "value"
      },
      repeatRate = {
        description = "float\nPaging repeat rate.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Sound = {
    childs = {
      new = {
        args = "()",
        returns = "(Sound*)",
        valuetype = "Sound",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      LoadRaw = {
        args = "(Deserializer& source)",
        description = "(bool) LoadRaw (const String fileName)\nLoad raw sound data.",
        returns = "(bool)",
        type = "method"
      },
      LoadWav = {
        args = "(Deserializer& source)",
        description = "(bool) LoadWav (const String fileName)\nLoad WAV format sound data.",
        returns = "(bool)",
        type = "method"
      },
      LoadOggVorbis = {
        args = "(Deserializer& source)",
        description = "(bool) LoadOggVorbis (const String fileName)\nLoad Ogg Vorbis format sound data. Does not decode at load, but will rather be decoded while playing.",
        returns = "(bool)",
        type = "method"
      },
      SetSize = {
        args = "(unsigned dataSize)",
        description = "Set sound size in bytes. Also resets the sound to be uncompressed and one-shot.",
        returns = "()",
        type = "method"
      },
      SetData = {
        args = "(const void* data, unsigned dataSize)",
        returns = "()",
        type = "method"
      },
      SetFormat = {
        args = "(unsigned frequency, bool sixteenBit, bool stereo)",
        description = "Set uncompressed sound data format.",
        returns = "()",
        type = "method"
      },
      SetLooped = {
        args = "(bool enable)",
        description = "Set loop on/off. If loop is enabled, sets the full sound as loop range.",
        returns = "()",
        type = "method"
      },
      SetLoop = {
        args = "(unsigned repeatOffset, unsigned endOffset)",
        description = "Define loop.",
        returns = "()",
        type = "method"
      },
      FixInterpolation = {
        args = "()",
        description = "Fix interpolation by copying data from loop start to loop end (looped), or adding silence (oneshot.)",
        returns = "()",
        type = "method"
      },
      GetLength = {
        args = "()",
        description = "Return length in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetDataSize = {
        args = "()",
        description = "Return total sound data size.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSampleSize = {
        args = "()",
        description = "Return sample size.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFrequency = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetIntFrequency = {
        args = "()",
        description = "Return default frequency as an integer.",
        returns = "(unsigned)",
        type = "method"
      },
      IsLooped = {
        args = "()",
        description = "Return whether is looped.",
        returns = "(bool)",
        type = "method"
      },
      IsSixteenBit = {
        args = "()",
        description = "Return whether data is sixteen bit.",
        returns = "(bool)",
        type = "method"
      },
      IsStereo = {
        args = "()",
        description = "Return whether data is stereo.",
        returns = "(bool)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether is compressed in Ogg Vorbis format.",
        returns = "(bool)",
        type = "method"
      },
      length = {
        description = "(Readonly) float",
        type = "value"
      },
      dataSize = {
        description = "(Readonly) unsigned\nSound data size in bytes.",
        type = "value"
      },
      sampleSize = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      frequency = {
        description = "(Readonly) float\nDefault frequency.",
        type = "value"
      },
      intFrequency = {
        description = "(Readonly) int",
        type = "value"
      },
      looped = {
        description = "bool\nLooped flag.",
        type = "value"
      },
      sixteenBit = {
        description = "(Readonly) bool\nSixteen bit flag.",
        type = "value"
      },
      stereo = {
        description = "(Readonly) bool\nStereo flag.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool\nCompressed flag.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  SoundListener = {
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    type = "class"
  },
  SoundSource = {
    childs = {
      Play = {
        args = "(Sound* sound)",
        description = "() Play (Sound* sound, float frequency),\n() Play (Sound* sound, float frequency, float gain),\n() Play (Sound* sound, float frequency, float gain, float panning)\nPlay a sound.",
        returns = "()",
        type = "method"
      },
      Stop = {
        args = "()",
        description = "Stop playback.",
        returns = "()",
        type = "method"
      },
      SetSoundType = {
        args = "(SoundType type)",
        description = "Set sound type, determines the master gain group.",
        returns = "()",
        type = "method"
      },
      SetFrequency = {
        args = "(float frequency)",
        description = "Set frequency.",
        returns = "()",
        type = "method"
      },
      SetGain = {
        args = "(float gain)",
        description = "Set gain. 0.0 is silence, 1.0 is full volume.",
        returns = "()",
        type = "method"
      },
      SetAttenuation = {
        args = "(float attenuation)",
        description = "Set attenuation. 1.0 is unaltered. Used for distance attenuated playback.",
        returns = "()",
        type = "method"
      },
      SetPanning = {
        args = "(float panning)",
        description = "Set stereo panning. -1.0 is full left and 1.0 is full right.",
        returns = "()",
        type = "method"
      },
      SetAutoRemove = {
        args = "(bool enable)",
        description = "Set whether sound source will be automatically removed from the scene node when playback stops.",
        returns = "()",
        type = "method"
      },
      GetSound = {
        args = "()",
        description = "Return sound.",
        returns = "(Sound*)",
        valuetype = "Sound",
        type = "method"
      },
      GetSoundType = {
        args = "()",
        description = "Return sound type, determines the master gain group.",
        returns = "(SoundType)",
        type = "method"
      },
      GetTimePosition = {
        args = "()",
        description = "Return playback time position.",
        returns = "(float)",
        type = "method"
      },
      GetFrequency = {
        args = "()",
        description = "Return frequency.",
        returns = "(float)",
        type = "method"
      },
      GetGain = {
        args = "()",
        description = "Return gain.",
        returns = "(float)",
        type = "method"
      },
      GetAttenuation = {
        args = "()",
        description = "Return attenuation.",
        returns = "(float)",
        type = "method"
      },
      GetPanning = {
        args = "()",
        description = "Return stereo panning.",
        returns = "(float)",
        type = "method"
      },
      GetAutoRemove = {
        args = "()",
        description = "Return autoremove mode.",
        returns = "(bool)",
        type = "method"
      },
      IsPlaying = {
        args = "()",
        description = "Return whether is playing.",
        returns = "(bool)",
        type = "method"
      },
      PlayLockless = {
        args = "(Sound* sound)",
        description = "Play a sound without locking the audio mutex. Called internally.",
        returns = "()",
        type = "method"
      },
      StopLockless = {
        args = "()",
        description = "Stop sound without locking the audio mutex. Called internally.",
        returns = "()",
        type = "method"
      },
      sound = {
        valuetype = "Sound",
        description = "(Readonly) Sound*\nSound.",
        type = "value"
      },
      soundType = {
        description = "SoundType\nSoundSource type, determines the master gain group.",
        type = "value"
      },
      timePosition = {
        description = "(Readonly) float\nPlayback time position.",
        type = "value"
      },
      frequency = {
        description = "float\nFrequency.",
        type = "value"
      },
      gain = {
        description = "float\nGain.",
        type = "value"
      },
      attenuation = {
        description = "float\nAttenuation.",
        type = "value"
      },
      panning = {
        description = "float\nStereo panning.",
        type = "value"
      },
      autoRemove = {
        description = "bool\nAutoremove flag.",
        type = "value"
      },
      playing = {
        description = "(Readonly) bool",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  SoundSource3D = {
    childs = {
      SetDistanceAttenuation = {
        args = "(float nearDistance, float farDistance, float rolloffFactor)",
        description = "Set attenuation parameters.",
        returns = "()",
        type = "method"
      },
      SetAngleAttenuation = {
        args = "(float innerAngle, float outerAngle)",
        description = "Set angle attenuation parameters.",
        returns = "()",
        type = "method"
      },
      SetNearDistance = {
        args = "(float distance)",
        description = "Set near distance. Inside this range sound will not be attenuated.",
        returns = "()",
        type = "method"
      },
      SetFarDistance = {
        args = "(float distance)",
        description = "Set far distance. Outside this range sound will be completely attenuated.",
        returns = "()",
        type = "method"
      },
      SetInnerAngle = {
        args = "(float angle)",
        description = "Set inner angle in degrees. Inside this angle sound will not be attenuated.By default 360, meaning direction never has an effect.",
        returns = "()",
        type = "method"
      },
      SetOuterAngle = {
        args = "(float angle)",
        description = "Set outer angle in degrees. Outside this angle sound will be completely attenuated. By default 360, meaning direction never has an effect.",
        returns = "()",
        type = "method"
      },
      SetRolloffFactor = {
        args = "(float factor)",
        description = "Set rolloff power factor, defines attenuation function shape.",
        returns = "()",
        type = "method"
      },
      CalculateAttenuation = {
        args = "()",
        description = "Calculate attenuation and panning based on current position and listener position.",
        returns = "()",
        type = "method"
      },
      GetNearDistance = {
        args = "()",
        description = "Return near distance.",
        returns = "(float)",
        type = "method"
      },
      GetFarDistance = {
        args = "()",
        description = "Return far distance.",
        returns = "(float)",
        type = "method"
      },
      GetInnerAngle = {
        args = "()",
        description = "Return inner angle in degrees.",
        returns = "(float)",
        type = "method"
      },
      GetOuterAngle = {
        args = "()",
        description = "Return outer angle in degrees.",
        returns = "(float)",
        type = "method"
      },
      RollAngleoffFactor = {
        args = "()",
        description = "Return rolloff power factor.",
        returns = "(float)",
        type = "method"
      },
      nearDistance = {
        description = "float\nNear distance.",
        type = "value"
      },
      farDistance = {
        description = "float\nFar distance.",
        type = "value"
      },
      innerAngle = {
        description = "float\nInner angle for directional attenuation.",
        type = "value"
      },
      outerAngle = {
        description = "float\nOuter angle for directional attenuation.",
        type = "value"
      },
      rolloffFactor = {
        description = "float\nRolloff power factor.",
        type = "value"
      },
      Play = {
        args = "(Sound* sound)",
        description = "() Play (Sound* sound, float frequency),\n() Play (Sound* sound, float frequency, float gain),\n() Play (Sound* sound, float frequency, float gain, float panning)\nPlay a sound.",
        returns = "()",
        type = "method"
      },
      Stop = {
        args = "()",
        description = "Stop playback.",
        returns = "()",
        type = "method"
      },
      SetSoundType = {
        args = "(SoundType type)",
        description = "Set sound type, determines the master gain group.",
        returns = "()",
        type = "method"
      },
      SetFrequency = {
        args = "(float frequency)",
        description = "Set frequency.",
        returns = "()",
        type = "method"
      },
      SetGain = {
        args = "(float gain)",
        description = "Set gain. 0.0 is silence, 1.0 is full volume.",
        returns = "()",
        type = "method"
      },
      SetAttenuation = {
        args = "(float attenuation)",
        description = "Set attenuation. 1.0 is unaltered. Used for distance attenuated playback.",
        returns = "()",
        type = "method"
      },
      SetPanning = {
        args = "(float panning)",
        description = "Set stereo panning. -1.0 is full left and 1.0 is full right.",
        returns = "()",
        type = "method"
      },
      SetAutoRemove = {
        args = "(bool enable)",
        description = "Set whether sound source will be automatically removed from the scene node when playback stops.",
        returns = "()",
        type = "method"
      },
      GetSound = {
        args = "()",
        description = "Return sound.",
        returns = "(Sound*)",
        valuetype = "Sound",
        type = "method"
      },
      GetSoundType = {
        args = "()",
        description = "Return sound type, determines the master gain group.",
        returns = "(SoundType)",
        type = "method"
      },
      GetTimePosition = {
        args = "()",
        description = "Return playback time position.",
        returns = "(float)",
        type = "method"
      },
      GetFrequency = {
        args = "()",
        description = "Return frequency.",
        returns = "(float)",
        type = "method"
      },
      GetGain = {
        args = "()",
        description = "Return gain.",
        returns = "(float)",
        type = "method"
      },
      GetAttenuation = {
        args = "()",
        description = "Return attenuation.",
        returns = "(float)",
        type = "method"
      },
      GetPanning = {
        args = "()",
        description = "Return stereo panning.",
        returns = "(float)",
        type = "method"
      },
      GetAutoRemove = {
        args = "()",
        description = "Return autoremove mode.",
        returns = "(bool)",
        type = "method"
      },
      IsPlaying = {
        args = "()",
        description = "Return whether is playing.",
        returns = "(bool)",
        type = "method"
      },
      PlayLockless = {
        args = "(Sound* sound)",
        description = "Play a sound without locking the audio mutex. Called internally.",
        returns = "()",
        type = "method"
      },
      StopLockless = {
        args = "()",
        description = "Stop sound without locking the audio mutex. Called internally.",
        returns = "()",
        type = "method"
      },
      sound = {
        valuetype = "Sound",
        description = "(Readonly) Sound*\nSound.",
        type = "value"
      },
      soundType = {
        description = "SoundType\nSoundSource type, determines the master gain group.",
        type = "value"
      },
      timePosition = {
        description = "(Readonly) float\nPlayback time position.",
        type = "value"
      },
      frequency = {
        description = "float\nFrequency.",
        type = "value"
      },
      gain = {
        description = "float\nGain.",
        type = "value"
      },
      attenuation = {
        description = "float\nAttenuation.",
        type = "value"
      },
      panning = {
        description = "float\nStereo panning.",
        type = "value"
      },
      autoRemove = {
        description = "bool\nAutoremove flag.",
        type = "value"
      },
      playing = {
        description = "(Readonly) bool",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Sphere = {
    childs = {
      new = {
        args = "()",
        description = "(Sphere*) new (const Sphere& sphere),\n(Sphere*) new (const Vector3& center, float radius),\n(Sphere*) new (const BoundingBox& box),\n(Sphere*) new (const Frustum& frustum),\n(Sphere*) new (const Polyhedron& poly)",
        returns = "(Sphere*)",
        valuetype = "Sphere",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const Sphere& sphere)",
        description = "() Define (const Vector3& center, float radius),\n() Define (const BoundingBox& box),\n() Define (const Frustum& frustum),\n() Define (const Polyhedron& poly)",
        returns = "()",
        type = "method"
      },
      Merge = {
        args = "(const Vector3& point)",
        description = "() Merge (const BoundingBox& box),\n() Merge (const Frustum& frustum),\n() Merge (const Polyhedron& poly),\n() Merge (const Sphere& sphere)",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "(Intersection) IsInside (const Sphere& sphere),\n(Intersection) IsInside (const BoundingBox& box)",
        returns = "(Intersection)",
        type = "method"
      },
      IsInsideFast = {
        args = "(const Sphere& sphere)",
        description = "(Intersection) IsInsideFast (const BoundingBox& box)",
        returns = "(Intersection)",
        type = "method"
      },
      Distance = {
        args = "(const Vector3& point)",
        returns = "(float)",
        type = "method"
      },
      center = {
        description = "Vector3",
        type = "value"
      },
      radius = {
        description = "float",
        type = "value"
      },
      defined = {
        description = "bool",
        type = "value"
      },
    },
    type = "class"
  },
  Spline = {
    childs = {
      SetInterpolationMode = {
        args = "(InterpolationMode interpolationMode)",
        description = "Set the Interpolation Mode.",
        returns = "()",
        type = "method"
      },
      SetSpeed = {
        args = "(float speed)",
        description = "Set the movement Speed.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(float factor)",
        description = "Set the parent node's position on the Spline.",
        returns = "()",
        type = "method"
      },
      GetInterpolationMode = {
        args = "()",
        description = "Get the Interpolation Mode.",
        returns = "(InterpolationMode)",
        type = "method"
      },
      GetSpeed = {
        args = "()",
        description = "Get the movement Speed.",
        returns = "(float)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Get the parent node's last position on the spline.",
        returns = "(Vector3)",
        type = "method"
      },
      Push = {
        args = "(const Vector3& controlPoint)",
        description = "Add a Control Point to the end.",
        returns = "()",
        type = "method"
      },
      Pop = {
        args = "()",
        description = "Remove a Control Point from the end.",
        returns = "()",
        type = "method"
      },
      GetPoint = {
        args = "(float factor)",
        description = "Get a point on the spline from 0.f to 1.f where 0 is the start and 1 is the end.",
        returns = "(Vector3)",
        type = "method"
      },
      Move = {
        args = "(float timeStep)",
        description = "Move the parent node to the next position along the Spline based off the Speed value.",
        returns = "()",
        type = "method"
      },
      Reset = {
        args = "()",
        description = "Reset movement along the path.",
        returns = "()",
        type = "method"
      },
      IsFinished = {
        args = "()",
        description = "Returns whether the movement along the Spline complete.",
        returns = "(bool)",
        type = "method"
      },
      interpolationMode = {
        description = "InterpolationMode\nThe Interpolation Mode of the Spline.",
        type = "value"
      },
      speed = {
        description = "float\nThe Speed of movement along the Spline.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Sprite = {
    childs = {
      new = {
        args = "()",
        returns = "(Sprite*)",
        valuetype = "Sprite",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector2& position)",
        description = "() SetPosition (float x, float y)\nSet floating point position.",
        returns = "()",
        type = "method"
      },
      SetHotSpot = {
        args = "(const IntVector2& hotSpot)",
        description = "() SetHotSpot (int x, int y)\nSet hotspot for positioning and rotation.",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(const Vector2& scale)",
        description = "() SetScale (float x, float y),\n() SetScale (float scale)\nSet scale. Scale also affects child sprites.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(float angle)",
        description = "Set rotation angle.",
        returns = "()",
        type = "method"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return floating point position.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetHotSpot = {
        args = "()",
        description = "Return hotspot.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetScale = {
        args = "()",
        description = "Return scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return rotation angle.",
        returns = "(float)",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      GetTransform = {
        args = "()",
        description = "Update and return rendering transform, also used to transform child sprites.",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      position = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      hotSpot = {
        valuetype = "IntVector2",
        description = "IntVector2&\nHotspot for positioning and rotation.",
        type = "value"
      },
      scale = {
        valuetype = "Vector2",
        description = "Vector2&\nScale.",
        type = "value"
      },
      rotation = {
        description = "float\nRotation angle.",
        type = "value"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      transform = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&\nTransform matrix.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Sprite2D = {
    childs = {
      SetTexture = {
        args = "(Texture2D* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetRectangle = {
        args = "(const IntRect& rectangle)",
        description = "Set rectangle.",
        returns = "()",
        type = "method"
      },
      SetHotSpot = {
        args = "(const Vector2& hotSpot)",
        description = "Set hot spot.",
        returns = "()",
        type = "method"
      },
      SetSpriteSheet = {
        args = "(SpriteSheet2D* spriteSheet)",
        description = "Set sprite sheet.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetRectangle = {
        args = "()",
        description = "Return rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHotSpot = {
        args = "()",
        description = "Return hot spot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetSpriteSheet = {
        args = "()",
        description = "Return sprite sheet.",
        returns = "(SpriteSheet2D*)",
        valuetype = "SpriteSheet2D",
        type = "method"
      },
      texture = {
        valuetype = "Texture2D",
        description = "Texture2D*\nTexture.",
        type = "value"
      },
      rectangle = {
        description = "IntRect\nRectangle.",
        type = "value"
      },
      hotSpot = {
        description = "Vector2\nHot spot.",
        type = "value"
      },
      spriteSheet = {
        valuetype = "SpriteSheet2D",
        description = "SpriteSheet2D*\nSprite sheet.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  SpriteSheet2D = {
    childs = {
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetSprite = {
        args = "(const String name)",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      DefineSprite = {
        args = "(const String name, const IntRect& rectangle)",
        description = "() DefineSprite (const String name, const IntRect& rectangle, const Vector2& hotSpot)",
        returns = "()",
        type = "method"
      },
      UpdateSprite = {
        args = "(const String name, const IntRect& rectangle)",
        description = "() UpdateSprite (const String name, const IntRect& rectangle, const Vector2& hotSpot)",
        returns = "()",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  StaticModel = {
    childs = {
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "(bool) SetMaterial (unsigned index, Material* material)\nSet material on all geometries.",
        returns = "()",
        type = "method"
      },
      SetOcclusionLodLevel = {
        args = "(unsigned level)",
        description = "Set occlusion LOD level. By default (M_MAX_UNSIGNED) same as visible.",
        returns = "()",
        type = "method"
      },
      ApplyMaterialList = {
        args = "(const String fileName = String::EMPTY)",
        description = "Apply default materials from a material list file. If filename is empty (default), the model's resource name with extension .txt will be used.",
        returns = "()",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaterial = {
        args = "(unsigned index = 0)",
        description = "Return material by geometry index.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetOcclusionLodLevel = {
        args = "()",
        description = "Return occlusion LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Determines if the given world space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideLocal = {
        args = "(const Vector3& point)",
        description = "Determines if the given local space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      numGeometries = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      occlusionLodLevel = {
        description = "unsigned\nOcclusion LOD level.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  StaticModelGeometryData = {
    childs = {
      center = {
        description = "Vector3",
        type = "value"
      },
      lodLevel = {
        description = "unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  StaticModelGroup = {
    childs = {
      AddInstanceNode = {
        args = "(Node* node)",
        description = "Add an instance scene node. It does not need any drawable components of its own.",
        returns = "()",
        type = "method"
      },
      RemoveInstanceNode = {
        args = "(Node* node)",
        description = "Remove an instance scene node.",
        returns = "()",
        type = "method"
      },
      RemoveAllInstanceNodes = {
        args = "()",
        description = "Remove all instance scene nodes.",
        returns = "()",
        type = "method"
      },
      GetNumInstanceNodes = {
        args = "()",
        description = "Return number of instance nodes.",
        returns = "(unsigned)",
        type = "method"
      },
      GetInstanceNode = {
        args = "(unsigned index)",
        description = "Return instance node by index.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      numInstanceNodes = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "(bool) SetMaterial (unsigned index, Material* material)\nSet material on all geometries.",
        returns = "()",
        type = "method"
      },
      SetOcclusionLodLevel = {
        args = "(unsigned level)",
        description = "Set occlusion LOD level. By default (M_MAX_UNSIGNED) same as visible.",
        returns = "()",
        type = "method"
      },
      ApplyMaterialList = {
        args = "(const String fileName = String::EMPTY)",
        description = "Apply default materials from a material list file. If filename is empty (default), the model's resource name with extension .txt will be used.",
        returns = "()",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaterial = {
        args = "(unsigned index = 0)",
        description = "Return material by geometry index.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetOcclusionLodLevel = {
        args = "()",
        description = "Return occlusion LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Determines if the given world space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideLocal = {
        args = "(const Vector3& point)",
        description = "Determines if the given local space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      numGeometries = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      occlusionLodLevel = {
        description = "unsigned\nOcclusion LOD level.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  StaticSprite2D = {
    childs = {
      SetFlip = {
        args = "(bool flipX, bool flipY)",
        description = "Set flip.",
        returns = "()",
        type = "method"
      },
      SetFlipX = {
        args = "(bool flipX)",
        description = "Set flip X.",
        returns = "()",
        type = "method"
      },
      SetFlipY = {
        args = "(bool flipY)",
        description = "Set flip Y.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "Set color.",
        returns = "()",
        type = "method"
      },
      GetFlipX = {
        args = "()",
        description = "Return flip X.",
        returns = "(bool)",
        type = "method"
      },
      GetFlipY = {
        args = "()",
        description = "Return flip Y.",
        returns = "(bool)",
        type = "method"
      },
      GetColor = {
        args = "()",
        description = "Return color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      flipX = {
        description = "bool\nFlip X.",
        type = "value"
      },
      flipY = {
        description = "bool\nFlip Y.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColor.",
        type = "value"
      },
      SetPixelsPerUnit = {
        args = "(float pixelsPerUnit)",
        description = "Set pixels per coordinate unit.",
        returns = "()",
        type = "method"
      },
      SetSprite = {
        args = "(Sprite2D* sprite)",
        description = "Set sprite.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetZValue = {
        args = "(float zValue)",
        description = "Set Z value.",
        returns = "()",
        type = "method"
      },
      GetPixelsPerUnit = {
        args = "()",
        description = "Return pixels per coordinate unit.",
        returns = "(float)",
        type = "method"
      },
      GetSprite = {
        args = "()",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      GetZValue = {
        args = "()",
        description = "Return Z value.",
        returns = "(float)",
        type = "method"
      },
      pixelsPerUnit = {
        description = "float\nPixels per coordinate unit.",
        type = "value"
      },
      sprite = {
        valuetype = "Sprite2D",
        description = "Sprite2D*\nSprite.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*\nMaterial. If null, use a default material. If non-null, use a clone of this for updating the diffuse texture.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode.",
        type = "value"
      },
      zValue = {
        description = "float\nZ value.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  StringHash = {
    childs = {
      new = {
        args = "()",
        description = "(StringHash*) new (const StringHash& rhs),\n(StringHash*) new (unsigned value),\n(StringHash*) new (const String str)",
        returns = "(StringHash*)",
        valuetype = "StringHash",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      operatorbool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      Value = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ToHash = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      Calculate = {
        args = "(const char* str)",
        returns = "(unsigned)",
        type = "method"
      },
      ZERO = {
        description = "const StringHash",
        type = "value"
      },
      value = {
        description = "(Readonly) unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  Technique = {
    childs = {
      HasPass = {
        args = "(const String type)",
        returns = "(bool)",
        type = "method"
      },
      GetPass = {
        args = "(const String type)",
        returns = "(Pass*)",
        valuetype = "Pass",
        type = "method"
      },
      IsSM3 = {
        args = "()",
        description = "Return whether requires %Shader %Model 3.",
        returns = "(bool)",
        type = "method"
      },
      SM3 = {
        description = "(Readonly) bool",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Terrain = {
    childs = {
      SetPatchSize = {
        args = "(int size)",
        description = "Set patch quads per side. Must be a power of two.",
        returns = "()",
        type = "method"
      },
      SetSpacing = {
        args = "(const Vector3& spacing)",
        description = "Set vertex (XZ) and height (Y) spacing.",
        returns = "()",
        type = "method"
      },
      SetSmoothing = {
        args = "(bool enable)",
        description = "Set smoothing of heightmap.",
        returns = "()",
        type = "method"
      },
      SetHeightMap = {
        args = "(Image* image)",
        description = "Set heightmap image. Dimensions should be a power of two + 1. Uses 8-bit grayscale, or optionally red as MSB and green as LSB for 16-bit accuracy. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance for patches.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance for patches.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias for patches. Affects which terrain LOD to display.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask for patches. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask for patches. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask for patches. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask for patches. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights for patches. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag for patches.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag for patches. Occlusion uses the coarsest LOD and may potentially be too aggressive, so use with caution.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag for patches.",
        returns = "()",
        type = "method"
      },
      GetPatchSize = {
        args = "()",
        description = "Return patch quads per side.",
        returns = "(int)",
        type = "method"
      },
      GetSpacing = {
        args = "()",
        description = "Return vertex and height spacing.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetNumVertices = {
        args = "()",
        description = "Return heightmap size in vertices.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetNumPatches = {
        args = "()",
        description = "Return heightmap size in patches.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSmoothing = {
        args = "()",
        description = "Return whether smoothing is in use.",
        returns = "(bool)",
        type = "method"
      },
      GetHeightMap = {
        args = "()",
        description = "Return heightmap image.",
        returns = "(Image*)",
        valuetype = "Image",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetPatch = {
        args = "(unsigned index)",
        description = "(TerrainPatch*) GetPatch (int x, int z)\nReturn patch by index.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetHeight = {
        args = "(const Vector3& worldPosition)",
        description = "Return height at world coordinates.",
        returns = "(float)",
        type = "method"
      },
      GetNormal = {
        args = "(const Vector3& worldPosition)",
        description = "Return normal at world coordinates.",
        returns = "(Vector3)",
        type = "method"
      },
      GetHeightData = {
        args = "()",
        description = "Return raw height data.",
        returns = "(SharedArrayPtr<float>)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return visible flag.",
        returns = "(bool)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      patchSize = {
        description = "int\nPatch size, quads per side.",
        type = "value"
      },
      spacing = {
        valuetype = "Vector3",
        description = "Vector3&\nVertex and height spacing.",
        type = "value"
      },
      numVertices = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nTerrain size in vertices.",
        type = "value"
      },
      numPatches = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nTerrain size in patches.",
        type = "value"
      },
      smoothing = {
        description = "bool\nSmoothing enable flag.",
        type = "value"
      },
      heightMap = {
        valuetype = "Image",
        description = "Image*\nHeightmap image.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*\nMaterial.",
        type = "value"
      },
      drawDistance = {
        description = "float\nDraw distance.",
        type = "value"
      },
      shadowDistance = {
        description = "float\nShadow distance.",
        type = "value"
      },
      lodBias = {
        description = "float\nLOD bias.",
        type = "value"
      },
      viewMask = {
        description = "unsigned\nView mask.",
        type = "value"
      },
      lightMask = {
        description = "unsigned\nLight mask.",
        type = "value"
      },
      shadowMask = {
        description = "unsigned\nShadow mask.",
        type = "value"
      },
      zoneMask = {
        description = "unsigned\nZone mask.",
        type = "value"
      },
      maxLights = {
        description = "unsigned\nMaximum lights.",
        type = "value"
      },
      visible = {
        description = "(Readonly) bool\nVisible flag.",
        type = "value"
      },
      castShadows = {
        description = "bool\nShadowcaster flag.",
        type = "value"
      },
      occluder = {
        description = "bool\nOccluder flag.",
        type = "value"
      },
      occludee = {
        description = "bool\nOccludee flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  TerrainPatch = {
    childs = {
      SetOwner = {
        args = "(Terrain* terrain)",
        description = "Set owner terrain.",
        returns = "()",
        type = "method"
      },
      SetNeighbors = {
        args = "(TerrainPatch* north, TerrainPatch* south, TerrainPatch* west, TerrainPatch* east)",
        description = "Set neighbor patches.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetBoundingBox = {
        args = "(const BoundingBox& box)",
        description = "Set local-space bounding box.",
        returns = "()",
        type = "method"
      },
      SetCoordinates = {
        args = "(const IntVector2& coordinates)",
        description = "Set patch coordinates.",
        returns = "()",
        type = "method"
      },
      SetOcclusionOffset = {
        args = "(float offset)",
        description = "Set vertical offset for occlusion geometry. Should be negative.",
        returns = "()",
        type = "method"
      },
      ResetLod = {
        args = "()",
        description = "Reset to LOD level 0.",
        returns = "()",
        type = "method"
      },
      GetGeometry = {
        args = "()",
        description = "Return visible geometry.",
        returns = "(Geometry*)",
        valuetype = "Geometry",
        type = "method"
      },
      GetMaxLodGeometry = {
        args = "()",
        description = "Return max LOD geometry.",
        returns = "(Geometry*)",
        valuetype = "Geometry",
        type = "method"
      },
      GetMinLodGeometry = {
        args = "()",
        description = "Return min LOD geometry.",
        returns = "(Geometry*)",
        valuetype = "Geometry",
        type = "method"
      },
      GetVertexBuffer = {
        args = "()",
        description = "Return vertex buffer.",
        returns = "(VertexBuffer*)",
        valuetype = "VertexBuffer",
        type = "method"
      },
      GetOwner = {
        args = "()",
        description = "Return owner terrain.",
        returns = "(Terrain*)",
        valuetype = "Terrain",
        type = "method"
      },
      GetNorthPatch = {
        args = "()",
        description = "Return north neighbor patch.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetSouthPatch = {
        args = "()",
        description = "Return south neighbor patch.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetWestPatch = {
        args = "()",
        description = "Return west neighbor patch.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetEastPatch = {
        args = "()",
        description = "Return east neighbor patch.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetCoordinates = {
        args = "()",
        description = "Return patch coordinates.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetLodLevel = {
        args = "()",
        description = "Return current LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      GetOcclusionOffset = {
        args = "()",
        description = "Return vertical offset for occlusion geometry..",
        returns = "(float)",
        type = "method"
      },
      geometry = {
        valuetype = "Geometry",
        description = "(Readonly) Geometry*\nGeometry.",
        type = "value"
      },
      maxLodGeometry = {
        valuetype = "Geometry",
        description = "(Readonly) Geometry*\nGeometry that is locked to the max LOD level. Used for decals.",
        type = "value"
      },
      minLodGeometry = {
        valuetype = "Geometry",
        description = "(Readonly) Geometry*\nGeometry that is locked to the minimum LOD level. Used for occlusion.",
        type = "value"
      },
      vertexBuffer = {
        valuetype = "VertexBuffer",
        description = "(Readonly) VertexBuffer*\nVertex buffer.",
        type = "value"
      },
      owner = {
        valuetype = "Terrain",
        description = "Terrain*\nParent terrain.",
        type = "value"
      },
      northPatch = {
        valuetype = "TerrainPatch",
        description = "(Readonly) TerrainPatch*",
        type = "value"
      },
      southPatch = {
        valuetype = "TerrainPatch",
        description = "(Readonly) TerrainPatch*",
        type = "value"
      },
      westPatch = {
        valuetype = "TerrainPatch",
        description = "(Readonly) TerrainPatch*",
        type = "value"
      },
      eastPatch = {
        valuetype = "TerrainPatch",
        description = "(Readonly) TerrainPatch*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "BoundingBox&",
        type = "value"
      },
      coordinates = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPatch coordinates in the terrain. (0,0) is the northwest corner.",
        type = "value"
      },
      lodLevel = {
        description = "(Readonly) unsigned\nCurrent LOD level.",
        type = "value"
      },
      occlusionOffset = {
        description = "float\nVertical offset for occlusion geometry.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Text = {
    childs = {
      new = {
        args = "()",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetFont = {
        args = "(const String fontName, int size = DEFAULT_FONT_SIZE)",
        description = "(bool) SetFont (Font* font, int size = DEFAULT_FONT_SIZE)\nSet font and font size.",
        returns = "(bool)",
        type = "method"
      },
      SetText = {
        args = "(const String text)",
        description = "Set text. Text is assumed to be either ASCII or UTF8-encoded.",
        returns = "()",
        type = "method"
      },
      SetTextAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set row alignment.",
        returns = "()",
        type = "method"
      },
      SetRowSpacing = {
        args = "(float spacing)",
        description = "Set row spacing, 1.0 for original font spacing.",
        returns = "()",
        type = "method"
      },
      SetWordwrap = {
        args = "(bool enable)",
        description = "Set wordwrap. In wordwrap mode the text element will respect its current width. Otherwise it resizes itself freely.",
        returns = "()",
        type = "method"
      },
      SetSelection = {
        args = "(unsigned start, unsigned length = M_MAX_UNSIGNED)",
        description = "Set selection. When length is not provided, select until the text ends.",
        returns = "()",
        type = "method"
      },
      ClearSelection = {
        args = "()",
        description = "Clear selection.",
        returns = "()",
        type = "method"
      },
      SetSelectionColor = {
        args = "(const Color& color)",
        description = "Set selection background color. Color with 0 alpha (default) disables.",
        returns = "()",
        type = "method"
      },
      SetHoverColor = {
        args = "(const Color& color)",
        description = "Set hover background color. Color with 0 alpha (default) disables.",
        returns = "()",
        type = "method"
      },
      SetTextEffect = {
        args = "(TextEffect textEffect)",
        description = "Set text effect.",
        returns = "()",
        type = "method"
      },
      SetEffectColor = {
        args = "(const Color& effectColor)",
        description = "Set effect color.",
        returns = "()",
        type = "method"
      },
      GetFont = {
        args = "()",
        description = "Return font.",
        returns = "(Font*)",
        valuetype = "Font",
        type = "method"
      },
      GetFontSize = {
        args = "()",
        description = "Return font size.",
        returns = "(int)",
        type = "method"
      },
      GetText = {
        args = "()",
        description = "Return text.",
        returns = "(const String)",
        type = "method"
      },
      GetTextAlignment = {
        args = "()",
        description = "Return row alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetRowSpacing = {
        args = "()",
        description = "Return row spacing.",
        returns = "(float)",
        type = "method"
      },
      GetWordwrap = {
        args = "()",
        description = "Return wordwrap mode.",
        returns = "(bool)",
        type = "method"
      },
      GetSelectionStart = {
        args = "()",
        description = "Return selection start.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelectionLength = {
        args = "()",
        description = "Return selection length.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelectionColor = {
        args = "()",
        description = "Return selection background color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetHoverColor = {
        args = "()",
        description = "Return hover background color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetTextEffect = {
        args = "()",
        description = "Return text effect.",
        returns = "(TextEffect)",
        type = "method"
      },
      GetEffectColor = {
        args = "()",
        description = "Return effect color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetRowHeight = {
        args = "()",
        description = "Return row height.",
        returns = "(int)",
        type = "method"
      },
      GetNumRows = {
        args = "()",
        description = "Return number of rows.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumChars = {
        args = "()",
        description = "Return number of characters.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowWidth = {
        args = "(unsigned index)",
        description = "Return width of row by index.",
        returns = "(int)",
        type = "method"
      },
      GetCharPosition = {
        args = "(unsigned index)",
        description = "Return position of character by index relative to the text element origin.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetCharSize = {
        args = "(unsigned index)",
        description = "Return size of character by index.",
        returns = "(IntVector2)",
        type = "method"
      },
      SetEffectDepthBias = {
        args = "(float bias)",
        description = "Set text effect Z bias. Zero by default, adjusted only in 3D mode.",
        returns = "()",
        type = "method"
      },
      GetEffectDepthBias = {
        args = "()",
        description = "Return effect Z bias.",
        returns = "(float)",
        type = "method"
      },
      font = {
        valuetype = "Font",
        description = "Font*\nFont.",
        type = "value"
      },
      fontSize = {
        description = "(Readonly) int\nFont size.",
        type = "value"
      },
      text = {
        description = "String\nUTF-8 encoded text.",
        type = "value"
      },
      textAlignment = {
        description = "HorizontalAlignment\nRow alignment.",
        type = "value"
      },
      rowSpacing = {
        description = "float\nRow spacing.",
        type = "value"
      },
      wordwrap = {
        description = "bool",
        type = "value"
      },
      selectionStart = {
        description = "(Readonly) unsigned\nSelection start.",
        type = "value"
      },
      selectionLength = {
        description = "(Readonly) unsigned\nSelection length.",
        type = "value"
      },
      selectionColor = {
        valuetype = "Color",
        description = "Color&\nSelection background color.",
        type = "value"
      },
      hoverColor = {
        valuetype = "Color",
        description = "Color&\nHover background color.",
        type = "value"
      },
      textEffect = {
        description = "TextEffect\nText effect.",
        type = "value"
      },
      effectColor = {
        valuetype = "Color",
        description = "Color&\nEffect color.",
        type = "value"
      },
      rowHeight = {
        description = "(Readonly) int\nRow height.",
        type = "value"
      },
      numRows = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numChars = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Text3D = {
    childs = {
      new = {
        args = "()",
        returns = "(Text3D*)",
        valuetype = "Text3D",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetFont = {
        args = "(const String fontName, int size = DEFAULT_FONT_SIZE)",
        description = "(bool) SetFont (Font* font, int size = DEFAULT_FONT_SIZE)\nSet font and font size. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetText = {
        args = "(const String text)",
        description = "Set text. Text is assumed to be either ASCII or UTF8-encoded.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetTextAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set row alignment.",
        returns = "()",
        type = "method"
      },
      SetRowSpacing = {
        args = "(float spacing)",
        description = "Set row spacing, 1.0 for original font spacing.",
        returns = "()",
        type = "method"
      },
      SetWordwrap = {
        args = "(bool enable)",
        description = "Set wordwrap. In wordwrap mode the text element will respect its current width. Otherwise it resizes itself freely.",
        returns = "()",
        type = "method"
      },
      SetTextEffect = {
        args = "(TextEffect textEffect)",
        description = "Set text effect.",
        returns = "()",
        type = "method"
      },
      SetEffectColor = {
        args = "(const Color& effectColor)",
        description = "Set effect color.",
        returns = "()",
        type = "method"
      },
      SetEffectDepthBias = {
        args = "(float bias)",
        description = "Set effect Z bias.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set text width. Only has effect in word wrap mode.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetFaceCamera = {
        args = "(bool enable)",
        description = "Set whether to face the camera automatically.",
        returns = "()",
        type = "method"
      },
      GetFont = {
        args = "()",
        description = "Return font.",
        returns = "(Font*)",
        valuetype = "Font",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetFontSize = {
        args = "()",
        description = "Return font size.",
        returns = "(int)",
        type = "method"
      },
      GetText = {
        args = "()",
        description = "Return text.",
        returns = "(const String)",
        type = "method"
      },
      GetTextAlignment = {
        args = "()",
        description = "Return row alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetRowSpacing = {
        args = "()",
        description = "Return row spacing.",
        returns = "(float)",
        type = "method"
      },
      GetWordwrap = {
        args = "()",
        description = "Return wordwrap mode.",
        returns = "(bool)",
        type = "method"
      },
      GetTextEffect = {
        args = "()",
        description = "Return text effect.",
        returns = "(TextEffect)",
        type = "method"
      },
      GetEffectColor = {
        args = "()",
        description = "Return effect color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetEffectDepthBias = {
        args = "()",
        description = "Return effect depth bias.",
        returns = "(float)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return text width.",
        returns = "(int)",
        type = "method"
      },
      GetRowHeight = {
        args = "()",
        description = "Return row height.",
        returns = "(int)",
        type = "method"
      },
      GetNumRows = {
        args = "()",
        description = "Return number of rows.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumChars = {
        args = "()",
        description = "Return number of characters.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowWidth = {
        args = "(unsigned index)",
        description = "Return width of row by index.",
        returns = "(int)",
        type = "method"
      },
      GetCharPosition = {
        args = "(unsigned index)",
        description = "Return position of character by index relative to the text element origin.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetCharSize = {
        args = "(unsigned index)",
        description = "Return size of character by index.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "Return corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetFaceCamera = {
        args = "()",
        description = "Return whether faces the camera automatically.",
        returns = "(bool)",
        type = "method"
      },
      font = {
        valuetype = "Font",
        description = "Font*",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*\nMaterial to use as a base for the text material(s).",
        type = "value"
      },
      fontSize = {
        description = "(Readonly) int",
        type = "value"
      },
      text = {
        description = "String\nInternally used text element.",
        type = "value"
      },
      textAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      rowSpacing = {
        description = "float",
        type = "value"
      },
      wordwrap = {
        description = "bool",
        type = "value"
      },
      textEffect = {
        description = "TextEffect",
        type = "value"
      },
      effectColor = {
        valuetype = "Color",
        description = "Color&",
        type = "value"
      },
      effectDepthBias = {
        description = "float",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&",
        type = "value"
      },
      rowHeight = {
        description = "(Readonly) int",
        type = "value"
      },
      numRows = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numChars = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      opacity = {
        description = "float",
        type = "value"
      },
      faceCamera = {
        description = "bool\nFace camera flag.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Texture = {
    childs = {
      SetNumLevels = {
        args = "(unsigned levels)",
        returns = "()",
        type = "method"
      },
      SetFilterMode = {
        args = "(TextureFilterMode filter)",
        returns = "()",
        type = "method"
      },
      SetAddressMode = {
        args = "(TextureCoordinate coord, TextureAddressMode address)",
        returns = "()",
        type = "method"
      },
      SetBorderColor = {
        args = "(const Color& color)",
        returns = "()",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      SetBackupTexture = {
        args = "(Texture* texture)",
        returns = "()",
        type = "method"
      },
      SetMipsToSkip = {
        args = "(int quality, int mips)",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetLevels = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetFilterMode = {
        args = "()",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetAddressMode = {
        args = "(TextureCoordinate coord)",
        returns = "(TextureAddressMode)",
        type = "method"
      },
      GetBorderColor = {
        args = "()",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetBackupTexture = {
        args = "()",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetMipsToSkip = {
        args = "(int quality)",
        returns = "(int)",
        type = "method"
      },
      GetLevelWidth = {
        args = "(unsigned level)",
        returns = "(int)",
        type = "method"
      },
      GetLevelHeight = {
        args = "(unsigned level)",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetDataSize = {
        args = "(int width, int height)",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowDataSize = {
        args = "(int width)",
        returns = "(unsigned)",
        type = "method"
      },
      format = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      levels = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      width = {
        description = "(Readonly) int",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
      filterMode = {
        description = "TextureFilterMode",
        type = "value"
      },
      borderColor = {
        valuetype = "Color",
        description = "Color&",
        type = "value"
      },
      sRGB = {
        description = "bool",
        type = "value"
      },
      backupTexture = {
        valuetype = "Texture",
        description = "Texture*",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Texture2D = {
    childs = {
      new = {
        args = "()",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(int width, int height, unsigned format, TextureUsage usage = TEXTURE_STATIC)",
        returns = "(bool)",
        type = "method"
      },
      Load = {
        args = "(Image* image, bool useAlpha = false)",
        returns = "(bool)",
        type = "method"
      },
      GetRenderSurface = {
        args = "()",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      renderSurface = {
        valuetype = "RenderSurface",
        description = "(Readonly) RenderSurface*",
        type = "value"
      },
      SetNumLevels = {
        args = "(unsigned levels)",
        returns = "()",
        type = "method"
      },
      SetFilterMode = {
        args = "(TextureFilterMode filter)",
        returns = "()",
        type = "method"
      },
      SetAddressMode = {
        args = "(TextureCoordinate coord, TextureAddressMode address)",
        returns = "()",
        type = "method"
      },
      SetBorderColor = {
        args = "(const Color& color)",
        returns = "()",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      SetBackupTexture = {
        args = "(Texture* texture)",
        returns = "()",
        type = "method"
      },
      SetMipsToSkip = {
        args = "(int quality, int mips)",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetLevels = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetFilterMode = {
        args = "()",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetAddressMode = {
        args = "(TextureCoordinate coord)",
        returns = "(TextureAddressMode)",
        type = "method"
      },
      GetBorderColor = {
        args = "()",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetBackupTexture = {
        args = "()",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetMipsToSkip = {
        args = "(int quality)",
        returns = "(int)",
        type = "method"
      },
      GetLevelWidth = {
        args = "(unsigned level)",
        returns = "(int)",
        type = "method"
      },
      GetLevelHeight = {
        args = "(unsigned level)",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetDataSize = {
        args = "(int width, int height)",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowDataSize = {
        args = "(int width)",
        returns = "(unsigned)",
        type = "method"
      },
      format = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      levels = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      width = {
        description = "(Readonly) int",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
      filterMode = {
        description = "TextureFilterMode",
        type = "value"
      },
      borderColor = {
        valuetype = "Color",
        description = "Color&",
        type = "value"
      },
      sRGB = {
        description = "bool",
        type = "value"
      },
      backupTexture = {
        valuetype = "Texture",
        description = "Texture*",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  TextureCube = {
    childs = {
      GetRenderSurface = {
        args = "(CubeMapFace face)",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      SetNumLevels = {
        args = "(unsigned levels)",
        returns = "()",
        type = "method"
      },
      SetFilterMode = {
        args = "(TextureFilterMode filter)",
        returns = "()",
        type = "method"
      },
      SetAddressMode = {
        args = "(TextureCoordinate coord, TextureAddressMode address)",
        returns = "()",
        type = "method"
      },
      SetBorderColor = {
        args = "(const Color& color)",
        returns = "()",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      SetBackupTexture = {
        args = "(Texture* texture)",
        returns = "()",
        type = "method"
      },
      SetMipsToSkip = {
        args = "(int quality, int mips)",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetLevels = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetFilterMode = {
        args = "()",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetAddressMode = {
        args = "(TextureCoordinate coord)",
        returns = "(TextureAddressMode)",
        type = "method"
      },
      GetBorderColor = {
        args = "()",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetBackupTexture = {
        args = "()",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetMipsToSkip = {
        args = "(int quality)",
        returns = "(int)",
        type = "method"
      },
      GetLevelWidth = {
        args = "(unsigned level)",
        returns = "(int)",
        type = "method"
      },
      GetLevelHeight = {
        args = "(unsigned level)",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetDataSize = {
        args = "(int width, int height)",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowDataSize = {
        args = "(int width)",
        returns = "(unsigned)",
        type = "method"
      },
      format = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      levels = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      width = {
        description = "(Readonly) int",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
      filterMode = {
        description = "TextureFilterMode",
        type = "value"
      },
      borderColor = {
        valuetype = "Color",
        description = "Color&",
        type = "value"
      },
      sRGB = {
        description = "bool",
        type = "value"
      },
      backupTexture = {
        valuetype = "Texture",
        description = "Texture*",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  TextureFrame = {
    childs = {
      new = {
        args = "()",
        returns = "(TextureFrame*)",
        valuetype = "TextureFrame",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      uv = {
        description = "Rect",
        type = "value"
      },
      time = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  Time = {
    childs = {
      GetFrameNumber = {
        args = "()",
        description = "Return frame number, starting from 1 once BeginFrame() is called for the first time.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTimeStep = {
        args = "()",
        description = "Return current frame timestep as seconds.",
        returns = "(float)",
        type = "method"
      },
      GetTimerPeriod = {
        args = "()",
        description = "Return current low-resolution timer period in milliseconds.",
        returns = "(unsigned)",
        type = "method"
      },
      GetElapsedTime = {
        args = "()",
        description = "Return elapsed time from program start as seconds.",
        returns = "(float)",
        type = "method"
      },
      GetSystemTime = {
        args = "()",
        description = "Get system time as milliseconds.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTimeStamp = {
        args = "()",
        description = "Get a date/time stamp as a string.",
        returns = "(String)",
        type = "method"
      },
      Sleep = {
        args = "(unsigned mSec)",
        description = "Sleep for a number of milliseconds.",
        returns = "()",
        type = "method"
      },
      frameNumber = {
        description = "(Readonly) unsigned\nFrame number.",
        type = "value"
      },
      timeStep = {
        description = "(Readonly) float\nTimestep in seconds.",
        type = "value"
      },
      timerPeriod = {
        description = "(Readonly) unsigned\nLow-resolution timer period.",
        type = "value"
      },
      elapsedTime = {
        description = "(Readonly) float\nElapsed time since program start.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ToolTip = {
    childs = {
      new = {
        args = "()",
        returns = "(ToolTip*)",
        valuetype = "ToolTip",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetDelay = {
        args = "(float delay)",
        description = "Set the delay in seconds until the tooltip shows once hovering. Set zero to use the default from the UI subsystem.",
        returns = "()",
        type = "method"
      },
      GetDelay = {
        args = "()",
        description = "Return the delay in seconds until the tooltip shows once hovering.",
        returns = "(float)",
        type = "method"
      },
      delay = {
        description = "float\nDelay from hover start to displaying the tooltip.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  TouchState = {
    childs = {
      touchID = {
        description = "int",
        type = "value"
      },
      position = {
        description = "IntVector2",
        type = "value"
      },
      lastPosition = {
        description = "IntVector2",
        type = "value"
      },
      delta = {
        description = "IntVector2",
        type = "value"
      },
      pressure = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  UI = {
    childs = {
      SetCursor = {
        args = "(Cursor* cursor)",
        description = "Set cursor UI element.",
        returns = "()",
        type = "method"
      },
      SetFocusElement = {
        args = "(UIElement* element, bool byKey = false)",
        description = "Set focused UI element.",
        returns = "()",
        type = "method"
      },
      SetModalElement = {
        args = "(UIElement* modalElement, bool enable)",
        description = "Only the modal element can clear its modal status or when it is being destructed.",
        returns = "(bool)",
        type = "method"
      },
      Clear = {
        args = "()",
        description = "Clear the UI (excluding the cursor.)",
        returns = "()",
        type = "method"
      },
      Update = {
        args = "(float timeStep)",
        description = "Update the UI logic. Called by HandlePostUpdate().",
        returns = "()",
        type = "method"
      },
      RenderUpdate = {
        args = "()",
        description = "Update the UI for rendering. Called by HandleRenderUpdate().",
        returns = "()",
        type = "method"
      },
      Render = {
        args = "()",
        description = "Render the UI.",
        returns = "()",
        type = "method"
      },
      DebugDraw = {
        args = "(UIElement* element)",
        description = "Debug draw a UI element.",
        returns = "()",
        type = "method"
      },
      LoadLayout = {
        args = "(File* source, XMLFile* styleFile = 0)",
        description = "(UIElement*) LoadLayout (const String fileName, XMLFile* styleFile = 0),\n(UIElement*) LoadLayout (XMLFile* file, XMLFile* styleFile = 0)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      SaveLayout = {
        args = "(Serializer& dest, UIElement* element)",
        description = "Save a UI layout to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetClipBoardText = {
        args = "(const String text)",
        description = "Set clipboard text.",
        returns = "()",
        type = "method"
      },
      SetDoubleClickInterval = {
        args = "(float interval)",
        description = "Set UI element double click interval in seconds.",
        returns = "()",
        type = "method"
      },
      SetDragBeginInterval = {
        args = "(float interval)",
        description = "Set UI drag event start interval in seconds.",
        returns = "()",
        type = "method"
      },
      SetDragBeginDistance = {
        args = "(int pixels)",
        description = "Set UI drag event start distance threshold in pixels.",
        returns = "()",
        type = "method"
      },
      SetDefaultToolTipDelay = {
        args = "(float delay)",
        description = "Set tooltip default display delay in seconds.",
        returns = "()",
        type = "method"
      },
      SetMaxFontTextureSize = {
        args = "(int size)",
        description = "Set maximum font face texture size. Must be a power of two. Default is 2048.",
        returns = "()",
        type = "method"
      },
      SetNonFocusedMouseWheel = {
        args = "(bool nonFocusedMouseWheel)",
        description = "Set whether mouse wheel can control also a non-focused element.",
        returns = "()",
        type = "method"
      },
      SetUseSystemClipBoard = {
        args = "(bool enable)",
        description = "Set whether to use system clipboard. Default false.",
        returns = "()",
        type = "method"
      },
      SetUseScreenKeyboard = {
        args = "(bool enable)",
        description = "Set whether to show the on-screen keyboard (if supported) when a %LineEdit is focused. Default true on mobile devices.",
        returns = "()",
        type = "method"
      },
      SetUseMutableGlyphs = {
        args = "(bool enable)",
        description = "Set whether to use mutable (eraseable) glyphs to ensure a font face never expands to more than one texture. Default false.",
        returns = "()",
        type = "method"
      },
      SetForceAutoHint = {
        args = "(bool enable)",
        description = "Set whether to force font autohinting instead of using FreeType's TTF bytecode interpreter.",
        returns = "()",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root UI element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRootModalElement = {
        args = "()",
        description = "Return root modal element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetCursor = {
        args = "()",
        description = "Return cursor.",
        returns = "(Cursor*)",
        valuetype = "Cursor",
        type = "method"
      },
      GetCursorPosition = {
        args = "()",
        description = "Return cursor position.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetElementAt = {
        args = "(const IntVector2& position, bool enabledOnly = true)",
        description = "(UIElement*) GetElementAt (int x, int y, bool enabledOnly = true)\nReturn UI element at screen coordinates. By default returns only input-enabled elements.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetFocusElement = {
        args = "()",
        description = "Return focused element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetFrontElement = {
        args = "()",
        description = "Return topmost enabled root-level non-modal element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDragElement = {
        args = "()",
        description = "Return currently dragged element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetClipBoardText = {
        args = "()",
        description = "Return clipboard text.",
        returns = "(const String)",
        type = "method"
      },
      GetDoubleClickInterval = {
        args = "()",
        description = "Return UI element double click interval in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetDragBeginInterval = {
        args = "()",
        description = "Return UI drag start event interval in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetDragBeginDistance = {
        args = "()",
        description = "Return UI drag start event distance threshold in pixels.",
        returns = "(int)",
        type = "method"
      },
      GetDefaultToolTipDelay = {
        args = "()",
        description = "Return tooltip default display delay in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetMaxFontTextureSize = {
        args = "()",
        description = "Return font texture maximum size.",
        returns = "(int)",
        type = "method"
      },
      IsNonFocusedMouseWheel = {
        args = "()",
        description = "Return whether mouse wheel can control also a non-focused element.",
        returns = "(bool)",
        type = "method"
      },
      GetUseSystemClipBoard = {
        args = "()",
        description = "Return whether is using the system clipboard.",
        returns = "(bool)",
        type = "method"
      },
      GetUseScreenKeyboard = {
        args = "()",
        description = "Return whether focusing a %LineEdit will show the on-screen keyboard.",
        returns = "(bool)",
        type = "method"
      },
      GetUseMutableGlyphs = {
        args = "()",
        description = "Return whether is using mutable (eraseable) glyphs for fonts.",
        returns = "(bool)",
        type = "method"
      },
      GetForceAutoHint = {
        args = "()",
        description = "Return whether is using forced autohinting.",
        returns = "(bool)",
        type = "method"
      },
      HasModalElement = {
        args = "()",
        description = "Return true when UI has modal element(s).",
        returns = "(bool)",
        type = "method"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      rootModalElement = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*\nUI root modal element.",
        type = "value"
      },
      cursor = {
        valuetype = "Cursor",
        description = "Cursor*\nCursor.",
        type = "value"
      },
      cursorPosition = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      focusElement = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*\nCurrently focused element",
        type = "value"
      },
      frontElement = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      dragElement = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*\nUI element being dragged.",
        type = "value"
      },
      clipBoardText = {
        description = "String",
        type = "value"
      },
      doubleClickInterval = {
        description = "float\nSeconds between clicks to register a double click.",
        type = "value"
      },
      dragBeginInterval = {
        description = "float\nSeconds from mouse button down to begin a drag if there has been no movement exceeding pixel threshold.",
        type = "value"
      },
      dragBeginDistance = {
        description = "int\nDrag begin event distance threshold in pixels.",
        type = "value"
      },
      defaultToolTipDelay = {
        description = "float\nTooltip default display delay in seconds.",
        type = "value"
      },
      maxFontTextureSize = {
        description = "int\nFont texture maximum size.",
        type = "value"
      },
      nonFocusedMouseWheel = {
        description = "bool\nFlag to switch mouse wheel event to be sent to non-focused element at cursor.",
        type = "value"
      },
      useSystemClipBoard = {
        description = "bool\nFlag for using operating system clipboard instead of internal.",
        type = "value"
      },
      useScreenKeyboard = {
        description = "bool\nFlag for showing the on-screen keyboard on focusing a %LineEdit.",
        type = "value"
      },
      useMutableGlyphs = {
        description = "bool\nFlag for using mutable (eraseable) font glyphs.",
        type = "value"
      },
      forceAutoHint = {
        description = "bool\nFlag for forcing FreeType autohinting.",
        type = "value"
      },
      modalElement = {
        description = "(Readonly) bool",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  UIElement = {
    childs = {
      new = {
        args = "()",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Variant = {
    childs = {
      new = {
        args = "()",
        description = "(Variant*) new (int value),\n(Variant*) new (unsigned value),\n(Variant*) new (const StringHash& value),\n(Variant*) new (const ShortStringHash& value),\n(Variant*) new (bool value),\n(Variant*) new (float value),\n(Variant*) new (const Vector2& value),\n(Variant*) new (const Vector3& value),\n(Variant*) new (const Vector4& value),\n(Variant*) new (const Quaternion& value),\n(Variant*) new (const Color& value),\n(Variant*) new (const String value),\n(Variant*) new (const char* value),\n(Variant*) new (const ResourceRef& value),\n(Variant*) new (const ResourceRefList& value),\n(Variant*) new (const IntRect& value),\n(Variant*) new (const IntVector2& value),\n(Variant*) new (const String type, const String value),\n(Variant*) new (VariantType type, const String value),\n(Variant*) new (VariantType type, const char* value),\n(Variant*) new (const Variant& value)",
        returns = "(Variant*)",
        valuetype = "Variant",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetInt = {
        args = "(int value)",
        returns = "()",
        type = "method"
      },
      SetUint = {
        args = "(unsigned value)",
        returns = "()",
        type = "method"
      },
      SetStringHash = {
        args = "(const StringHash& value)",
        returns = "()",
        type = "method"
      },
      SetShortStringHash = {
        args = "(const ShortStringHash& value)",
        returns = "()",
        type = "method"
      },
      SetBool = {
        args = "(bool value)",
        returns = "()",
        type = "method"
      },
      SetFloat = {
        args = "(float value)",
        returns = "()",
        type = "method"
      },
      SetVector2 = {
        args = "(const Vector2& value)",
        returns = "()",
        type = "method"
      },
      SetVector3 = {
        args = "(const Vector3& value)",
        returns = "()",
        type = "method"
      },
      SetVector4 = {
        args = "(const Vector4& value)",
        returns = "()",
        type = "method"
      },
      SetQuaternion = {
        args = "(const Quaternion& value)",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& value)",
        returns = "()",
        type = "method"
      },
      SetString = {
        args = "(const String value)",
        returns = "()",
        type = "method"
      },
      SetBuffer = {
        args = "(const VectorBuffer& value)",
        returns = "()",
        type = "method"
      },
      SetResourceRef = {
        args = "(const ResourceRef& value)",
        returns = "()",
        type = "method"
      },
      SetResourceRefList = {
        args = "(const ResourceRefList& value)",
        returns = "()",
        type = "method"
      },
      SetIntRect = {
        args = "(const IntRect& value)",
        returns = "()",
        type = "method"
      },
      SetIntVector2 = {
        args = "(const IntVector2& value)",
        returns = "()",
        type = "method"
      },
      GetInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetUInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetStringHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      GetShortStringHash = {
        args = "()",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetFloat = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetVector2 = {
        args = "()",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetVector3 = {
        args = "()",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetVector4 = {
        args = "()",
        returns = "(const Vector4&)",
        valuetype = "Vector4",
        type = "method"
      },
      GetQuaternion = {
        args = "()",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetColor = {
        args = "()",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetString = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetBuffer = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      GetResourceRef = {
        args = "()",
        returns = "(const ResourceRef&)",
        valuetype = "ResourceRef",
        type = "method"
      },
      GetResourceRefList = {
        args = "()",
        returns = "(const ResourceRefList&)",
        valuetype = "ResourceRefList",
        type = "method"
      },
      GetIntRect = {
        args = "()",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetIntVector2 = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetType = {
        args = "()",
        returns = "(VariantType)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      IsZero = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsEmpty = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) VariantType",
        type = "value"
      },
      typeName = {
        description = "(Readonly) String",
        type = "value"
      },
      zero = {
        description = "(Readonly) bool",
        type = "value"
      },
      empty = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  VariantMap = {
    childs = {
      new = {
        args = "()",
        returns = "(VariantMap*)",
        valuetype = "VariantMap",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetInt = {
        args = "(const String key, int value)",
        returns = "()",
        type = "method"
      },
      SetUInt = {
        args = "(const String key, unsigned value)",
        returns = "()",
        type = "method"
      },
      SetStringHash = {
        args = "(const String key, const StringHash& value)",
        returns = "()",
        type = "method"
      },
      SetShortStringHash = {
        args = "(const String key, const ShortStringHash& value)",
        returns = "()",
        type = "method"
      },
      SetBool = {
        args = "(const String key, bool value)",
        returns = "()",
        type = "method"
      },
      SetFloat = {
        args = "(const String key, float value)",
        returns = "()",
        type = "method"
      },
      SetVector2 = {
        args = "(const String key, const Vector2 value)",
        returns = "()",
        type = "method"
      },
      SetVector3 = {
        args = "(const String key, const Vector3 value)",
        returns = "()",
        type = "method"
      },
      SetVector4 = {
        args = "(const String key, const Vector4 value)",
        returns = "()",
        type = "method"
      },
      SetQuaternion = {
        args = "(const String key, const Quaternion value)",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const String key, const Color value)",
        returns = "()",
        type = "method"
      },
      SetString = {
        args = "(const String key, const String value)",
        returns = "()",
        type = "method"
      },
      SetBuffer = {
        args = "(const String key, const VectorBuffer& value)",
        returns = "()",
        type = "method"
      },
      SetResourceRef = {
        args = "(const String key, const ResourceRef value)",
        returns = "()",
        type = "method"
      },
      SetResourceRefList = {
        args = "(const String key, const ResourceRefList value)",
        returns = "()",
        type = "method"
      },
      SetIntRect = {
        args = "(const String key, const IntRect value)",
        returns = "()",
        type = "method"
      },
      SetIntVector2 = {
        args = "(const String key, const IntVector2 value)",
        returns = "()",
        type = "method"
      },
      SetPtr = {
        args = "(const String key, void* value)",
        returns = "()",
        type = "method"
      },
      GetInt = {
        args = "(const String key)",
        returns = "(int)",
        type = "method"
      },
      GetUInt = {
        args = "(const String key)",
        returns = "(int)",
        type = "method"
      },
      GetStringHash = {
        args = "(const String key)",
        returns = "(StringHash)",
        type = "method"
      },
      GetShortStringHash = {
        args = "(const String key)",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBool = {
        args = "(const String key)",
        returns = "(bool)",
        type = "method"
      },
      GetFloat = {
        args = "(const String key)",
        returns = "(float)",
        type = "method"
      },
      GetVector2 = {
        args = "(const String key)",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetVector3 = {
        args = "(const String key)",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetVector4 = {
        args = "(const String key)",
        returns = "(const Vector4&)",
        valuetype = "Vector4",
        type = "method"
      },
      GetQuaternion = {
        args = "(const String key)",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetColor = {
        args = "(const String key)",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetString = {
        args = "(const String key)",
        returns = "(const String)",
        type = "method"
      },
      GetBuffer = {
        args = "(const String key)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      GetResourceRef = {
        args = "(const String key)",
        returns = "(const ResourceRef&)",
        valuetype = "ResourceRef",
        type = "method"
      },
      GetResourceRefList = {
        args = "(const String key)",
        returns = "(const ResourceRefList&)",
        valuetype = "ResourceRefList",
        type = "method"
      },
      GetIntRect = {
        args = "(const String key)",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetIntVector2 = {
        args = "(const String key)",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPtr = {
        args = "(const String type, const String key)",
        returns = "(const void*)",
        type = "method"
      },
    },
    type = "class"
  },
  Vector2 = {
    childs = {
      new = {
        args = "()",
        description = "(Vector2*) new (const Vector2& vector),\n(Vector2*) new (float x, float y)",
        returns = "(Vector2*)",
        valuetype = "Vector2",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Normalize = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Length = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      LengthSquared = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      DotProduct = {
        args = "(const Vector2& rhs)",
        returns = "(float)",
        type = "method"
      },
      AbsDotProduct = {
        args = "(const Vector2& rhs)",
        returns = "(float)",
        type = "method"
      },
      Abs = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      Lerp = {
        args = "(const Vector2& rhs, float t)",
        returns = "(Vector2)",
        type = "method"
      },
      Equals = {
        args = "(const Vector2& rhs)",
        returns = "(bool)",
        type = "method"
      },
      Normalized = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      x = {
        description = "float",
        type = "value"
      },
      y = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Vector2",
        type = "value"
      },
      LEFT = {
        description = "const Vector2",
        type = "value"
      },
      RIGHT = {
        description = "const Vector2",
        type = "value"
      },
      UP = {
        description = "const Vector2",
        type = "value"
      },
      DOWN = {
        description = "const Vector2",
        type = "value"
      },
      ONE = {
        description = "const Vector2",
        type = "value"
      },
    },
    type = "class"
  },
  Vector3 = {
    childs = {
      new = {
        args = "()",
        description = "(Vector3*) new (const Vector3& vector),\n(Vector3*) new (const Vector2& vector, float z),\n(Vector3*) new (float x, float y, float z)",
        returns = "(Vector3*)",
        valuetype = "Vector3",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Normalize = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Length = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      LengthSquared = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      DotProduct = {
        args = "(const Vector3& rhs)",
        returns = "(float)",
        type = "method"
      },
      AbsDotProduct = {
        args = "(const Vector3& rhs)",
        returns = "(float)",
        type = "method"
      },
      CrossProduct = {
        args = "(const Vector3& rhs)",
        returns = "(Vector3)",
        type = "method"
      },
      Abs = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Lerp = {
        args = "(const Vector3& rhs, float t)",
        returns = "(Vector3)",
        type = "method"
      },
      Equals = {
        args = "(const Vector3& rhs)",
        returns = "(bool)",
        type = "method"
      },
      Angle = {
        args = "(const Vector3& rhs)",
        returns = "(float)",
        type = "method"
      },
      Normalized = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      x = {
        description = "float",
        type = "value"
      },
      y = {
        description = "float",
        type = "value"
      },
      z = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Vector3",
        type = "value"
      },
      LEFT = {
        description = "const Vector3",
        type = "value"
      },
      RIGHT = {
        description = "const Vector3",
        type = "value"
      },
      UP = {
        description = "const Vector3",
        type = "value"
      },
      DOWN = {
        description = "const Vector3",
        type = "value"
      },
      FORWARD = {
        description = "const Vector3",
        type = "value"
      },
      BACK = {
        description = "const Vector3",
        type = "value"
      },
      ONE = {
        description = "const Vector3",
        type = "value"
      },
    },
    type = "class"
  },
  Vector4 = {
    childs = {
      new = {
        args = "()",
        description = "(Vector4*) new (const Vector4& vector),\n(Vector4*) new (const Vector3& vector, float w),\n(Vector4*) new (float x, float y, float z, float w)",
        returns = "(Vector4*)",
        valuetype = "Vector4",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      DotProduct = {
        args = "(const Vector4& rhs)",
        returns = "(float)",
        type = "method"
      },
      AbsDotProduct = {
        args = "(const Vector4& rhs)",
        returns = "(float)",
        type = "method"
      },
      Abs = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      Lerp = {
        args = "(const Vector4& rhs, float t)",
        returns = "(Vector4)",
        type = "method"
      },
      Equals = {
        args = "(const Vector4& rhs)",
        returns = "(bool)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      x = {
        description = "float",
        type = "value"
      },
      y = {
        description = "float",
        type = "value"
      },
      z = {
        description = "float",
        type = "value"
      },
      w = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Vector4",
        type = "value"
      },
      ONE = {
        description = "const Vector4",
        type = "value"
      },
    },
    type = "class"
  },
  VectorBuffer = {
    childs = {
      new = {
        args = "()",
        description = "(VectorBuffer*) new (Deserializer& source, unsigned size)",
        returns = "(VectorBuffer*)",
        valuetype = "VectorBuffer",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetData = {
        args = "(Deserializer& source, unsigned size)",
        description = "Set data from a stream.",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        description = "Reset to zero size.",
        returns = "()",
        type = "method"
      },
      Resize = {
        args = "(unsigned size)",
        description = "Set size.",
        returns = "()",
        type = "method"
      },
      GetData = {
        args = "()",
        description = "Return data.",
        returns = "(const void*)",
        type = "method"
      },
      GetModifiableData = {
        args = "()",
        description = "Return non-const data.",
        returns = "(void*)",
        type = "method"
      },
      Read = {
        args = "(unsigned size)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      Seek = {
        args = "(unsigned position)",
        description = "Set position from the beginning of the buffer.",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetSize = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      IsEof = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      ReadShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadUShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadUByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadFloat = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      ReadIntRect = {
        args = "()",
        returns = "(IntRect)",
        type = "method"
      },
      ReadIntVector2 = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      ReadRect = {
        args = "()",
        returns = "(Rect)",
        type = "method"
      },
      ReadVector2 = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      ReadVector3 = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ReadPackedVector3 = {
        args = "(float maxAbsCoord)",
        returns = "(Vector3)",
        type = "method"
      },
      ReadVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      ReadQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadPackedQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadColor = {
        args = "()",
        returns = "(Color)",
        type = "method"
      },
      ReadBoundingBox = {
        args = "()",
        returns = "(BoundingBox)",
        type = "method"
      },
      ReadString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadFileID = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadStringHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      ReadShortStringHash = {
        args = "()",
        returns = "(ShortStringHash)",
        type = "method"
      },
      ReadBuffer = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      ReadResourceRef = {
        args = "()",
        returns = "(ResourceRef)",
        type = "method"
      },
      ReadResourceRefList = {
        args = "()",
        returns = "(ResourceRefList)",
        type = "method"
      },
      ReadVariant = {
        args = "()",
        description = "(Variant) ReadVariant (VariantType type)",
        returns = "(Variant)",
        type = "method"
      },
      ReadVariantVector = {
        args = "()",
        returns = "(VariantVector)",
        type = "method"
      },
      ReadVariantMap = {
        args = "()",
        returns = "(VariantMap)",
        type = "method"
      },
      ReadVLE = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadNetID = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadLine = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      Write = {
        args = "(const VectorBuffer& buffer)",
        returns = "(unsigned)",
        type = "method"
      },
      WriteInt = {
        args = "(int value)",
        returns = "(bool)",
        type = "method"
      },
      WriteShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBool = {
        args = "(bool value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFloat = {
        args = "(float value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntRect = {
        args = "(const IntRect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector2 = {
        args = "(const IntVector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteRect = {
        args = "(const Rect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector2 = {
        args = "(const Vector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector3 = {
        args = "(const Vector3& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedVector3 = {
        args = "(const Vector3& value, float maxAbsCoord)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector4 = {
        args = "(const Vector4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteColor = {
        args = "(const Color& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBoundingBox = {
        args = "(const BoundingBox& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteString = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFileID = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteStringHash = {
        args = "(const StringHash& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteShortStringHash = {
        args = "(const ShortStringHash& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBuffer = {
        args = "(const VectorBuffer& buffer)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRef = {
        args = "(const ResourceRef& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRefList = {
        args = "(const ResourceRefList& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariant = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantData = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantVector = {
        args = "(const VariantVector& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantMap = {
        args = "(const VariantMap& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVLE = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteNetID = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteLine = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      position = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      size = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      eof = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  View3D = {
    childs = {
      new = {
        args = "()",
        returns = "(View3D*)",
        valuetype = "View3D",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetView = {
        args = "(Scene* scene, Camera* camera)",
        description = "Define the scene and camera to use in rendering. The View3D will take ownership of them with shared pointers.",
        returns = "()",
        type = "method"
      },
      SetFormat = {
        args = "(unsigned format)",
        description = "Set render texture pixel format. Default is RGB.",
        returns = "()",
        type = "method"
      },
      SetAutoUpdate = {
        args = "(bool enable)",
        description = "Set render target auto update mode. Default is true.",
        returns = "()",
        type = "method"
      },
      QueueUpdate = {
        args = "()",
        description = "Queue manual update on the render texture.",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        description = "Return render texture pixel format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAutoUpdate = {
        args = "()",
        description = "Return whether render target updates automatically.",
        returns = "(bool)",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return scene.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      GetCameraNode = {
        args = "()",
        description = "Return camera scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetRenderTexture = {
        args = "()",
        description = "Return render texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetDepthTexture = {
        args = "()",
        description = "Return depth stencil texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetViewport = {
        args = "()",
        description = "Return viewport.",
        returns = "(Viewport*)",
        valuetype = "Viewport",
        type = "method"
      },
      format = {
        description = "unsigned",
        type = "value"
      },
      autoUpdate = {
        description = "bool\nRender texture auto update mode.",
        type = "value"
      },
      SetMovable = {
        args = "(bool enable)",
        description = "Set whether can be moved.",
        returns = "()",
        type = "method"
      },
      SetResizable = {
        args = "(bool enable)",
        description = "Set whether can be resized.",
        returns = "()",
        type = "method"
      },
      SetFixedWidthResizing = {
        args = "(bool enable)",
        description = "Set whether resizing width is fixed.",
        returns = "()",
        type = "method"
      },
      SetFixedHeightResizing = {
        args = "(bool enable)",
        description = "Set whether resizing height is fixed.",
        returns = "()",
        type = "method"
      },
      SetResizeBorder = {
        args = "(const IntRect& rect)",
        description = "Set resize area width at edges.",
        returns = "()",
        type = "method"
      },
      SetModal = {
        args = "(bool modal)",
        description = "Set modal flag. When the modal flag is set, the focused window needs to be dismissed first to allow other UI elements to gain focus.",
        returns = "()",
        type = "method"
      },
      SetModalShadeColor = {
        args = "(const Color& color)",
        description = "Set modal shade color.",
        returns = "()",
        type = "method"
      },
      SetModalFrameColor = {
        args = "(const Color& color)",
        description = "Set modal frame color.",
        returns = "()",
        type = "method"
      },
      SetModalFrameSize = {
        args = "(const IntVector2& size)",
        description = "Set modal frame size.",
        returns = "()",
        type = "method"
      },
      IsMovable = {
        args = "()",
        description = "Return whether is movable.",
        returns = "(bool)",
        type = "method"
      },
      IsResizable = {
        args = "()",
        description = "Return whether is resizable.",
        returns = "(bool)",
        type = "method"
      },
      GetFixedWidthResizing = {
        args = "()",
        description = "Return whether is resizing width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetFixedHeightResizing = {
        args = "()",
        description = "Return whether is resizing height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetResizeBorder = {
        args = "()",
        description = "Return resize area width at edges.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      IsModal = {
        args = "()",
        description = "Return modal flag.",
        returns = "(bool)",
        type = "method"
      },
      GetModalShadeColor = {
        args = "()",
        description = "Get modal shade color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetModalFrameColor = {
        args = "()",
        description = "Get modal frame color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetModalFrameSize = {
        args = "()",
        description = "Get modal frame size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      movable = {
        description = "bool\nMovable flag.",
        type = "value"
      },
      resizable = {
        description = "bool\nResizable flag.",
        type = "value"
      },
      fixedWidthResizing = {
        description = "bool\nFixed width resize flag.",
        type = "value"
      },
      fixedHeightResizing = {
        description = "bool\nFixed height resize flag.",
        type = "value"
      },
      resizeBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nResize area width at edges.",
        type = "value"
      },
      modal = {
        description = "bool\nModal flag.",
        type = "value"
      },
      modalShadeColor = {
        valuetype = "Color",
        description = "Color&\nModal shade color, used when modal flag is set.",
        type = "value"
      },
      modalFrameColor = {
        valuetype = "Color",
        description = "Color&\nModal frame color, used when modal flag is set.",
        type = "value"
      },
      modalFrameSize = {
        valuetype = "IntVector2",
        description = "IntVector2&\nModal frame size, used when modal flag is set.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Viewport = {
    childs = {
      new = {
        args = "()",
        description = "(Viewport*) new (Scene* scene, Camera* camera, RenderPath* renderPath = 0),\n(Viewport*) new (Scene* scene, Camera* camera, const IntRect& rect, RenderPath* renderPath = 0)",
        returns = "(Viewport*)",
        valuetype = "Viewport",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetScene = {
        args = "(Scene* scene)",
        description = "Set scene.",
        returns = "()",
        type = "method"
      },
      SetCamera = {
        args = "(Camera* camera)",
        description = "Set camera.",
        returns = "()",
        type = "method"
      },
      SetRect = {
        args = "(const IntRect& rect)",
        description = "Set rectangle.",
        returns = "()",
        type = "method"
      },
      SetRenderPath = {
        args = "(RenderPath* path)",
        description = "() SetRenderPath (XMLFile* file)\nSet rendering path.",
        returns = "()",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return scene.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      GetCamera = {
        args = "()",
        description = "Return camera.",
        returns = "(Camera*)",
        valuetype = "Camera",
        type = "method"
      },
      GetRect = {
        args = "()",
        description = "Return rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetRenderPath = {
        args = "()",
        description = "Return rendering path.",
        returns = "(RenderPath*)",
        valuetype = "RenderPath",
        type = "method"
      },
      scene = {
        valuetype = "Scene",
        description = "Scene*\nScene pointer.",
        type = "value"
      },
      camera = {
        valuetype = "Camera",
        description = "Camera*\nCamera pointer.",
        type = "value"
      },
      rect = {
        valuetype = "IntRect",
        description = "IntRect&\nViewport rectangle.",
        type = "value"
      },
      renderPath = {
        valuetype = "RenderPath",
        description = "RenderPath*\nRendering path.",
        type = "value"
      },
    },
    type = "class"
  },
  Window = {
    childs = {
      new = {
        args = "()",
        returns = "(Window*)",
        valuetype = "Window",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetMovable = {
        args = "(bool enable)",
        description = "Set whether can be moved.",
        returns = "()",
        type = "method"
      },
      SetResizable = {
        args = "(bool enable)",
        description = "Set whether can be resized.",
        returns = "()",
        type = "method"
      },
      SetFixedWidthResizing = {
        args = "(bool enable)",
        description = "Set whether resizing width is fixed.",
        returns = "()",
        type = "method"
      },
      SetFixedHeightResizing = {
        args = "(bool enable)",
        description = "Set whether resizing height is fixed.",
        returns = "()",
        type = "method"
      },
      SetResizeBorder = {
        args = "(const IntRect& rect)",
        description = "Set resize area width at edges.",
        returns = "()",
        type = "method"
      },
      SetModal = {
        args = "(bool modal)",
        description = "Set modal flag. When the modal flag is set, the focused window needs to be dismissed first to allow other UI elements to gain focus.",
        returns = "()",
        type = "method"
      },
      SetModalShadeColor = {
        args = "(const Color& color)",
        description = "Set modal shade color.",
        returns = "()",
        type = "method"
      },
      SetModalFrameColor = {
        args = "(const Color& color)",
        description = "Set modal frame color.",
        returns = "()",
        type = "method"
      },
      SetModalFrameSize = {
        args = "(const IntVector2& size)",
        description = "Set modal frame size.",
        returns = "()",
        type = "method"
      },
      IsMovable = {
        args = "()",
        description = "Return whether is movable.",
        returns = "(bool)",
        type = "method"
      },
      IsResizable = {
        args = "()",
        description = "Return whether is resizable.",
        returns = "(bool)",
        type = "method"
      },
      GetFixedWidthResizing = {
        args = "()",
        description = "Return whether is resizing width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetFixedHeightResizing = {
        args = "()",
        description = "Return whether is resizing height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetResizeBorder = {
        args = "()",
        description = "Return resize area width at edges.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      IsModal = {
        args = "()",
        description = "Return modal flag.",
        returns = "(bool)",
        type = "method"
      },
      GetModalShadeColor = {
        args = "()",
        description = "Get modal shade color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetModalFrameColor = {
        args = "()",
        description = "Get modal frame color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetModalFrameSize = {
        args = "()",
        description = "Get modal frame size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      movable = {
        description = "bool\nMovable flag.",
        type = "value"
      },
      resizable = {
        description = "bool\nResizable flag.",
        type = "value"
      },
      fixedWidthResizing = {
        description = "bool\nFixed width resize flag.",
        type = "value"
      },
      fixedHeightResizing = {
        description = "bool\nFixed height resize flag.",
        type = "value"
      },
      resizeBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nResize area width at edges.",
        type = "value"
      },
      modal = {
        description = "bool\nModal flag.",
        type = "value"
      },
      modalShadeColor = {
        valuetype = "Color",
        description = "Color&\nModal shade color, used when modal flag is set.",
        type = "value"
      },
      modalFrameColor = {
        valuetype = "Color",
        description = "Color&\nModal frame color, used when modal flag is set.",
        type = "value"
      },
      modalFrameSize = {
        valuetype = "IntVector2",
        description = "IntVector2&\nModal frame size, used when modal flag is set.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set image border dimensions.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return image border dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nImage border dimensions.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest)",
        description = "(bool) SaveXML (const String fileName)\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(ShortStringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(ShortStringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetLayoutMinSize = {
        args = "()",
        description = "Return minimum layout element size in the layout direction. Only valid after layout has been calculated.",
        returns = "(int)",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment\nHorizontal alignment.",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment\nVertical alignment.",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      layoutMinSize = {
        description = "(Readonly) int\nLayout element minimum size in layout direction.",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  XMLElement = {
    childs = {
      CreateChild = {
        args = "(const String name)",
        description = "Create a child element.",
        returns = "(XMLElement)",
        type = "method"
      },
      RemoveChild = {
        args = "(const XMLElement& element)",
        description = "(bool) RemoveChild (const String name)\nRemove a child element. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      RemoveChildren = {
        args = "(const String name = String::EMPTY)",
        description = "Remove child elements of certain name, or all child elements if name is empty. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAttribute = {
        args = "(const String name = String::EMPTY)",
        description = "Remove an attribute by name. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetValue = {
        args = "(const String value)",
        description = "Set the value for an inner node in the following format <node>value</node>.",
        returns = "(bool)",
        type = "method"
      },
      SetAttribute = {
        args = "(const String name, const String value)",
        description = "Set an attribute.\nSet an attribute. Only valid if it is an attribute only XPath query result.",
        returns = "(bool)",
        type = "method"
      },
      SetBool = {
        args = "(const String name, bool value)",
        description = "Set a bool attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetBoundingBox = {
        args = "(const BoundingBox& value)",
        description = "Set a BoundingBox attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetColor = {
        args = "(const String name, const Color& value)",
        description = "Set a color attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetFloat = {
        args = "(const String name, float value)",
        description = "Set a float attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetUInt = {
        args = "(const String name, unsigned value)",
        description = "Set an unsigned integer attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetInt = {
        args = "(const String name, int value)",
        description = "Set an integer attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetIntRect = {
        args = "(const String name, const IntRect& value)",
        description = "Set an IntRect attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetIntVector2 = {
        args = "(const String name, const IntVector2& value)",
        description = "Set an IntVector2 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetRect = {
        args = "(const String name, const Rect& value)",
        description = "Set a Rect attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetQuaternion = {
        args = "(const String name, const Quaternion& value)",
        description = "Set a quaternion attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetString = {
        args = "(const String name, const String value)",
        description = "Set a string attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVariant = {
        args = "(const Variant& value)",
        description = "Set a variant attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVariantValue = {
        args = "(const Variant& value)",
        description = "Set a variant attribute excluding the type.",
        returns = "(bool)",
        type = "method"
      },
      SetResourceRef = {
        args = "(const ResourceRef& value)",
        description = "Set a resource reference attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetResourceRefList = {
        args = "(const ResourceRefList& value)",
        description = "Set a resource referene list attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVector2 = {
        args = "(const String name, const Vector2& value)",
        description = "Set a Vector2 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVector3 = {
        args = "(const String name, const Vector3& value)",
        description = "Set a Vector3 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVector4 = {
        args = "(const String name, const Vector4& value)",
        description = "Set a Vector4 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVectorVariant = {
        args = "(const String name, const Variant& value)",
        description = "Set a float or Vector attribute stored in a variant.",
        returns = "(bool)",
        type = "method"
      },
      IsNull = {
        args = "()",
        description = "Return whether does not refer to an element or an XPath node.",
        returns = "(bool)",
        type = "method"
      },
      NotNull = {
        args = "()",
        description = "Return whether refers to an element or an XPath node.",
        returns = "(bool)",
        type = "method"
      },
      operatorbool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return element name (or attribute name if it is an attribute only XPath query result).",
        returns = "(String)",
        type = "method"
      },
      HasChild = {
        args = "(const String name)",
        description = "Return whether has a child element.",
        returns = "(bool)",
        type = "method"
      },
      GetChild = {
        args = "(const String name = String::EMPTY)",
        description = "Return child element, or null if missing.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetNext = {
        args = "(const String name = String::EMPTY)",
        description = "Return next sibling element.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetNumAttributes = {
        args = "()",
        description = "Return number of attributes.",
        returns = "(unsigned)",
        type = "method"
      },
      HasAttribute = {
        args = "(const String name)",
        description = "Return whether has an attribute.",
        returns = "(bool)",
        type = "method"
      },
      GetBool = {
        args = "(const String name)",
        description = "Return bool attribute, or false if missing.",
        returns = "(bool)",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return bounding box attribute, or empty if missing.",
        returns = "(BoundingBox)",
        type = "method"
      },
      GetValue = {
        args = "()",
        description = "Return inner value, or empty if missing for nodes like <node>value</node>",
        returns = "(String)",
        type = "method"
      },
      GetColor = {
        args = "(const String name)",
        description = "Return a color attribute, or default if missing.",
        returns = "(Color)",
        type = "method"
      },
      GetFloat = {
        args = "(const String name)",
        description = "Return a float attribute, or zero if missing.",
        returns = "(float)",
        type = "method"
      },
      GetUInt = {
        args = "(const String name)",
        description = "Return an unsigned integer attribute, or zero if missing.",
        returns = "(unsigned)",
        type = "method"
      },
      GetInt = {
        args = "(const String name)",
        description = "Return an integer attribute, or zero if missing.",
        returns = "(int)",
        type = "method"
      },
      GetIntRect = {
        args = "(const String name)",
        description = "Return an IntRect attribute, or default if missing.",
        returns = "(IntRect)",
        type = "method"
      },
      GetIntVector2 = {
        args = "(const String name)",
        description = "Return an IntVector2 attribute, or default if missing.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetRect = {
        args = "(const String name)",
        description = "Return a Rect attribute, or default if missing.",
        returns = "(Rect)",
        type = "method"
      },
      GetQuaternion = {
        args = "(const String name)",
        description = "Return a quaternion attribute, or default if missing.",
        returns = "(Quaternion)",
        type = "method"
      },
      GetVariant = {
        args = "()",
        description = "Return a variant attribute, or empty if missing.",
        returns = "(Variant)",
        type = "method"
      },
      GetVariantValue = {
        args = "(VariantType type)",
        description = "Return a variant attribute with static type.",
        returns = "(Variant)",
        type = "method"
      },
      GetResourceRef = {
        args = "()",
        description = "Return a resource reference attribute, or empty if missing.",
        returns = "(ResourceRef)",
        type = "method"
      },
      GetResourceRefList = {
        args = "()",
        description = "Return a resource reference list attribute, or empty if missing.",
        returns = "(ResourceRefList)",
        type = "method"
      },
      GetVariantMap = {
        args = "()",
        description = "Return a variant map attribute, or empty if missing.",
        returns = "(VariantMap)",
        type = "method"
      },
      GetVector2 = {
        args = "(const String name)",
        description = "Return a Vector2 attribute, or default if missing.",
        returns = "(Vector2)",
        type = "method"
      },
      GetVector3 = {
        args = "(const String name)",
        description = "Return a Vector3 attribute, or default if missing.",
        returns = "(Vector3)",
        type = "method"
      },
      GetVector4 = {
        args = "(const String name)",
        description = "Return a Vector4 attribute, or default if missing.",
        returns = "(Vector4)",
        type = "method"
      },
      GetVector = {
        args = "(const String name)",
        description = "Return any Vector attribute as Vector4. Missing coordinates will be zero.",
        returns = "(Vector4)",
        type = "method"
      },
      GetFile = {
        args = "()",
        description = "Return XML file.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      EMPTY = {
        description = "const XMLElement\nEmpty XMLElement.",
        type = "value"
      },
      null = {
        description = "(Readonly) bool",
        type = "value"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      value = {
        description = "(Readonly) String",
        type = "value"
      },
      parent = {
        description = "(Readonly) XMLElement",
        type = "value"
      },
      numAttributes = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      file = {
        valuetype = "XMLFile",
        description = "(Readonly) XMLFile*\nXML file.",
        type = "value"
      },
    },
    type = "class"
  },
  XMLFile = {
    childs = {
      new = {
        args = "()",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      CreateRoot = {
        args = "(const String name = String::EMPTY)",
        description = "Clear the document and create a root element.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetRoot = {
        args = "(const String name = String::EMPTY)",
        description = "Return the root element, with optionally specified name. Return null element if not found.",
        returns = "(XMLElement)",
        type = "method"
      },
      Patch = {
        args = "(XMLFile* patchFile)",
        description = "() Patch (XMLElement patchElement)\nPatch the XMLFile with another XMLFile. Based on RFC 5261.",
        returns = "()",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Zone = {
    childs = {
      SetBoundingBox = {
        args = "(const BoundingBox& box)",
        description = "Set local-space bounding box. Will be used as an oriented bounding box to test whether objects or the camera are inside.",
        returns = "()",
        type = "method"
      },
      SetAmbientColor = {
        args = "(const Color& color)",
        description = "Set ambient color",
        returns = "()",
        type = "method"
      },
      SetFogColor = {
        args = "(const Color& color)",
        description = "Set fog color.",
        returns = "()",
        type = "method"
      },
      SetFogStart = {
        args = "(float start)",
        description = "Set fog start distance.",
        returns = "()",
        type = "method"
      },
      SetFogEnd = {
        args = "(float end)",
        description = "Set fog end distance.",
        returns = "()",
        type = "method"
      },
      SetFogHeight = {
        args = "(float height)",
        description = "Set fog height distance relative to the scene node's world position. Effective only in height fog mode.",
        returns = "()",
        type = "method"
      },
      SetFogHeightScale = {
        args = "(float scale)",
        description = "Set fog height scale. Effective only in height fog mode.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set zone priority. If an object or camera is inside several zones, the one with highest priority is used.",
        returns = "()",
        type = "method"
      },
      SetHeightFog = {
        args = "(bool enable)",
        description = "Set height fog mode.",
        returns = "()",
        type = "method"
      },
      SetOverride = {
        args = "(bool enable)",
        description = "Set override mode. If camera is inside an override zone, it will also be used for all drawables.",
        returns = "()",
        type = "method"
      },
      SetAmbientGradient = {
        args = "(bool enable)",
        description = "Set ambient gradient mode. In gradient mode ambient color is interpolated from neighbor zones.",
        returns = "()",
        type = "method"
      },
      GetInverseWorldTransform = {
        args = "()",
        description = "Return inverse world transform.",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      GetAmbientColor = {
        args = "()",
        description = "Return zone's own ambient color, disregarding gradient mode.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetAmbientStartColor = {
        args = "()",
        description = "Return ambient start color. Not safe to call from worker threads due to possible octree query.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetAmbientEndColor = {
        args = "()",
        description = "Return ambient end color. Not safe to call from worker threads due to possible octree query.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetFogColor = {
        args = "()",
        description = "Return fog color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetFogStart = {
        args = "()",
        description = "Return fog start distance.",
        returns = "(float)",
        type = "method"
      },
      GetFogEnd = {
        args = "()",
        description = "Return fog end distance.",
        returns = "(float)",
        type = "method"
      },
      GetFogHeight = {
        args = "()",
        description = "Return fog height distance relative to the scene node's world position.",
        returns = "(float)",
        type = "method"
      },
      GetFogHeightScale = {
        args = "()",
        description = "Return fog height scale.",
        returns = "(float)",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return zone priority.",
        returns = "(int)",
        type = "method"
      },
      GetHeightFog = {
        args = "()",
        description = "Return whether height fog mode is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetOverride = {
        args = "()",
        description = "Return whether override mode is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetAmbientGradient = {
        args = "()",
        description = "Return whether ambient gradient mode is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Check whether a point is inside.",
        returns = "(bool)",
        type = "method"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "BoundingBox&",
        type = "value"
      },
      inverseWorldTransform = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&",
        type = "value"
      },
      ambientColor = {
        valuetype = "Color",
        description = "Color&\nAmbient color.",
        type = "value"
      },
      ambientStartColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nCached ambient start color.",
        type = "value"
      },
      ambientEndColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nCached ambient end color.",
        type = "value"
      },
      fogColor = {
        valuetype = "Color",
        description = "Color&\nFog color.",
        type = "value"
      },
      fogStart = {
        description = "float\nFog start distance.",
        type = "value"
      },
      fogEnd = {
        description = "float\nFog end distance.",
        type = "value"
      },
      fogHeight = {
        description = "float\nFog height distance.",
        type = "value"
      },
      fogHeightScale = {
        description = "float\nFog height cale.",
        type = "value"
      },
      priority = {
        description = "int\nZone priority.",
        type = "value"
      },
      heightFog = {
        description = "bool\nHeight fog mode flag.",
        type = "value"
      },
      override = {
        description = "bool\nOverride mode flag.",
        type = "value"
      },
      ambientGradient = {
        description = "bool\nAmbient gradient mode flag.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_1)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        description = "Return current zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(ShortStringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetBaseType = {
        args = "()",
        description = "Return base class type hash.",
        returns = "(ShortStringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        description = "Return object category. Categories are (optionally) registered along with the object factory. Return an empty string if the object category is not registered.",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      type = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      baseType = {
        description = "(Readonly) ShortStringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },

  -- Enumerations

      BLEND_REPLACE = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_ADD = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_MULTIPLY = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_ALPHA = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_ADDALPHA = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_PREMULALPHA = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_INVDESTALPHA = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      MAX_BLENDMODES = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      COLLISION_NEVER = {
        description = "(Readonly) int for 'CollisionEventMode'",
        type = "value"
      },
      COLLISION_ACTIVE = {
        description = "(Readonly) int for 'CollisionEventMode'",
        type = "value"
      },
      COLLISION_ALWAYS = {
        description = "(Readonly) int for 'CollisionEventMode'",
        type = "value"
      },
      CMP_ALWAYS = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_EQUAL = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_NOTEQUAL = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_LESS = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_LESSEQUAL = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_GREATER = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_GREATEREQUAL = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      MAX_COMPAREMODES = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CF_NONE = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_DXT1 = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_DXT3 = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_DXT5 = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_ETC1 = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_PVRTC_RGB_2BPP = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_PVRTC_RGBA_2BPP = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_PVRTC_RGB_4BPP = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_PVRTC_RGBA_4BPP = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CONSTRAINT_POINT = {
        description = "(Readonly) int for 'ConstraintType'",
        type = "value"
      },
      CONSTRAINT_HINGE = {
        description = "(Readonly) int for 'ConstraintType'",
        type = "value"
      },
      CONSTRAINT_SLIDER = {
        description = "(Readonly) int for 'ConstraintType'",
        type = "value"
      },
      CONSTRAINT_CONETWIST = {
        description = "(Readonly) int for 'ConstraintType'",
        type = "value"
      },
      C_TOPLEFT = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      C_TOPRIGHT = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      C_BOTTOMLEFT = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      C_BOTTOMRIGHT = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      MAX_UIELEMENT_CORNERS = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      REPLICATED = {
        description = "(Readonly) int for 'CreateMode'",
        type = "value"
      },
      LOCAL = {
        description = "(Readonly) int for 'CreateMode'",
        type = "value"
      },
      FACE_POSITIVE_X = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_NEGATIVE_X = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_POSITIVE_Y = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_NEGATIVE_Y = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_POSITIVE_Z = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_NEGATIVE_Z = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      MAX_CUBEMAP_FACES = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      CULL_NONE = {
        description = "(Readonly) int for 'CullMode'",
        type = "value"
      },
      CULL_CCW = {
        description = "(Readonly) int for 'CullMode'",
        type = "value"
      },
      CULL_CW = {
        description = "(Readonly) int for 'CullMode'",
        type = "value"
      },
      MAX_CULLMODES = {
        description = "(Readonly) int for 'CullMode'",
        type = "value"
      },
      CS_NORMAL = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_RESIZEVERTICAL = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_RESIZEDIAGONAL_TOPRIGHT = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_RESIZEHORIZONTAL = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_RESIZEDIAGONAL_TOPLEFT = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_ACCEPTDROP = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_REJECTDROP = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_BUSY = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_MAX_SHAPES = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CM_LOOP = {
        description = "(Readonly) int for 'CycleMode'",
        type = "value"
      },
      CM_CLAMP = {
        description = "(Readonly) int for 'CycleMode'",
        type = "value"
      },
      CM_PINGPONG = {
        description = "(Readonly) int for 'CycleMode'",
        type = "value"
      },
      DLPS_NONE = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_SPOT = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_POINT = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_POINTMASK = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_SPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_SPOTSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_POINTSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_POINTMASKSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_SHADOW = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_SPOTSHADOW = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_POINTSHADOW = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_POINTMASKSHADOW = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_SHADOWSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_SPOTSHADOWSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_POINTSHADOWSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_POINTMASKSHADOWSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHO = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOSPOT = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOPOINT = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOPOINTMASK = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOSPOTSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOPOINTSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOPOINTMASKSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOSHADOW = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOSPOTSHADOW = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOPOINTSHADOW = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOPOINTMASKSHADOW = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOSHADOWSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOSPOTSHADOWSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOPOINTSHADOWSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLPS_ORTHOPOINTMASKSHADOWSPEC = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      MAX_DEFERRED_LIGHT_PS_VARIATIONS = {
        description = "(Readonly) int for 'DeferredLightPSVariation'",
        type = "value"
      },
      DLVS_NONE = {
        description = "(Readonly) int for 'DeferredLightVSVariation'",
        type = "value"
      },
      DLVS_DIR = {
        description = "(Readonly) int for 'DeferredLightVSVariation'",
        type = "value"
      },
      DLVS_ORTHO = {
        description = "(Readonly) int for 'DeferredLightVSVariation'",
        type = "value"
      },
      DLVS_ORTHODIR = {
        description = "(Readonly) int for 'DeferredLightVSVariation'",
        type = "value"
      },
      MAX_DEFERRED_LIGHT_VS_VARIATIONS = {
        description = "(Readonly) int for 'DeferredLightVSVariation'",
        type = "value"
      },
      EMITTER_SPHERE = {
        description = "(Readonly) int for 'EmitterType'",
        type = "value"
      },
      EMITTER_BOX = {
        description = "(Readonly) int for 'EmitterType'",
        type = "value"
      },
      EMITTER_TYPE_GRAVITY = {
        description = "(Readonly) int for 'EmitterType2D'",
        type = "value"
      },
      EMITTER_TYPE_RADIAL = {
        description = "(Readonly) int for 'EmitterType2D'",
        type = "value"
      },
      FILE_READ = {
        description = "(Readonly) int for 'FileMode'",
        type = "value"
      },
      FILE_WRITE = {
        description = "(Readonly) int for 'FileMode'",
        type = "value"
      },
      FILE_READWRITE = {
        description = "(Readonly) int for 'FileMode'",
        type = "value"
      },
      FILL_SOLID = {
        description = "(Readonly) int for 'FillMode'",
        type = "value"
      },
      FILL_WIREFRAME = {
        description = "(Readonly) int for 'FillMode'",
        type = "value"
      },
      FILL_POINT = {
        description = "(Readonly) int for 'FillMode'",
        type = "value"
      },
      FM_NOTFOCUSABLE = {
        description = "(Readonly) int for 'FocusMode'",
        type = "value"
      },
      FM_RESETFOCUS = {
        description = "(Readonly) int for 'FocusMode'",
        type = "value"
      },
      FM_FOCUSABLE = {
        description = "(Readonly) int for 'FocusMode'",
        type = "value"
      },
      FM_FOCUSABLE_DEFOCUSABLE = {
        description = "(Readonly) int for 'FocusMode'",
        type = "value"
      },
      PLANE_NEAR = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_LEFT = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_RIGHT = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_UP = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_DOWN = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_FAR = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      GEOM_STATIC = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      GEOM_SKINNED = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      GEOM_INSTANCED = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      GEOM_BILLBOARD = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      GEOM_STATIC_NOINSTANCING = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      MAX_GEOMETRYTYPES = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      HM_NEVER = {
        description = "(Readonly) int for 'HighlightMode'",
        type = "value"
      },
      HM_FOCUS = {
        description = "(Readonly) int for 'HighlightMode'",
        type = "value"
      },
      HM_ALWAYS = {
        description = "(Readonly) int for 'HighlightMode'",
        type = "value"
      },
      HA_LEFT = {
        description = "(Readonly) int for 'HorizontalAlignment'",
        type = "value"
      },
      HA_CENTER = {
        description = "(Readonly) int for 'HorizontalAlignment'",
        type = "value"
      },
      HA_RIGHT = {
        description = "(Readonly) int for 'HorizontalAlignment'",
        type = "value"
      },
      HTTP_INITIALIZING = {
        description = "(Readonly) int for 'HttpRequestState'",
        type = "value"
      },
      HTTP_ERROR = {
        description = "(Readonly) int for 'HttpRequestState'",
        type = "value"
      },
      HTTP_OPEN = {
        description = "(Readonly) int for 'HttpRequestState'",
        type = "value"
      },
      HTTP_CLOSED = {
        description = "(Readonly) int for 'HttpRequestState'",
        type = "value"
      },
      BEZIER_CURVE = {
        description = "(Readonly) int for 'InterpolationMode'",
        type = "value"
      },
      OUTSIDE = {
        description = "(Readonly) int for 'Intersection'",
        type = "value"
      },
      INTERSECTS = {
        description = "(Readonly) int for 'Intersection'",
        type = "value"
      },
      INSIDE = {
        description = "(Readonly) int for 'Intersection'",
        type = "value"
      },
      LM_FREE = {
        description = "(Readonly) int for 'LayoutMode'",
        type = "value"
      },
      LM_HORIZONTAL = {
        description = "(Readonly) int for 'LayoutMode'",
        type = "value"
      },
      LM_VERTICAL = {
        description = "(Readonly) int for 'LayoutMode'",
        type = "value"
      },
      LPS_NONE = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_SPOT = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_POINT = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_POINTMASK = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_SPEC = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_SPOTSPEC = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_POINTSPEC = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_POINTMASKSPEC = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_SHADOW = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_SPOTSHADOW = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_POINTSHADOW = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_POINTMASKSHADOW = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_SHADOWSPEC = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_SPOTSHADOWSPEC = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_POINTSHADOWSPEC = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LPS_POINTMASKSHADOWSPEC = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      MAX_LIGHT_PS_VARIATIONS = {
        description = "(Readonly) int for 'LightPSVariation'",
        type = "value"
      },
      LIGHT_DIRECTIONAL = {
        description = "(Readonly) int for 'LightType'",
        type = "value"
      },
      LIGHT_SPOT = {
        description = "(Readonly) int for 'LightType'",
        type = "value"
      },
      LIGHT_POINT = {
        description = "(Readonly) int for 'LightType'",
        type = "value"
      },
      LVS_DIR = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_SPOT = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_POINT = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_SPEC = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_SPOTSPEC = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_POINTSPEC = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_SHADOW = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_SPOTSHADOW = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_POINTSHADOW = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_DIRSPECSHADOW = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_SPOTSPECSHADOW = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LVS_POINTSPECSHADOW = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      MAX_LIGHT_VS_VARIATIONS = {
        description = "(Readonly) int for 'LightVSVariation'",
        type = "value"
      },
      LOCK_NONE = {
        description = "(Readonly) int for 'LockState'",
        type = "value"
      },
      LOCK_HARDWARE = {
        description = "(Readonly) int for 'LockState'",
        type = "value"
      },
      LOCK_SHADOW = {
        description = "(Readonly) int for 'LockState'",
        type = "value"
      },
      LOCK_SCRATCH = {
        description = "(Readonly) int for 'LockState'",
        type = "value"
      },
      O_HORIZONTAL = {
        description = "(Readonly) int for 'Orientation'",
        type = "value"
      },
      O_VERTICAL = {
        description = "(Readonly) int for 'Orientation'",
        type = "value"
      },
      LIGHTING_UNLIT = {
        description = "(Readonly) int for 'PassLightingMode'",
        type = "value"
      },
      LIGHTING_PERVERTEX = {
        description = "(Readonly) int for 'PassLightingMode'",
        type = "value"
      },
      LIGHTING_PERPIXEL = {
        description = "(Readonly) int for 'PassLightingMode'",
        type = "value"
      },
      TRIANGLE_LIST = {
        description = "(Readonly) int for 'PrimitiveType'",
        type = "value"
      },
      LINE_LIST = {
        description = "(Readonly) int for 'PrimitiveType'",
        type = "value"
      },
      RAY_AABB = {
        description = "(Readonly) int for 'RayQueryLevel'",
        type = "value"
      },
      RAY_OBB = {
        description = "(Readonly) int for 'RayQueryLevel'",
        type = "value"
      },
      RAY_TRIANGLE = {
        description = "(Readonly) int for 'RayQueryLevel'",
        type = "value"
      },
      SURFACE_MANUALUPDATE = {
        description = "(Readonly) int for 'RenderSurfaceUpdateMode'",
        type = "value"
      },
      SURFACE_UPDATEVISIBLE = {
        description = "(Readonly) int for 'RenderSurfaceUpdateMode'",
        type = "value"
      },
      SURFACE_UPDATEALWAYS = {
        description = "(Readonly) int for 'RenderSurfaceUpdateMode'",
        type = "value"
      },
      SP_FRAME = {
        description = "(Readonly) int for 'ShaderParameterGroup'",
        type = "value"
      },
      SP_CAMERA = {
        description = "(Readonly) int for 'ShaderParameterGroup'",
        type = "value"
      },
      SP_VIEWPORT = {
        description = "(Readonly) int for 'ShaderParameterGroup'",
        type = "value"
      },
      SP_ZONE = {
        description = "(Readonly) int for 'ShaderParameterGroup'",
        type = "value"
      },
      SP_LIGHT = {
        description = "(Readonly) int for 'ShaderParameterGroup'",
        type = "value"
      },
      SP_VERTEXLIGHTS = {
        description = "(Readonly) int for 'ShaderParameterGroup'",
        type = "value"
      },
      SP_MATERIAL = {
        description = "(Readonly) int for 'ShaderParameterGroup'",
        type = "value"
      },
      SP_OBJECTTRANSFORM = {
        description = "(Readonly) int for 'ShaderParameterGroup'",
        type = "value"
      },
      MAX_SHADER_PARAMETER_GROUPS = {
        description = "(Readonly) int for 'ShaderParameterGroup'",
        type = "value"
      },
      VS = {
        description = "(Readonly) int for 'ShaderType'",
        type = "value"
      },
      PS = {
        description = "(Readonly) int for 'ShaderType'",
        type = "value"
      },
      SHAPE_BOX = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_SPHERE = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_STATICPLANE = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_CYLINDER = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_CAPSULE = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_CONE = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_TRIANGLEMESH = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_CONVEXHULL = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_TERRAIN = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SOUND_EFFECT = {
        description = "(Readonly) int for 'SoundType'",
        type = "value"
      },
      SOUND_AMBIENT = {
        description = "(Readonly) int for 'SoundType'",
        type = "value"
      },
      SOUND_VOICE = {
        description = "(Readonly) int for 'SoundType'",
        type = "value"
      },
      SOUND_MUSIC = {
        description = "(Readonly) int for 'SoundType'",
        type = "value"
      },
      SOUND_MASTER = {
        description = "(Readonly) int for 'SoundType'",
        type = "value"
      },
      MAX_SOUND_TYPES = {
        description = "(Readonly) int for 'SoundType'",
        type = "value"
      },
      OP_KEEP = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      OP_ZERO = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      OP_REF = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      OP_INCR = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      OP_DECR = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      TE_NONE = {
        description = "(Readonly) int for 'TextEffect'",
        type = "value"
      },
      TE_SHADOW = {
        description = "(Readonly) int for 'TextEffect'",
        type = "value"
      },
      TE_STROKE = {
        description = "(Readonly) int for 'TextEffect'",
        type = "value"
      },
      ADDRESS_WRAP = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      ADDRESS_MIRROR = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      ADDRESS_CLAMP = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      ADDRESS_BORDER = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      MAX_ADDRESSMODES = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      COORD_U = {
        description = "(Readonly) int for 'TextureCoordinate'",
        type = "value"
      },
      COORD_V = {
        description = "(Readonly) int for 'TextureCoordinate'",
        type = "value"
      },
      COORD_W = {
        description = "(Readonly) int for 'TextureCoordinate'",
        type = "value"
      },
      MAX_COORDS = {
        description = "(Readonly) int for 'TextureCoordinate'",
        type = "value"
      },
      FILTER_NEAREST = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      FILTER_BILINEAR = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      FILTER_TRILINEAR = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      FILTER_ANISOTROPIC = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      FILTER_DEFAULT = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      MAX_FILTERMODES = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      TU_DIFFUSE = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_ALBEDOBUFFER = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_NORMAL = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_NORMALBUFFER = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_SPECULAR = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_EMISSIVE = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_ENVIRONMENT = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      MAX_MATERIAL_TEXTURE_UNITS = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_LIGHTRAMP = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_LIGHTSHAPE = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_SHADOWMAP = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_FACESELECT = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_INDIRECTION = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_DEPTHBUFFER = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_LIGHTBUFFER = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_VOLUMEMAP = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      MAX_TEXTURE_UNITS = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TEXTURE_STATIC = {
        description = "(Readonly) int for 'TextureUsage'",
        type = "value"
      },
      TEXTURE_DYNAMIC = {
        description = "(Readonly) int for 'TextureUsage'",
        type = "value"
      },
      TEXTURE_RENDERTARGET = {
        description = "(Readonly) int for 'TextureUsage'",
        type = "value"
      },
      TEXTURE_DEPTHSTENCIL = {
        description = "(Readonly) int for 'TextureUsage'",
        type = "value"
      },
      TM_BREADTH_FIRST = {
        description = "(Readonly) int for 'TraversalMode'",
        type = "value"
      },
      TM_DEPTH_FIRST = {
        description = "(Readonly) int for 'TraversalMode'",
        type = "value"
      },
      VAR_NONE = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_INT = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_BOOL = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_FLOAT = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VECTOR2 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VECTOR3 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VECTOR4 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_QUATERNION = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_COLOR = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_STRING = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_BUFFER = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VOIDPTR = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_RESOURCEREF = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_RESOURCEREFLIST = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VARIANTVECTOR = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VARIANTMAP = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_INTRECT = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_INTVECTOR2 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_PTR = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      MAX_VAR_TYPES = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      ELEMENT_POSITION = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_NORMAL = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_COLOR = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_TEXCOORD1 = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_TEXCOORD2 = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_CUBETEXCOORD1 = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_CUBETEXCOORD2 = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_TANGENT = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_BLENDWEIGHTS = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_BLENDINDICES = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_INSTANCEMATRIX1 = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_INSTANCEMATRIX2 = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      ELEMENT_INSTANCEMATRIX3 = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      MAX_VERTEX_ELEMENTS = {
        description = "(Readonly) int for 'VertexElement'",
        type = "value"
      },
      VLVS_NOLIGHTS = {
        description = "(Readonly) int for 'VertexLightVSVariation'",
        type = "value"
      },
      VLVS_1LIGHT = {
        description = "(Readonly) int for 'VertexLightVSVariation'",
        type = "value"
      },
      VLVS_2LIGHTS = {
        description = "(Readonly) int for 'VertexLightVSVariation'",
        type = "value"
      },
      VLVS_3LIGHTS = {
        description = "(Readonly) int for 'VertexLightVSVariation'",
        type = "value"
      },
      VLVS_4LIGHTS = {
        description = "(Readonly) int for 'VertexLightVSVariation'",
        type = "value"
      },
      MAX_VERTEXLIGHT_VS_VARIATIONS = {
        description = "(Readonly) int for 'VertexLightVSVariation'",
        type = "value"
      },
      VA_TOP = {
        description = "(Readonly) int for 'VerticalAlignment'",
        type = "value"
      },
      VA_CENTER = {
        description = "(Readonly) int for 'VerticalAlignment'",
        type = "value"
      },
      VA_BOTTOM = {
        description = "(Readonly) int for 'VerticalAlignment'",
        type = "value"
      },
      DRAG_NONE = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_MOVE = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_TOPLEFT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_TOP = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_TOPRIGHT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_RIGHT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_BOTTOMRIGHT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_BOTTOM = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_BOTTOMLEFT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_LEFT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },

  -- Global Functions

      Abs = {
        args = "(float value)",
        returns = "(float)",
        type = "function"
      },
      AddTrailingSlash = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      Clamp = {
        args = "(float value, float min, float max)",
        returns = "(float)",
        type = "function"
      },
      Equals = {
        args = "(float lhs, float rhs)",
        returns = "(bool)",
        type = "function"
      },
      ErrorDialog = {
        args = "(const String title, const String message)",
        returns = "()",
        type = "function"
      },
      ErrorExit = {
        args = "(const String message = String::EMPTY, int exitCode = EXIT_FAILURE)",
        returns = "()",
        type = "function"
      },
      GetArguments = {
        args = "()",
        returns = "(const Vector<String>&)",
        valuetype = "Vector<String>",
        type = "function"
      },
      GetAudio = {
        args = "()",
        returns = "(Audio*)",
        valuetype = "Audio",
        type = "function"
      },
      GetCache = {
        args = "()",
        returns = "(ResourceCache*)",
        valuetype = "ResourceCache",
        type = "function"
      },
      GetConsole = {
        args = "()",
        returns = "(Console*)",
        valuetype = "Console",
        type = "function"
      },
      GetConsoleInput = {
        args = "()",
        returns = "(String)",
        type = "function"
      },
      GetContext = {
        args = "()",
        returns = "(Context*)",
        valuetype = "Context",
        type = "function"
      },
      GetDebugHud = {
        args = "()",
        returns = "(DebugHud*)",
        valuetype = "DebugHud",
        type = "function"
      },
      GetEngine = {
        args = "()",
        returns = "(Engine*)",
        valuetype = "Engine",
        type = "function"
      },
      GetEventHandler = {
        args = "()",
        returns = "(EventHandler*)",
        valuetype = "EventHandler",
        type = "function"
      },
      GetEventSender = {
        args = "()",
        returns = "(Object*)",
        valuetype = "Object",
        type = "function"
      },
      GetExecuteConsoleCommands = {
        args = "()",
        returns = "(bool)",
        type = "function"
      },
      GetExtension = {
        args = "(const String fullPath, bool lowercaseExtension = true)",
        returns = "(String)",
        type = "function"
      },
      GetFileName = {
        args = "(const String fullPath)",
        returns = "(String)",
        type = "function"
      },
      GetFileNameAndExtension = {
        args = "(const String fullPath, bool lowercaseExtension = false)",
        returns = "(String)",
        type = "function"
      },
      GetFileSystem = {
        args = "()",
        returns = "(FileSystem*)",
        valuetype = "FileSystem",
        type = "function"
      },
      GetGraphics = {
        args = "()",
        returns = "(Graphics*)",
        valuetype = "Graphics",
        type = "function"
      },
      GetInput = {
        args = "()",
        returns = "(Input*)",
        valuetype = "Input",
        type = "function"
      },
      GetInternalPath = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      GetLog = {
        args = "()",
        returns = "(Log*)",
        valuetype = "Log",
        type = "function"
      },
      GetNativePath = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      GetNetwork = {
        args = "()",
        returns = "(Network*)",
        valuetype = "Network",
        type = "function"
      },
      GetNumLogicalCPUs = {
        args = "()",
        returns = "(unsigned)",
        type = "function"
      },
      GetNumPhysicalCPUs = {
        args = "()",
        returns = "(unsigned)",
        type = "function"
      },
      GetParentPath = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      GetPath = {
        args = "(const String fullPath)",
        returns = "(String)",
        type = "function"
      },
      GetPlatform = {
        args = "()",
        returns = "(String)",
        type = "function"
      },
      GetRandomSeed = {
        args = "()",
        returns = "(unsigned)",
        type = "function"
      },
      GetRenderer = {
        args = "()",
        returns = "(Renderer*)",
        valuetype = "Renderer",
        type = "function"
      },
      GetTime = {
        args = "()",
        returns = "(Time*)",
        valuetype = "Time",
        type = "function"
      },
      GetUI = {
        args = "()",
        returns = "(UI*)",
        valuetype = "UI",
        type = "function"
      },
      IsAbsolutePath = {
        args = "(const String pathName)",
        returns = "(bool)",
        type = "function"
      },
      IsAlpha = {
        args = "(unsigned ch)",
        returns = "(bool)",
        type = "function"
      },
      IsDigit = {
        args = "(unsigned ch)",
        returns = "(bool)",
        type = "function"
      },
      Lerp = {
        args = "(float lhs, float rhs, float t)",
        returns = "(float)",
        type = "function"
      },
      Max = {
        args = "(float lhs, float rhs)",
        returns = "(float)",
        type = "function"
      },
      Min = {
        args = "(float lhs, float rhs)",
        returns = "(float)",
        type = "function"
      },
      OpenConsoleWindow = {
        args = "()",
        returns = "()",
        type = "function"
      },
      PrintLine = {
        args = "(const String str, bool error = false)",
        returns = "()",
        type = "function"
      },
      Rand = {
        args = "()",
        returns = "(int)",
        type = "function"
      },
      RandStandardNormal = {
        args = "()",
        returns = "(float)",
        type = "function"
      },
      Random = {
        args = "()",
        returns = "(float)",
        type = "function"
      },
      Random = {
        args = "(float min, float max)",
        returns = "(float)",
        type = "function"
      },
      Random = {
        args = "(float range)",
        returns = "(float)",
        type = "function"
      },
      RandomInt = {
        args = "(int range)",
        returns = "(int)",
        type = "function"
      },
      RandomInt = {
        args = "(int min, int max)",
        returns = "(int)",
        type = "function"
      },
      RandomNormal = {
        args = "(float meanValue, float variance)",
        returns = "(float)",
        type = "function"
      },
      RemoveTrailingSlash = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      ReplaceExtension = {
        args = "(const String fullPath, const String newExtension)",
        returns = "(String)",
        type = "function"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap& eventData)",
        returns = "()",
        type = "function"
      },
      SetExecuteConsoleCommands = {
        args = "(bool enable)",
        returns = "()",
        type = "function"
      },
      SetRandomSeed = {
        args = "(unsigned seed)",
        returns = "()",
        type = "function"
      },
      Sign = {
        args = "(float value)",
        returns = "(float)",
        type = "function"
      },
      SmoothStep = {
        args = "(float lhs, float rhs, float t)",
        returns = "(float)",
        type = "function"
      },
      SubscribeToEvent = {
        args = "(void* sender, const String eventName, const String functionName)",
        returns = "()",
        type = "function"
      },
      SubscribeToEvent = {
        args = "(const String eventName, const String functionName)",
        returns = "()",
        type = "function"
      },
      ToBool = {
        args = "(const String source)",
        returns = "(bool)",
        type = "function"
      },
      ToColor = {
        args = "(const String source)",
        returns = "(Color)",
        type = "function"
      },
      ToFloat = {
        args = "(const String source)",
        returns = "(float)",
        type = "function"
      },
      ToInt = {
        args = "(const String source)",
        returns = "(int)",
        type = "function"
      },
      ToIntRect = {
        args = "(const String source)",
        returns = "(IntRect)",
        type = "function"
      },
      ToIntVector2 = {
        args = "(const String source)",
        returns = "(IntVector2)",
        type = "function"
      },
      ToLower = {
        args = "(unsigned ch)",
        returns = "(unsigned)",
        type = "function"
      },
      ToQuaternion = {
        args = "(const String source)",
        returns = "(Quaternion)",
        type = "function"
      },
      ToRect = {
        args = "(const String source)",
        returns = "(Rect)",
        type = "function"
      },
      ToString = {
        args = "(void* value)",
        returns = "(String)",
        type = "function"
      },
      ToStringHex = {
        args = "(unsigned value)",
        returns = "(String)",
        type = "function"
      },
      ToUInt = {
        args = "(const String source)",
        returns = "(unsigned)",
        type = "function"
      },
      ToUpper = {
        args = "(unsigned ch)",
        returns = "(unsigned)",
        type = "function"
      },
      ToVector2 = {
        args = "(const String source)",
        returns = "(Vector2)",
        type = "function"
      },
      ToVector3 = {
        args = "(const String source)",
        returns = "(Vector3)",
        type = "function"
      },
      ToVector4 = {
        args = "(const String source, bool allowMissingCoords = false)",
        returns = "(Vector4)",
        type = "function"
      },
      UnsubscribeFromAllEvents = {
        args = "()",
        returns = "()",
        type = "function"
      },
      UnsubscribeFromEvent = {
        args = "(const String eventName, const String functionName = String::EMPTY)",
        returns = "()",
        type = "function"
      },
      UnsubscribeFromEvent = {
        args = "(void* sender, const String eventName, const String functionName = String::EMPTY)",
        returns = "()",
        type = "function"
      },
      UnsubscribeFromEvents = {
        args = "(void* sender)",
        returns = "()",
        type = "function"
      },

      audio = {
        valuetype = "Audio",
        description = "(Readonly) Audio*",
        type = "value"
      },
      time = {
        valuetype = "Time",
        description = "(Readonly) Time*",
        type = "value"
      },
      console = {
        valuetype = "Console",
        description = "(Readonly) Console*",
        type = "value"
      },
      debugHud = {
        valuetype = "DebugHud",
        description = "(Readonly) DebugHud*",
        type = "value"
      },
      engine = {
        valuetype = "Engine",
        description = "(Readonly) Engine*",
        type = "value"
      },
      graphics = {
        valuetype = "Graphics",
        description = "(Readonly) Graphics*",
        type = "value"
      },
      renderer = {
        valuetype = "Renderer",
        description = "(Readonly) Renderer*",
        type = "value"
      },
      fileSystem = {
        valuetype = "FileSystem",
        description = "(Readonly) FileSystem*",
        type = "value"
      },
      log = {
        valuetype = "Log",
        description = "(Readonly) Log*",
        type = "value"
      },
      input = {
        valuetype = "Input",
        description = "(Readonly) Input*",
        type = "value"
      },
      network = {
        valuetype = "Network",
        description = "(Readonly) Network*",
        type = "value"
      },
      cache = {
        valuetype = "ResourceCache",
        description = "(Readonly) ResourceCache*",
        type = "value"
      },
      ui = {
        valuetype = "UI",
        description = "(Readonly) UI*",
        type = "value"
      },

  -- Global Constants

      ANIMATION_LOD_BASESCALE = {
        description = "const float",
        type = "value"
      },
      CHANNEL_POSITION = {
        description = "const char",
        type = "value"
      },
      CHANNEL_ROTATION = {
        description = "const char",
        type = "value"
      },
      CHANNEL_SCALE = {
        description = "const char",
        type = "value"
      },
      CLEAR_COLOR = {
        description = "const unsigned",
        type = "value"
      },
      CLEAR_DEPTH = {
        description = "const unsigned",
        type = "value"
      },
      CLEAR_STENCIL = {
        description = "const unsigned",
        type = "value"
      },
      CONTROLLER_AXIS_LEFTX = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_LEFTY = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_RIGHTX = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_RIGHTY = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_TRIGGERLEFT = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_TRIGGERRIGHT = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_A = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_B = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_BACK = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_DPAD_DOWN = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_DPAD_LEFT = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_DPAD_RIGHT = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_DPAD_UP = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_GUIDE = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_LEFTSHOULDER = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_LEFTSTICK = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_RIGHTSHOULDER = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_RIGHTSTICK = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_START = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_X = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_Y = {
        description = "const int",
        type = "value"
      },
      DD_DISABLED = {
        description = "const unsigned",
        type = "value"
      },
      DD_SOURCE = {
        description = "const unsigned",
        type = "value"
      },
      DD_SOURCE_AND_TARGET = {
        description = "const unsigned",
        type = "value"
      },
      DD_TARGET = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_ALL = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_MODE = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_NONE = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_PROFILER = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_STATS = {
        description = "const unsigned",
        type = "value"
      },
      DEFAULT_LIGHTMASK = {
        description = "const unsigned",
        type = "value"
      },
      DEFAULT_SHADOWMASK = {
        description = "const unsigned",
        type = "value"
      },
      DEFAULT_VIEWMASK = {
        description = "const unsigned",
        type = "value"
      },
      DEFAULT_ZONEMASK = {
        description = "const unsigned",
        type = "value"
      },
      DRAWABLE_ANY = {
        description = "const unsigned",
        type = "value"
      },
      DRAWABLE_GEOMETRY = {
        description = "const unsigned",
        type = "value"
      },
      DRAWABLE_LIGHT = {
        description = "const unsigned",
        type = "value"
      },
      DRAWABLE_ZONE = {
        description = "const unsigned",
        type = "value"
      },
      FIRST_LOCAL_ID = {
        description = "const unsigned",
        type = "value"
      },
      FIRST_REPLICATED_ID = {
        description = "const unsigned",
        type = "value"
      },
      HAT_CENTER = {
        description = "const int",
        type = "value"
      },
      HAT_DOWN = {
        description = "const int",
        type = "value"
      },
      HAT_LEFT = {
        description = "const int",
        type = "value"
      },
      HAT_RIGHT = {
        description = "const int",
        type = "value"
      },
      HAT_UP = {
        description = "const int",
        type = "value"
      },
      INSTANCING_BUFFER_DEFAULT_SIZE = {
        description = "const int",
        type = "value"
      },
      KEY_0 = {
        description = "const int",
        type = "value"
      },
      KEY_1 = {
        description = "const int",
        type = "value"
      },
      KEY_2 = {
        description = "const int",
        type = "value"
      },
      KEY_3 = {
        description = "const int",
        type = "value"
      },
      KEY_4 = {
        description = "const int",
        type = "value"
      },
      KEY_5 = {
        description = "const int",
        type = "value"
      },
      KEY_6 = {
        description = "const int",
        type = "value"
      },
      KEY_7 = {
        description = "const int",
        type = "value"
      },
      KEY_8 = {
        description = "const int",
        type = "value"
      },
      KEY_9 = {
        description = "const int",
        type = "value"
      },
      KEY_A = {
        description = "const int",
        type = "value"
      },
      KEY_ADD = {
        description = "const int",
        type = "value"
      },
      KEY_ALT = {
        description = "const int",
        type = "value"
      },
      KEY_APPS = {
        description = "const int",
        type = "value"
      },
      KEY_B = {
        description = "const int",
        type = "value"
      },
      KEY_BACKSPACE = {
        description = "const int",
        type = "value"
      },
      KEY_C = {
        description = "const int",
        type = "value"
      },
      KEY_CAPSLOCK = {
        description = "const int",
        type = "value"
      },
      KEY_CTRL = {
        description = "const int",
        type = "value"
      },
      KEY_D = {
        description = "const int",
        type = "value"
      },
      KEY_DECIMAL = {
        description = "const int",
        type = "value"
      },
      KEY_DELETE = {
        description = "const int",
        type = "value"
      },
      KEY_DIVIDE = {
        description = "const int",
        type = "value"
      },
      KEY_DOWN = {
        description = "const int",
        type = "value"
      },
      KEY_E = {
        description = "const int",
        type = "value"
      },
      KEY_END = {
        description = "const int",
        type = "value"
      },
      KEY_ESC = {
        description = "const int",
        type = "value"
      },
      KEY_F = {
        description = "const int",
        type = "value"
      },
      KEY_F1 = {
        description = "const int",
        type = "value"
      },
      KEY_F10 = {
        description = "const int",
        type = "value"
      },
      KEY_F11 = {
        description = "const int",
        type = "value"
      },
      KEY_F12 = {
        description = "const int",
        type = "value"
      },
      KEY_F13 = {
        description = "const int",
        type = "value"
      },
      KEY_F14 = {
        description = "const int",
        type = "value"
      },
      KEY_F15 = {
        description = "const int",
        type = "value"
      },
      KEY_F16 = {
        description = "const int",
        type = "value"
      },
      KEY_F17 = {
        description = "const int",
        type = "value"
      },
      KEY_F18 = {
        description = "const int",
        type = "value"
      },
      KEY_F19 = {
        description = "const int",
        type = "value"
      },
      KEY_F2 = {
        description = "const int",
        type = "value"
      },
      KEY_F20 = {
        description = "const int",
        type = "value"
      },
      KEY_F21 = {
        description = "const int",
        type = "value"
      },
      KEY_F22 = {
        description = "const int",
        type = "value"
      },
      KEY_F23 = {
        description = "const int",
        type = "value"
      },
      KEY_F24 = {
        description = "const int",
        type = "value"
      },
      KEY_F3 = {
        description = "const int",
        type = "value"
      },
      KEY_F4 = {
        description = "const int",
        type = "value"
      },
      KEY_F5 = {
        description = "const int",
        type = "value"
      },
      KEY_F6 = {
        description = "const int",
        type = "value"
      },
      KEY_F7 = {
        description = "const int",
        type = "value"
      },
      KEY_F8 = {
        description = "const int",
        type = "value"
      },
      KEY_F9 = {
        description = "const int",
        type = "value"
      },
      KEY_G = {
        description = "const int",
        type = "value"
      },
      KEY_H = {
        description = "const int",
        type = "value"
      },
      KEY_HOME = {
        description = "const int",
        type = "value"
      },
      KEY_I = {
        description = "const int",
        type = "value"
      },
      KEY_INSERT = {
        description = "const int",
        type = "value"
      },
      KEY_J = {
        description = "const int",
        type = "value"
      },
      KEY_K = {
        description = "const int",
        type = "value"
      },
      KEY_KP_ENTER = {
        description = "const int",
        type = "value"
      },
      KEY_L = {
        description = "const int",
        type = "value"
      },
      KEY_LALT = {
        description = "const int",
        type = "value"
      },
      KEY_LCTRL = {
        description = "const int",
        type = "value"
      },
      KEY_LEFT = {
        description = "const int",
        type = "value"
      },
      KEY_LSHIFT = {
        description = "const int",
        type = "value"
      },
      KEY_LWIN = {
        description = "const int",
        type = "value"
      },
      KEY_M = {
        description = "const int",
        type = "value"
      },
      KEY_MULTIPLY = {
        description = "const int",
        type = "value"
      },
      KEY_N = {
        description = "const int",
        type = "value"
      },
      KEY_NUMLOCK = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD0 = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD1 = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD2 = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD3 = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD4 = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD5 = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD6 = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD7 = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD8 = {
        description = "const int",
        type = "value"
      },
      KEY_NUMPAD9 = {
        description = "const int",
        type = "value"
      },
      KEY_O = {
        description = "const int",
        type = "value"
      },
      KEY_P = {
        description = "const int",
        type = "value"
      },
      KEY_PAGEDOWN = {
        description = "const int",
        type = "value"
      },
      KEY_PAGEUP = {
        description = "const int",
        type = "value"
      },
      KEY_PAUSE = {
        description = "const int",
        type = "value"
      },
      KEY_PRINTSCREEN = {
        description = "const int",
        type = "value"
      },
      KEY_Q = {
        description = "const int",
        type = "value"
      },
      KEY_R = {
        description = "const int",
        type = "value"
      },
      KEY_RALT = {
        description = "const int",
        type = "value"
      },
      KEY_RCTRL = {
        description = "const int",
        type = "value"
      },
      KEY_RETURN = {
        description = "const int",
        type = "value"
      },
      KEY_RETURN2 = {
        description = "const int",
        type = "value"
      },
      KEY_RIGHT = {
        description = "const int",
        type = "value"
      },
      KEY_RSHIFT = {
        description = "const int",
        type = "value"
      },
      KEY_RWIN = {
        description = "const int",
        type = "value"
      },
      KEY_S = {
        description = "const int",
        type = "value"
      },
      KEY_SCROLLLOCK = {
        description = "const int",
        type = "value"
      },
      KEY_SELECT = {
        description = "const int",
        type = "value"
      },
      KEY_SHIFT = {
        description = "const int",
        type = "value"
      },
      KEY_SPACE = {
        description = "const int",
        type = "value"
      },
      KEY_SUBTRACT = {
        description = "const int",
        type = "value"
      },
      KEY_T = {
        description = "const int",
        type = "value"
      },
      KEY_TAB = {
        description = "const int",
        type = "value"
      },
      KEY_U = {
        description = "const int",
        type = "value"
      },
      KEY_UP = {
        description = "const int",
        type = "value"
      },
      KEY_V = {
        description = "const int",
        type = "value"
      },
      KEY_W = {
        description = "const int",
        type = "value"
      },
      KEY_X = {
        description = "const int",
        type = "value"
      },
      KEY_Y = {
        description = "const int",
        type = "value"
      },
      KEY_Z = {
        description = "const int",
        type = "value"
      },
      LAST_LOCAL_ID = {
        description = "const unsigned",
        type = "value"
      },
      LAST_REPLICATED_ID = {
        description = "const unsigned",
        type = "value"
      },
      LOG_DEBUG = {
        description = "const int",
        type = "value"
      },
      LOG_ERROR = {
        description = "const int",
        type = "value"
      },
      LOG_INFO = {
        description = "const int",
        type = "value"
      },
      LOG_NONE = {
        description = "const int",
        type = "value"
      },
      LOG_WARNING = {
        description = "const int",
        type = "value"
      },
      MAX_VERTEX_LIGHTS = {
        description = "const int",
        type = "value"
      },
      MOUSEB_LEFT = {
        description = "const int",
        type = "value"
      },
      MOUSEB_MIDDLE = {
        description = "const int",
        type = "value"
      },
      MOUSEB_RIGHT = {
        description = "const int",
        type = "value"
      },
      M_DEGTORAD = {
        description = "const float",
        type = "value"
      },
      M_DEGTORAD_2 = {
        description = "const float",
        type = "value"
      },
      M_EPSILON = {
        description = "const float",
        type = "value"
      },
      M_INFINITY = {
        description = "const float",
        type = "value"
      },
      M_LARGE_EPSILON = {
        description = "const float",
        type = "value"
      },
      M_LARGE_VALUE = {
        description = "const float",
        type = "value"
      },
      M_MAX_FOV = {
        description = "const float",
        type = "value"
      },
      M_MAX_INT = {
        description = "const int",
        type = "value"
      },
      M_MAX_UNSIGNED = {
        description = "const unsigned",
        type = "value"
      },
      M_MIN_INT = {
        description = "const int",
        type = "value"
      },
      M_MIN_NEARCLIP = {
        description = "const float",
        type = "value"
      },
      M_MIN_UNSIGNED = {
        description = "const unsigned",
        type = "value"
      },
      M_PI = {
        description = "const float",
        type = "value"
      },
      M_RADTODEG = {
        description = "const float",
        type = "value"
      },
      NUM_FRUSTUM_PLANES = {
        description = "const unsigned",
        type = "value"
      },
      NUM_FRUSTUM_VERTICES = {
        description = "const unsigned",
        type = "value"
      },
      QUALITY_HIGH = {
        description = "const int",
        type = "value"
      },
      QUALITY_LOW = {
        description = "const int",
        type = "value"
      },
      QUALITY_MAX = {
        description = "const int",
        type = "value"
      },
      QUALITY_MEDIUM = {
        description = "const int",
        type = "value"
      },
      QUAL_ALT = {
        description = "const int",
        type = "value"
      },
      QUAL_ANY = {
        description = "const int",
        type = "value"
      },
      QUAL_CTRL = {
        description = "const int",
        type = "value"
      },
      QUAL_SHIFT = {
        description = "const int",
        type = "value"
      },
      SCAN_DIRS = {
        description = "const unsigned",
        type = "value"
      },
      SCAN_FILES = {
        description = "const unsigned",
        type = "value"
      },
      SCAN_HIDDEN = {
        description = "const unsigned",
        type = "value"
      },
      SHADOWQUALITY_HIGH_16BIT = {
        description = "const int",
        type = "value"
      },
      SHADOWQUALITY_HIGH_24BIT = {
        description = "const int",
        type = "value"
      },
      SHADOWQUALITY_LOW_16BIT = {
        description = "const int",
        type = "value"
      },
      SHADOWQUALITY_LOW_24BIT = {
        description = "const int",
        type = "value"
      },
      SHADOW_MIN_PIXELS = {
        description = "const int",
        type = "value"
      },
      VO_DISABLE_OCCLUSION = {
        description = "const unsigned",
        type = "value"
      },
      VO_DISABLE_SHADOWS = {
        description = "const unsigned",
        type = "value"
      },
      VO_LOW_MATERIAL_QUALITY = {
        description = "const unsigned",
        type = "value"
      },
      VO_NONE = {
        description = "const unsigned",
        type = "value"
      },
}
return api
